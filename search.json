[{"title":"链表","url":"/2021/03/24/210324javaList/","content":"<h1 id=\"两数相加\"><a href=\"#两数相加\" class=\"headerlink\" title=\"两数相加\"></a>两数相加</h1><p><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">2.两数相加</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">    \tListNode head=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    \tListNode temp=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(l1!=<span class=\"keyword\">null</span>||l2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">int</span> n1 = l1!=<span class=\"keyword\">null</span> ? l1.val: <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n2 = l2!=<span class=\"keyword\">null</span> ? l2.val: <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = n1 + n2 + flag;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t\t\thead=temp=<span class=\"keyword\">new</span> ListNode(sum%<span class=\"number\">10</span>);</span><br><span class=\"line\">    \t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \t\t\ttemp.next=<span class=\"keyword\">new</span> ListNode(sum%<span class=\"number\">10</span>);</span><br><span class=\"line\">    \t\t\ttemp=temp.next;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\tflag=sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">    \t\t</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(l1!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t\t\tl1=l1.next;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(l2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t\t\tl2=l2.next;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(flag&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \t\ttemp.next=<span class=\"keyword\">new</span> ListNode(flag);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:注意空指针问题！</p>\n<h1 id=\"找出两个链表的交点\"><a href=\"#找出两个链表的交点\" class=\"headerlink\" title=\"找出两个链表的交点\"></a>找出两个链表的交点</h1><p> <a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">160. 相交链表</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">        ListNode l1=headA;</span><br><span class=\"line\">        ListNode l2=headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1!=l2)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                l1=headB;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                l1=l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l2==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                l2=headA;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                l2=l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"翻转链表\"><a href=\"#翻转链表\" class=\"headerlink\" title=\"翻转链表\"></a>翻转链表</h1><p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">206. 反转链表</a></p>\n<p>反转一个单链表。</p>\n<p><img src=\"https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode pre=head;</span><br><span class=\"line\">        ListNode cur=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pre!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            ListNode temp=pre.next;</span><br><span class=\"line\">            pre.next=cur;</span><br><span class=\"line\">            cur=pre;</span><br><span class=\"line\">            pre=temp;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span>||head.next==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode cur=reverseList(head.next);</span><br><span class=\"line\">        head.next.next=head;</span><br><span class=\"line\">        head.next=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"合并两个有序链表\"><a href=\"#合并两个有序链表\" class=\"headerlink\" title=\"合并两个有序链表\"></a>合并两个有序链表</h1><p> <a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\">21. 合并两个有序链表</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode nhead =<span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        ListNode temp=nhead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1!=<span class=\"keyword\">null</span>&amp;&amp;l2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class=\"line\">                temp.next=l1;</span><br><span class=\"line\">                l1=l1.next;</span><br><span class=\"line\">                temp=temp.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                temp.next=l2;</span><br><span class=\"line\">                l2=l2.next;</span><br><span class=\"line\">                temp=temp.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l1!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                temp.next=l1;</span><br><span class=\"line\">                l1=l1.next;</span><br><span class=\"line\">                temp=temp.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            temp.next=l2;</span><br><span class=\"line\">            l2=l2.next;</span><br><span class=\"line\">            temp=temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nhead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["算法"]},{"title":"常见数据结构时间复杂度","url":"/2021/03/26/210326cjdatabase/","content":"<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ul>\n<li>添加：O(1)</li>\n<li>删除：O(n）</li>\n<li>修改：O(1)</li>\n<li>查询：O(n)</li>\n<li>尺寸：O(1)</li>\n</ul>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><ul>\n<li>插入：O(1)，如果需要查找再插入则O(n)</li>\n<li>删除：O(1)，如果需要查找再删除则O(n)</li>\n<li>搜索：O(n)</li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li>推：O（1）</li>\n<li>Pop：O（1）</li>\n<li>上：O（1）</li>\n<li>搜索（像查找，像一个特殊的操作）：O（n）</li>\n</ul>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li>插入：O（1）</li>\n<li>删除：O（1）</li>\n<li>尺寸：O（1）</li>\n</ul>\n<h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><ul>\n<li>查找：O（1）</li>\n<li>插入：O（1）</li>\n<li>删除：可根据链表输入长度决定，在最坏情况下，链表长度为n，时间复杂度就为O（n）</li>\n</ul>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>最佳</th>\n<th>平均</th>\n<th>最差</th>\n<th>最差情况下的空间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>快速排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n*n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>冒泡排序</td>\n<td>O(n)</td>\n<td>O(n*n)</td>\n<td>O(n*n)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>O(n)</td>\n<td>O(n*n)</td>\n<td>O(n*n)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>O(n*n)</td>\n<td>O(n*n)</td>\n<td>O(n*n)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>桶排序</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n*n)</td>\n<td>O(nk)</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>O(nk)</td>\n<td>O(nk)</td>\n<td>O(nk)</td>\n<td>O(n+k)</td>\n</tr>\n</tbody></table>\n<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>平均</th>\n<th>最差</th>\n<th>最差空间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>深度优先搜索(DFS)</td>\n<td>-</td>\n<td>O(E+V)</td>\n<td>O(V)</td>\n</tr>\n<tr>\n<td>广度优先搜索(BFS)</td>\n<td>-</td>\n<td>O(E+V)</td>\n<td>O(V)</td>\n</tr>\n<tr>\n<td>二分查找</td>\n<td>O(logn)</td>\n<td>O(logn)</td>\n<td>O(1)</td>\n</tr>\n</tbody></table>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://www.jianshu.com/p/99ae14b48c0f\">https://www.jianshu.com/p/99ae14b48c0f</a></p>\n"},{"title":"数据结构","url":"/2021/03/26/210326datastructure/","content":"<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h2 id=\"二叉树查找的时间复杂度\"><a href=\"#二叉树查找的时间复杂度\" class=\"headerlink\" title=\"二叉树查找的时间复杂度\"></a>二叉树查找的时间复杂度</h2><p>如果<strong>二叉排序树是平衡</strong>的，则n个节点的二叉排序树的高度为Log2(n+1),其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。</p>\n<h2 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">PreOrder</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.printIn(root);</span><br><span class=\"line\">    PreOrder(root.left);</span><br><span class=\"line\">    PreOrder(root.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">\tList&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\tStack&lt;TreeNode&gt; stack =<span class=\"keyword\">new</span> Stack &lt;&gt;();</span><br><span class=\"line\">\tstack.push(root);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">\t\tTreeNode node =stack.pop();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(node==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tret.add(node.val);</span><br><span class=\"line\">\t\tstack.push(node.right);<span class=\"comment\">//先右后左，保证左子树先出来</span></span><br><span class=\"line\">\t\tstack.push(node.left);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    dfs(root.left);</span><br><span class=\"line\">    dfs(root.right);</span><br><span class=\"line\">    visit(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node = stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        ret.add(node.val);</span><br><span class=\"line\">        stack.push(node.left);</span><br><span class=\"line\">        stack.push(node.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Collections.reverse(ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一种写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        TreeNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right == <span class=\"keyword\">null</span> || root.right == prev) &#123;</span><br><span class=\"line\">                res.add(root.val);</span><br><span class=\"line\">                prev = root;</span><br><span class=\"line\">                root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    dfs(root.left);</span><br><span class=\"line\">    visit(root);</span><br><span class=\"line\">    dfs(root.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    TreeNode cur = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(cur);</span><br><span class=\"line\">            cur = cur.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode node = stack.pop();</span><br><span class=\"line\">        ret.add(node.val);</span><br><span class=\"line\">        cur = node.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h1>"},{"title":"位运算","url":"/2021/03/24/210324weiyunsuan/","content":"<h1 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h1><p>0s 表示一串 0，1s 表示一串 1。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">x ^ 0s = x      x &amp; 0s = 0      x | 0s = x</span><br><span class=\"line\">x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s</span><br><span class=\"line\">x ^ x = 0       x &amp; x = x       x | x = x</span><br></pre></td></tr></table></figure>\n\n<p>利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">1^1^2 = 2</span><br></pre></td></tr></table></figure>\n\n<p>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 &amp;</span><br><span class=\"line\">00111100</span><br><span class=\"line\">--------</span><br><span class=\"line\">00011000</span><br></pre></td></tr></table></figure>\n\n<p>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 |</span><br><span class=\"line\">00111100</span><br><span class=\"line\">--------</span><br><span class=\"line\">01111111</span><br></pre></td></tr></table></figure>\n\n<p><strong>位与运算技巧</strong></p>\n<p>n&amp;(n-1) 去除 n 的位级表示中<strong>最低</strong>的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 &amp;</span><br><span class=\"line\">01011010</span><br><span class=\"line\">--------</span><br><span class=\"line\">01011010</span><br></pre></td></tr></table></figure>\n\n<p>n&amp;(-n) 得到 n 的位级表示中<strong>最低</strong>的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">10110100 &amp;</span><br><span class=\"line\">01001100</span><br><span class=\"line\">--------</span><br><span class=\"line\">00000100</span><br></pre></td></tr></table></figure>\n\n<p>n-(n&amp;(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&amp;(n-1) 效果一样。</p>\n<p><strong>移位运算</strong></p>\n<p>&gt;&gt; n 为算术右移，相当于除以 2n，例如 -7 &gt;&gt; 2 = -2。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &gt;&gt; 2</span><br><span class=\"line\">--------</span><br><span class=\"line\">11111111111111111111111111111110</span><br></pre></td></tr></table></figure>\n\n<p>&gt;&gt;&gt; n 为无符号右移，左边会补上 0。例如 -7 &gt;&gt;&gt; 2 = 1073741822。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &gt;&gt;&gt; 2</span><br><span class=\"line\">--------</span><br><span class=\"line\">00111111111111111111111111111111</span><br></pre></td></tr></table></figure>\n\n<p>&lt;&lt; n 为算术左移，相当于乘以 2n。-7 &lt;&lt; 2 = -28。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &lt;&lt; 2</span><br><span class=\"line\">--------</span><br><span class=\"line\">11111111111111111111111111100100</span><br></pre></td></tr></table></figure>\n\n<p><strong>mask 计算</strong></p>\n<p>要获取 111111111，将 0 取反即可，~0。</p>\n<p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p>\n<p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111。</p>\n<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p>\n<p><strong>Java 中的位操作</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">static int Integer.bitCount();           // 统计 1 的数量</span><br><span class=\"line\">static int Integer.highestOneBit();      // 获得最高位</span><br><span class=\"line\">static String toBinaryString(int i);     // 转换为二进制表示的字符串</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"汉明距离\"><a href=\"#汉明距离\" class=\"headerlink\" title=\"汉明距离\"></a>汉明距离</h1><p><a href=\"https://leetcode-cn.com/problems/hamming-distance/\">461.汉明距离</a></p>\n<p>两个整数之间的<a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> z=x^y;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(z!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((z&amp;<span class=\"number\">1</span>)==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            z=z &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:采取异或的方法看有哪几位是不同的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> z=x^y;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(z!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            z&amp;=(z-<span class=\"number\">1</span>);</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ps：通过z&amp;(z-1)来清除最低位的1。</p>\n<h1 id=\"只出现一次的数字\"><a href=\"#只出现一次的数字\" class=\"headerlink\" title=\"只出现一次的数字\"></a>只出现一次的数字</h1><p><a href=\"https://leetcode-cn.com/problems/single-number/\">136.只出现一次的数字</a></p>\n<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num: nums)&#123;</span><br><span class=\"line\">            ret=ret^num;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"只出现一次的数字III\"><a href=\"#只出现一次的数字III\" class=\"headerlink\" title=\"只出现一次的数字III\"></a>只出现一次的数字III</h1><p><a href=\"https://leetcode-cn.com/problems/single-number-iii/\">260.只出现一次的数字III</a></p>\n<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] singleNumber(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> div=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num:nums)&#123;</span><br><span class=\"line\">            div^=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        div&amp;=-div;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans=&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num:nums)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((div&amp;num)==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                ans[<span class=\"number\">0</span>]=ans[<span class=\"number\">0</span>]^num;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                ans[<span class=\"number\">1</span>]=ans[<span class=\"number\">1</span>]^num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps：通过z&amp;(-z)获得中<strong>最低</strong>的那一位</p>\n<h1 id=\"丢失的数字\"><a href=\"#丢失的数字\" class=\"headerlink\" title=\"丢失的数字\"></a>丢失的数字</h1><p><a href=\"https://leetcode-cn.com/problems/missing-number/\">268.丢失的数字</a></p>\n<p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> target=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=nums.length ;i++ ) &#123;</span><br><span class=\"line\">            target=target^i^nums[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:采用的就是x^x=0的思想</p>\n<h1 id=\"颠倒二进制位\"><a href=\"#颠倒二进制位\" class=\"headerlink\" title=\"颠倒二进制位\"></a>颠倒二进制位</h1><p> <a href=\"https://leetcode-cn.com/problems/reverse-bits/\">190. 颠倒二进制位</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">32</span>;i++)&#123;</span><br><span class=\"line\">            ret=ret&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">            ret |=(n&amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">            n=n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:借助n&amp;1是最后一位，然后进行操作。</p>\n<h1 id=\"2的幂\"><a href=\"#2的幂\" class=\"headerlink\" title=\"2的幂\"></a>2的幂</h1><p> <a href=\"https://leetcode-cn.com/problems/power-of-two/\">231. 2的幂</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n&gt;<span class=\"number\">0</span> &amp;&amp; (n&amp;(n-<span class=\"number\">1</span>))==<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:使用n&amp;(n-1)为去除最低的1。</p>\n<h1 id=\"比特位计数\"><a href=\"#比特位计数\" class=\"headerlink\" title=\"比特位计数\"></a>比特位计数</h1><p> <a href=\"https://leetcode-cn.com/problems/counting-bits/\">338. 比特位计数</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countBits(<span class=\"keyword\">int</span> num) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ret=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[num+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=num;i++)&#123;</span><br><span class=\"line\">            ret[i]=ret[i&amp;(i-<span class=\"number\">1</span>)]+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:还是采用了i&amp;(i-1)为最低位的1思想。</p>\n","categories":["算法"],"tags":["位运算"]},{"title":"竞技世界面试复盘","url":"/2021/03/29/210329jjworldfupan/","content":"<h1 id=\"RAM和ROM\"><a href=\"#RAM和ROM\" class=\"headerlink\" title=\"RAM和ROM\"></a>RAM和ROM</h1><p>RAM（random access memory）即随机存储内存，这种存储器在断电时将丢失其存储内容，故主要用于存储短时间使用的程序。ROM（Read-Only Memory）即只读内存，是一种只能读出事先所存数据的固态半导体存储器。</p>\n<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><p>虚拟内存是操作系统内核为了对进程地址空间进行管理（process address space management）而精心设计的一个逻辑意义上的内存空间概念。</p>\n<p>用户编制程序时使用的地址称为<strong>虚地址或逻辑地址</strong>，其对应的存储空间称为虚存空间或逻辑地址空间；而计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。</p>\n<p><strong>引入虚拟存储技术的好处</strong>：<br>可在较小的可用内存中执行较大的用户程序；<br>可在内存中容纳更多程序并发执行；<br>不必影响编程时的程序结构（与覆盖技术比较）；</p>\n<p>提供给用户可用的虚拟内存空间通常大于物理内存。</p>\n<h1 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h1><p>理论上<em>SMTP</em>可以通过TCP,UDP或某些第三方协议来处理</p>\n<p>DHCP 用的是UDP</p>\n<h1 id=\"数据库主键\"><a href=\"#数据库主键\" class=\"headerlink\" title=\"数据库主键\"></a>数据库主键</h1><p><em>主键</em>只有一个,但是可以设置为多个字段为<em>主键</em>,也即联合<em>主键</em>。</p>\n<h1 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] quicksort(<span class=\"keyword\">int</span> []arr,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = high;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> key = arr[start];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(end &gt; start)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(end &gt; start&amp;&amp;arr[end]&gt;=key)&#123;</span><br><span class=\"line\">            end--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[end]&lt;=key)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp=arr[end];</span><br><span class=\"line\">            arr[end]=arr[start];</span><br><span class=\"line\">            arr[start]=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(end&gt;start&amp;&amp;arr[start]&lt;=key)&#123;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[start]&gt;=key)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> temp=arr[start];</span><br><span class=\"line\">            arr[start]=arr[end];</span><br><span class=\"line\">            arr[end]=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h1><p>使用哈夫曼编码来编码字符串”aaaabbcd”时，得到的编码长度为多少?</p>\n<p><a href=\"https://blog.csdn.net/weixin_43247186/article/details/87855415\">https://blog.csdn.net/weixin_43247186/article/details/87855415</a></p>\n<h1 id=\"字节\"><a href=\"#字节\" class=\"headerlink\" title=\"字节\"></a>字节</h1><p><em>字节是</em>一个存储单位 1个二进制位等于1Bit 8个Bit等于<em>1Byte</em>(字节)</p>\n<p>C语言会自动在在双引号””括起来的内容的末尾补上”\\0”代表结束，ASCII中的0号位也占用一个字符。</p>\n<p>注意，了解了sizeof的真正含义后。类似如下的代码就很low了。</p>\n<h1 id=\"大小端\"><a href=\"#大小端\" class=\"headerlink\" title=\"大小端\"></a>大小端</h1><p><strong>（数据看成字符串）</strong>大端——高尾端，小端——低尾端</p>\n<p>我们的电脑通常是小端存储</p>\n<h2 id=\"大小端各自的优点\"><a href=\"#大小端各自的优点\" class=\"headerlink\" title=\"大小端各自的优点\"></a>大小端各自的优点</h2><p>大端：符号位在所表示的内存的低地址，用于快速判断数据的正负和大小<br>小端：CPU做数值运算的时候是从内存中依次从低位到高位取数据进行运算，这样运算效率更高。</p>\n<h1 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h1><p>并发是指一个处理器同时处理多个任务。<br>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。<br>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。<br>来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。</p>\n<p>当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。</p>\n<p>当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]并发并行的区别<a href=\"https://blog.csdn.net/java_zero2one/article/details/51477791\">https://blog.csdn.net/java_zero2one/article/details/51477791</a></p>\n"},{"title":"Java常用集合类","url":"/2021/04/04/210404Java-jihelei/","content":"<h1 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h1><p>inkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p>\n<h2 id=\"新建队列\"><a href=\"#新建队列\" class=\"headerlink\" title=\"新建队列\"></a><strong>新建队列</strong></h2><p>Queue<String> queue=new LinkedList<Steing>;</p>\n<h2 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a><strong>添加元素</strong></h2><p>queue.offer(“a”);</p>\n<h2 id=\"返回第一个元素，并在队列中删除\"><a href=\"#返回第一个元素，并在队列中删除\" class=\"headerlink\" title=\"返回第一个元素，并在队列中删除\"></a><strong>返回第一个元素，并在队列中删除</strong></h2><p>queue.poll();</p>\n<h2 id=\"返回第一个元素\"><a href=\"#返回第一个元素\" class=\"headerlink\" title=\"返回第一个元素\"></a><strong>返回第一个元素</strong></h2><p>queue.element();</p>\n<p>或者</p>\n<p>queue.peek();</p>\n<h1 id=\"Deque\"><a href=\"#Deque\" class=\"headerlink\" title=\"Deque\"></a><strong>Deque</strong></h1><p>双端队列（两端都可进出）</p>\n<h2 id=\"新建\"><a href=\"#新建\" class=\"headerlink\" title=\"新建\"></a><strong>新建</strong></h2><p>Deque<String>  deque= new LinkList&lt;&gt;();</p>\n<h2 id=\"相关函数\"><a href=\"#相关函数\" class=\"headerlink\" title=\"相关函数\"></a><strong>相关函数</strong></h2><p><img src=\"/images/pasted-210404.jpg\"></p>\n<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><h2 id=\"新建-1\"><a href=\"#新建-1\" class=\"headerlink\" title=\"新建\"></a><strong>新建</strong></h2><p>ArrayList<String> arraylist=new ArrayList<String>();</p>\n<h2 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a><strong>访问元素</strong></h2><p>arraylist.get(0);//访问第1个元素</p>\n<h2 id=\"修改元素\"><a href=\"#修改元素\" class=\"headerlink\" title=\"修改元素\"></a><strong>修改元素</strong></h2><p>arraylist.set(2,”wiki”);</p>\n<h2 id=\"计算大小\"><a href=\"#计算大小\" class=\"headerlink\" title=\"计算大小\"></a><strong>计算大小</strong></h2><p>arraylist.size();</p>\n<h2 id=\"ArrayList排序\"><a href=\"#ArrayList排序\" class=\"headerlink\" title=\"ArrayList排序\"></a><strong>ArrayList排序</strong></h2><p>Collections.sort(arraylist);</p>\n<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a><strong>LinkedList</strong></h1><h2 id=\"与ArrayList的使用对比\"><a href=\"#与ArrayList的使用对比\" class=\"headerlink\" title=\"与ArrayList的使用对比\"></a><strong>与ArrayList的使用对比</strong></h2><p>以下情况使用 ArrayList :</p>\n<p>频繁访问列表中的某一个元素。</p>\n<p>只需要在列表末尾进行添加和删除元素操作。</p>\n<p>以下情况使用 LinkedList :</p>\n<p>你需要通过循环迭代来访问列表中的某些元素。</p>\n<p>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</p>\n<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a><strong>创建</strong></h2><p>LinkList<E> list=new LinkList<E>();</p>\n<h2 id=\"开头添加-移除-获取元素\"><a href=\"#开头添加-移除-获取元素\" class=\"headerlink\" title=\"开头添加/移除/获取元素\"></a><strong>开头添加/移除/获取元素</strong></h2><p>list.addFirst(“Wiki”);</p>\n<p>list.removeFirst();</p>\n<p>list.getFirst();</p>\n<h2 id=\"结尾添加元素\"><a href=\"#结尾添加元素\" class=\"headerlink\" title=\"结尾添加元素\"></a><strong>结尾添加元素</strong></h2><p>list.addLast(“hello”);</p>\n<p>list.removeLast();</p>\n<p>list.getLast();</p>\n<h1 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h1><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>\n<p>HashSet 允许有 null 值。</p>\n<p>HashSet 是无序的，即不会记录插入的顺序。</p>\n<p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p>\n<p>HashSet 实现了 Set 接口。</p>\n<h2 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a><strong>创建</strong></h2><p>HashSet<String> hashset=new HashSet<String>();</p>\n<h2 id=\"添加元素-1\"><a href=\"#添加元素-1\" class=\"headerlink\" title=\"添加元素\"></a><strong>添加元素</strong></h2><p>hashset.add(“Google”);</p>\n<p>注意，重复的元素不会被添加。</p>\n<h2 id=\"判断元素是否存在\"><a href=\"#判断元素是否存在\" class=\"headerlink\" title=\"判断元素是否存在\"></a><strong>判断元素是否存在</strong></h2><p>hashset.contains(“TaoBao”);</p>\n<h2 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a><strong>删除元素</strong></h2><p>hashset.remove(“TaoBao”);</p>\n<h2 id=\"计算大小-1\"><a href=\"#计算大小-1\" class=\"headerlink\" title=\"计算大小\"></a><strong>计算大小</strong></h2><p>hashset.size();</p>\n<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a><strong>HashMap</strong></h1><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>\n<p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p>\n<p>HashMap 是无序的，即不会记录插入的顺序。</p>\n<p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p>\n<h2 id=\"新建-2\"><a href=\"#新建-2\" class=\"headerlink\" title=\"新建\"></a><strong>新建</strong></h2><p>HashMap&lt;Integer,String&gt; Sites=new HashMap&lt;Integer,String&gt;();</p>\n<h2 id=\"添加元素-2\"><a href=\"#添加元素-2\" class=\"headerlink\" title=\"添加元素\"></a><strong>添加元素</strong></h2><p>Sites.put(1,”Google”);</p>\n<h2 id=\"访问元素-1\"><a href=\"#访问元素-1\" class=\"headerlink\" title=\"访问元素\"></a><strong>访问元素</strong></h2><p>Sites.get(1);</p>\n<p>使用get方法来获取key对应的value</p>\n<h2 id=\"删除元素-1\"><a href=\"#删除元素-1\" class=\"headerlink\" title=\"删除元素\"></a><strong>删除元素</strong></h2><p>Sites.remove(1);</p>\n<p>使用 remove(key) 方法来删除 key 对应的键值对(key-value)</p>\n<p>删除所有键值对可以使用clear方法</p>\n<p>Sites.clear();</p>\n<h2 id=\"计算大小-2\"><a href=\"#计算大小-2\" class=\"headerlink\" title=\"计算大小\"></a><strong>计算大小</strong></h2><p>Sites.size();</p>\n<h2 id=\"存在key-value\"><a href=\"#存在key-value\" class=\"headerlink\" title=\"存在key/value\"></a><strong>存在key/value</strong></h2><p>Sites.containsKey(1);</p>\n<p>Sites.containsValue(“Google”);</p>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>迭代HashMap:如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。</p>\n<h2 id=\"返回或者默认值\"><a href=\"#返回或者默认值\" class=\"headerlink\" title=\"返回或者默认值\"></a>返回或者默认值</h2><p>获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值：getOrDefault()</p>\n<h1 id=\"Java-Stack\"><a href=\"#Java-Stack\" class=\"headerlink\" title=\"Java Stack\"></a><strong>Java Stack</strong></h1><h2 id=\"新建-3\"><a href=\"#新建-3\" class=\"headerlink\" title=\"新建\"></a><strong>新建</strong></h2><p>Stack<Integer> st=new Stack<Integer>();</p>\n<h2 id=\"常见方法\"><a href=\"#常见方法\" class=\"headerlink\" title=\"常见方法\"></a>常见方法</h2><p><img src=\"/images/pasted-210404stack.jpg\"></p>\n<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><h2 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h2><p>length()</p>\n<h2 id=\"连接字符串\"><a href=\"#连接字符串\" class=\"headerlink\" title=\"连接字符串\"></a>连接字符串</h2><p>concat()</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><p>charAt(int index) ：返回指定索引处的 char 值。</p>\n<p>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引。</p>\n<p><a href=\"https://www.runoob.com/java/java-string-indexof.html\"> int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p>\n<h1 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h1><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">public delete(int start, int end) 移除此序列的子字符串中的字符。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>\n</tr>\n</tbody></table>\n","categories":["Java"]},{"title":"兄弟们冲冲冲！","url":"/2021/03/16/first%20blog/","content":"<h1 id=\"欢迎来到我的blog\"><a href=\"#欢迎来到我的blog\" class=\"headerlink\" title=\"欢迎来到我的blog\"></a>欢迎来到我的blog</h1><p>然后懒人表示什么都没有更新！<br>记得别咸鱼！</p>\n"},{"title":"数据结构面经","url":"/2021/04/10/datastrcture210410/","content":"<h1 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h1><p>性质 1：节点非红即黑。</p>\n<p>性质 2：根节点永远是黑色的。</p>\n<p>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</p>\n<p>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p>\n<p>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>\n<p>红黑树最重要的性质：从根到叶子的最长的可能路径小于等于最短的可能路径的两倍长。 红黑树并不是真正意义上的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。(对于AVL树，任何一个节点的两个子树高度差不会超过 1；对于红黑树，则是不会相差两倍以上)对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。对于红黑树，插入，删除，查找的复杂度都是 O(log N)。任何不平衡都会在3次旋转之内解决。</p>\n<h2 id=\"红黑树插入问题\"><a href=\"#红黑树插入问题\" class=\"headerlink\" title=\"红黑树插入问题\"></a>红黑树插入问题</h2><p>假设我们插入的新节点为 X</p>\n<ol>\n<li>将新插入的节点标记为红色</li>\n<li>如果 X 是根结点(root)，则标记为黑色</li>\n<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>\n</ol>\n<ul>\n<li><p>3.1 如果 X 的 uncle (叔叔) 是红色</p>\n</li>\n<li><ul>\n<li>3.1.1 将 parent 和 uncle 标记为黑色</li>\n<li>3.1.2 将 grand parent (祖父) 标记为红色</li>\n<li>3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li>\n</ul>\n</li>\n</ul>\n<p>话不多说，看下图</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-1d35b926316397d82c267593042f8c3f_720w.jpg\" alt=\"img\"></p>\n<p>跟着上面的公式走:</p>\n<ol>\n<li>将新插入的 X 节点标记为红色</li>\n<li>发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」</li>\n<li>发现 X 的 uncle (U) 同样为红色</li>\n<li>将 P 和 U 标记为黑色</li>\n<li>将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3</li>\n<li>发现 G 是根结点，标记为黑色</li>\n<li>结束</li>\n</ol>\n<p>刚刚说了 X 的 uncle 是红色的情况，接下来要说是<strong>黑色</strong>的情况</p>\n<ol>\n<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>\n</ol>\n<ul>\n<li><p>3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理</p>\n</li>\n<li><ul>\n<li>3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)</li>\n<li>3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)</li>\n<li>3.2.3 右右 (和 3.2.1 镜像过来，恰好相反)</li>\n<li>3.2.4 右左 (和 3.2.2 镜像过来，恰好相 【】【反)</li>\n</ul>\n</li>\n</ul>\n<p>当出现 uncle 是黑色的时候我们第一步要考虑的是 <strong>旋转</strong> ，这里先请小伙伴<strong>不要关注红黑树的第 4 条规则</strong>，主要是为了演示如何旋转的，来一点点看，不要看图就慌，有解释的 :</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"左左\"><a href=\"#左左\" class=\"headerlink\" title=\"左左\"></a>左左</h3><p>这种情况很简单，想象这是一根绳子，手提起 P 节点，然后变色即可</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-9e139a0f8b4a5e00ca8e643e2130403c_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"左右\"><a href=\"#左右\" class=\"headerlink\" title=\"左右\"></a>左右</h3><p>左旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的左孩子，然后再应用 <strong>左左情况</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-3fb33fbb3a42e34ed8a058a047a44cc3_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"右右\"><a href=\"#右右\" class=\"headerlink\" title=\"右右\"></a>右右</h3><p>与左左情况一样，想象成一根绳子</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-62a42ada09cb4547191aa4b9051c7c23_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"右左\"><a href=\"#右左\" class=\"headerlink\" title=\"右左\"></a>右左</h3><p>右旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的右孩子，然后再应用 <strong>右右情况</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg\" alt=\"img\"></p>\n<h1 id=\"ArrayList的扩容机制\"><a href=\"#ArrayList的扩容机制\" class=\"headerlink\" title=\"ArrayList的扩容机制\"></a>ArrayList的扩容机制</h1><p>ArrayList扩容发生在add()方法调用的时候，下面是add()方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">//扩容</span></span><br><span class=\"line\"> ensureCapacityInternal(size + <span class=\"number\">1</span>); <span class=\"comment\">//Increments modCount!!</span></span><br><span class=\"line\"> elementData[size++] = e; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;   </span><br><span class=\"line\"> &#125;         </span><br></pre></td></tr></table></figure>\n\n<p>ArrayList扩容的关键方法grow():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到ArrayList中elementData数组的内存空间长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容至原来的1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//若预设值大于默认的最大值检查是否溢出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间</span></span><br><span class=\"line\">    <span class=\"comment\">// 并将elementData的数据复制到新的内存空间</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;          </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"HashMap-的底层实现、JDK-1-8-的时候为啥将链表转换成红黑树？HashMap-的负载因子\"><a href=\"#HashMap-的底层实现、JDK-1-8-的时候为啥将链表转换成红黑树？HashMap-的负载因子\" class=\"headerlink\" title=\"HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子\"></a>HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子</h1><p>HashMap是用<strong>数组+链表+红黑树</strong>进行实现的，当添加一个元素（key-value）时，就首先计 算元素key的hash值，并根据hash值来确定插入数组中的位置，但是可能存在其他元素已经 被放在数组同一位置了，这个时候便使用链表来解决哈希冲突，当链表长度太长的时候，便 将链表转换为红黑树来提高搜索的效率。</p>\n<p>HashMap是基于拉链法实现的一个散列表，内部由数组和链表和红黑树实现。</p>\n<ol>\n<li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。</li>\n<li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造传入。</li>\n<li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（&gt;=8）， 会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（&lt;=6），又会将红黑树转换回单向链表提高性能，这里是一个平衡点。</li>\n</ol>\n<h1 id=\"有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？-线程安全的集合类\"><a href=\"#有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？-线程安全的集合类\" class=\"headerlink\" title=\"有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？ 线程安全的集合类.\"></a>有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？ 线程安全的集合类.</h1><p>Vector Stack Hashtable</p>\n<p>java.util.concurrent包下所有的集合类（ConcurrentHashMap，CopyOnWriteArrayList和CopyOnWriteArraySet等）</p>\n<h1 id=\"HashMap-多线程操作导致死循环问题异常\"><a href=\"#HashMap-多线程操作导致死循环问题异常\" class=\"headerlink\" title=\"HashMap 多线程操作导致死循环问题异常\"></a>HashMap 多线程操作导致死循环问题异常</h1><p>主要原因在于并发下的 rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。</p>\n","categories":["数据结构"],"tags":["面试"]},{"title":"算法复习","url":"/2021/03/20/java-suanfa/","content":"<h1 id=\"二分查找算法\"><a href=\"#二分查找算法\" class=\"headerlink\" title=\"二分查找算法\"></a>二分查找算法</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarysearch</span><span class=\"params\">(<span class=\"keyword\">int</span> []array,<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high=array.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(low&lt;=high)&#123;</span><br><span class=\"line\">        mid=(low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array[mid]==a)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a&gt;array[mid])&#123;</span><br><span class=\"line\">            low=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            high=mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"冒泡算法\"><a href=\"#冒泡算法\" class=\"headerlink\" title=\"冒泡算法\"></a>冒泡算法</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] bubbleSort(<span class=\"keyword\">int</span>[] arr)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;arr.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;arr.length-<span class=\"number\">1</span>-i;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(arr[j]&gt;arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j]=arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tarr[j+<span class=\"number\">1</span>]=temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] insertSort(<span class=\"keyword\">int</span>[] arr)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> insertVal=arr[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> index=i-<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(index&gt;=<span class=\"number\">0</span>&amp;&amp;insertVal&lt;arr[index])&#123;</span><br><span class=\"line\">\t\t\tarr[index+<span class=\"number\">1</span>]=arr[index];</span><br><span class=\"line\">\t\t\tindex--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarr[index+<span class=\"number\">1</span>]=insertVal;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> []quickSort(<span class=\"keyword\">int</span> []arr,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start=low;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> end=high;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> key=arr[start];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(end&gt;start)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(end&gt;start&amp;&amp;arr[end]&gt;=key)&#123;</span><br><span class=\"line\">\t\t\tend--;<span class=\"comment\">//找到比key小的值</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr[end]&lt;=key)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> temp=arr[end];</span><br><span class=\"line\">\t\t\tarr[end]=arr[start];</span><br><span class=\"line\">\t\t\tarr[start]=temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(end&gt;start&amp;&amp;arr[start]&lt;=key)&#123;</span><br><span class=\"line\">\t\t\tstart++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr[start]&gt;=key)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> temp=arr[start];</span><br><span class=\"line\">\t\t\tarr[start]=arr[end];</span><br><span class=\"line\">\t\t\tarr[end]=temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//递归左边序列</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(start&gt;low)&#123;</span><br><span class=\"line\">\t\tquickSort(arr,low,start-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//递归右边序列-+4</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(end&lt;high)&#123;</span><br><span class=\"line\">\t\tquickSort(arr.end+<span class=\"number\">1</span>,high);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["Java"]},{"title":"自己写输入输出问题","url":"/2021/03/20/javacode-io/","content":"<h1 id=\"1-基本定义\"><a href=\"#1-基本定义\" class=\"headerlink\" title=\"1. 基本定义\"></a>1. 基本定义</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tScanner cin1 = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        Scanner cin2 = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> BufferedInputStream(System.in));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用cin2进行输入的时候会比cin1快一些。</p>\n<h1 id=\"2-输入具体数据\"><a href=\"#2-输入具体数据\" class=\"headerlink\" title=\"2. 输入具体数据\"></a>2. 输入具体数据</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = cin.nextInt();<span class=\"comment\">//输入一个整数</span></span><br><span class=\"line\">String s = cin.next();<span class=\"comment\">//输入一个字符串</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> f = cin.nextDouble();<span class=\"comment\">//输入一个浮点数</span></span><br><span class=\"line\">String s = cin.nextLine();<span class=\"comment\">//输入一整行</span></span><br></pre></td></tr></table></figure>\n\n<p>可以使用cin.hasNext()来判断是否有下一个输入</p>\n<h1 id=\"3-基本输出\"><a href=\"#3-基本输出\" class=\"headerlink\" title=\"3. 基本输出\"></a>3. 基本输出</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.out.print();  <span class=\"comment\">//类似于cout&lt;&lt;…….;</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println();  <span class=\"comment\">//类似于cout&lt;&lt;……&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.printf();  <span class=\"comment\">//类似于C中printf的功能</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-要求具体精度输出\"><a href=\"#4-要求具体精度输出\" class=\"headerlink\" title=\"4. 要求具体精度输出\"></a>4. 要求具体精度输出</h1><p>（1）可以使用上面介绍的System.out.printf();</p>\n<p>（2）对于输出浮点数要保留几位小数的问题，可以使用DecimalFormat类解决</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> pi = <span class=\"number\">3.1415927</span>;<span class=\"comment\">//圆周率</span></span><br><span class=\"line\"><span class=\"comment\">//取一位整数</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;0&quot;</span>).format(pi));<span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"comment\">//取一位整数和两位小数</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;0.00&quot;</span>).format(pi));<span class=\"comment\">//3.14</span></span><br><span class=\"line\"><span class=\"comment\">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;00.000&quot;</span>).format(pi));<span class=\"comment\">// 03.142</span></span><br><span class=\"line\"><span class=\"comment\">//取所有整数部分</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;#&quot;</span>).format(pi));<span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"comment\">//以百分比方式计数，并取两位小数</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;#.##%&quot;</span>).format(pi));<span class=\"comment\">//314.16%</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-字符串的处理\"><a href=\"#5-字符串的处理\" class=\"headerlink\" title=\"5. 字符串的处理\"></a>5. 字符串的处理</h1><p>String。Java中字符串String是不可以修改的，要修改只能转换为字符数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String st = <span class=\"string\">&quot;abcdefg&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] ch;</span><br><span class=\"line\"></span><br><span class=\"line\">ch = st.toCharArray(); <span class=\"comment\">// 字符串转换为字符数组.</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"6-实例\"><a href=\"#6-实例\" class=\"headerlink\" title=\"6. 实例\"></a>6. 实例</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        String[] params = br.readLine().trim().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = Integer.parseInt(params[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = Integer.parseInt(params[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = Integer.parseInt(params[<span class=\"number\">2</span>]);</span><br><span class=\"line\">        String[] strArr = br.readLine().trim().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] scores = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) scores[i] = Integer.parseInt(strArr[i]);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有输入输出写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        BufferedWriter writer = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(System.out));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> T = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> N = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">            String tables = reader.readLine();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> M = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">            String enters = reader.readLine();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] res = solve(tables, enters);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r : res) &#123;</span><br><span class=\"line\">                writer.write(Integer.toString(r));</span><br><span class=\"line\">                writer.newLine();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        writer.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["Java"]},{"title":"HTML学习","url":"/2021/03/18/html-learning/","content":"<h1 id=\"HTML简介\"><a href=\"#HTML简介\" class=\"headerlink\" title=\"HTML简介\"></a>HTML简介</h1><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>html learning<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>标题一<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>段落一<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>!DOCTYPE html 声明为 HTML5 文档</li>\n<li>html 元素是 HTML 页面的根元素</li>\n<li>head元素包含了文档的元（meta）数据，如 meta charset=”utf-8”定义网页编码格式为 <strong>utf-8</strong>。</li>\n</ul>\n<p>只有 body区域 (白色部分) 才会在浏览器中显示。</p>\n<h1 id=\"HTML-基础\"><a href=\"#HTML-基础\" class=\"headerlink\" title=\"HTML 基础\"></a>HTML 基础</h1><p>HTML 标题（Heading）是通过h1-h6标签来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    标题一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>HTML 段落是通过标签 p 来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    段落一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>HTML 链接是通过标签 a来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://&quot;</span>&gt;</span></span><br><span class=\"line\">   链接一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>HTML 图像是通过标签 img 来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">loading</span>=<span class=\"string\">&quot;porrige&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;/images/logo.jpg&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;258&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"HTML元素\"><a href=\"#HTML元素\" class=\"headerlink\" title=\"HTML元素\"></a>HTML元素</h1><p>如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 br标签：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"HTML属性\"><a href=\"#HTML属性\" class=\"headerlink\" title=\"HTML属性\"></a>HTML属性</h1><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>class</td>\n<td>为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td>\n</tr>\n<tr>\n<td>id</td>\n<td>定义元素的唯一id</td>\n</tr>\n<tr>\n<td>style</td>\n<td>规定元素的行内样式（inline style）</td>\n</tr>\n<tr>\n<td>title</td>\n<td>描述了元素的额外信息 (作为工具条使用)</td>\n</tr>\n</tbody></table>\n<h1 id=\"HTML标题\"><a href=\"#HTML标题\" class=\"headerlink\" title=\"HTML标题\"></a>HTML标题</h1><p>标题（Heading）是通过 h1-h6标签进行定义的。</p>\n<p>h1定义最大的标题（主要）。 h6定义最小的标题（次要）。</p>\n<h2 id=\"HTML水平线\"><a href=\"#HTML水平线\" class=\"headerlink\" title=\"HTML水平线\"></a>HTML水平线</h2><p>hr标签在 HTML 页面中创建水平线。</p>\n<p>hr 元素可用于分隔内容。</p>\n<h2 id=\"HTML-注释\"><a href=\"#HTML-注释\" class=\"headerlink\" title=\"HTML 注释\"></a>HTML 注释</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure>","categories":["HTML"]},{"title":"网络编程","url":"/2021/03/18/network-coding/","content":"<h1 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h1><p>ip地址：InetAddress</p>\n<ul>\n<li><p>127.0.0.1 ：本机localhost</p>\n</li>\n<li><p>ip地址的分类</p>\n</li>\n<li><ul>\n<li>ipv4/ipv6</li>\n<li><ul>\n<li>IPV4 4个字节组成</li>\n<li>IPV6 128位，8个无符号整数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>java.net的包就是用于Internet用的</p>\n<h1 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h1><ul>\n<li><p>不同的进程拥有不同的端口号，用来区分软件。</p>\n</li>\n<li><p>被规定0~65535</p>\n</li>\n<li><p>端口分类</p>\n</li>\n<li><ul>\n<li>公有端口</li>\n<li><ul>\n<li>HTTP：80</li>\n<li>HTTPS：443</li>\n<li>FTP：21</li>\n<li>Telent：23</li>\n</ul>\n</li>\n<li>程序注册端口</li>\n<li><ul>\n<li>Tomcat：8080</li>\n<li>MySQL：3306</li>\n<li>Oracle：1521</li>\n</ul>\n</li>\n<li>动态、私有：49152~65535</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -ano <span class=\"comment\">#查看所有的端口</span></span><br><span class=\"line\">netstat -ano |findstr <span class=\"string\">&quot;5900&quot;</span></span><br><span class=\"line\">tasklist | finder <span class=\"string\">&quot;8696&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"try to upload","url":"/2021/03/17/try-to-upload/","content":"<p><img src=\"/images/pasted-210317pjl.jpg\" alt=\"pjl\"><br><img src=\"/images/pasted-210317whz.jpg\" alt=\"pjl\"></p>\n"},{"title":"数据库面试知识点记录","url":"/2021/03/24/210324Database/","content":"<h1 id=\"1-数据库范式\"><a href=\"#1-数据库范式\" class=\"headerlink\" title=\"1.数据库范式\"></a>1.数据库范式</h1><ul>\n<li><p>第一范式：列不可分，eg:【联系人】（姓名，性别，电话），一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF；</p>\n</li>\n<li><p>第二范式：有主键，保证完全依赖。eg:订单明细表【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName），Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID，不符合2NF；</p>\n</li>\n<li><p>第三范式：无传递依赖(非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况)，eg:订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。</p>\n</li>\n</ul>\n<h1 id=\"2-数据库索引\"><a href=\"#2-数据库索引\" class=\"headerlink\" title=\"2.数据库索引\"></a>2.数据库索引</h1><p><strong>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。</strong>索引的实现通常使用B_TREE及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。</p>\n<h2 id=\"1-索引的底层实现原理和优化\"><a href=\"#1-索引的底层实现原理和优化\" class=\"headerlink\" title=\"1). 索引的底层实现原理和优化\"></a>1). 索引的底层实现原理和优化</h2><p>　　在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。<br>(1). B-Tree(平衡多路查找树)</p>\n<p>　　B_TREE是一种平衡多路查找树，是一种动态查找效率很高的树形结构。B_TREE中所有结点的孩子结点的最大值称为B_TREE的阶，B_TREE的阶通常用m表示，简称为m叉树。一般来说，应该是m&gt;=3。一颗m阶的B_TREE或是一颗空树，或者是满足下列条件的m叉树：</p>\n<p>树中每个结点最多有m个孩子结点；</p>\n<p>若根结点不是叶子节点，则根结点至少有2个孩子结点；</p>\n<p>除根结点外，其它结点至少有(m/2的上界)个孩子结点；</p>\n<p>结点的结构如下图所示，其中，n为结点中关键字个数，(m/2的上界)-1 &lt;= n &lt;= m-1；di(1&lt;=i&lt;=n)为该结点的n个关键字值的第i个，且di&lt; d(i+1)；ci(0&lt;=i&lt;=n)为该结点孩子结点的指针，且ci所指向的节点的关键字均大于或等于di且小于d(i+1)；</p>\n<p>　　　　　　　　　　<img src=\"http://static.zybuluo.com/Rico123/4clzcd69i34ihxiddnsorkza/B-Tree%E7%BB%93%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"B-Tree结点的结构.png-1.7kB\"></p>\n<p>所有的叶结点都在同一层上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）。</p>\n<p>　　下图是一棵4阶B_TREE，4叉树结点的孩子结点的个数范围[2,4]。其中，有2个结点有4个孩子结点，有1个结点有3个孩子结点，有5个结点有2个孩子结点。</p>\n<p>　　　<img src=\"http://static.zybuluo.com/Rico123/z66j4t1g8jknavzqweyikezd/4%E9%98%B6B_TREE.jpg\" alt=\"4阶B_TREE.jpg-24.1kB\">　　</p>\n<p>　　B_TREE的查找类似二叉排序树的查找，所不同的是B-树每个结点上是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，到按照对应的指针信息指向的子树中去查找，当到达叶子结点时，则说明树中没有对应的关键码。由于B_TREE的高检索效率，B-树主要应用在文件系统和数据库中，对于存储在硬盘上的大型数据库文件，可以极大程度减少访问硬盘次数，大幅度提高数据检索效率。</p>\n<p>(2). B+Tree ： <strong>InnoDB存储引擎的索引实现</strong></p>\n<p>　　B+Tree是应文件系统所需而产生的一种B_TREE树的变形树。一棵m阶的B+树和m阶的B_TREE的差异在于以下三点：</p>\n<ul>\n<li><p>n 棵子树的结点中含有n个关键码；</p>\n</li>\n<li><p>所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；</p>\n</li>\n<li><p>非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码。</p>\n</li>\n</ul>\n<p>　　下图为一棵3阶的B+树。通常在B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。因此可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。<br>在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。只是在查找时，若非终端结点上的关键码等于给定值，并不终止，而是继续向下直到叶子结点。因此，对于B+树，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。</p>\n<p>　　　　　　　　　　<img src=\"http://static.zybuluo.com/Rico123/ynugdx0avoy5blfq6gkb0tv2/3%E9%98%B6B+%E6%A0%91.jpg\" alt=\"一棵3阶的B+树.jpg-29.9kB\"></p>\n<p>(3). 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？</p>\n<ul>\n<li><p>B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；</p>\n</li>\n<li><p>B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p>\n</li>\n<li><p>数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。</p>\n</li>\n</ul>\n<p>(4). 文件索引和数据库索引为什么使用B+树?</p>\n<p>　　文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。</p>\n<h2 id=\"2-索引的优点\"><a href=\"#2-索引的优点\" class=\"headerlink\" title=\"2). 索引的优点\"></a>2). 索引的优点</h2><p>大大加快数据的检索速度，这也是创建索引的最主要的原因；</p>\n<p>加速表和表之间的连接；</p>\n<p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</p>\n<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</p>\n<h2 id=\"3-什么情况下设置了索引但无法使用？\"><a href=\"#3-什么情况下设置了索引但无法使用？\" class=\"headerlink\" title=\"3). 什么情况下设置了索引但无法使用？\"></a>3). 什么情况下设置了索引但无法使用？</h2><p>以“%(表示任意0个或多个字符)”开头的LIKE语句，模糊匹配；</p>\n<p>OR语句前后没有同时使用索引；</p>\n<p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</p>\n<p>对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。</p>\n<h2 id=\"4-什么样的字段适合创建索引？\"><a href=\"#4-什么样的字段适合创建索引？\" class=\"headerlink\" title=\"4). 什么样的字段适合创建索引？\"></a>4). 什么样的字段适合创建索引？</h2><p>经常作查询选择的字段</p>\n<p>经常作表连接的字段</p>\n<p>经常出现在order by, group by, distinct 后面的字段</p>\n<h2 id=\"5-创建索引时需要注意什么？\"><a href=\"#5-创建索引时需要注意什么？\" class=\"headerlink\" title=\"5). 创建索引时需要注意什么？\"></a>5). 创建索引时需要注意什么？</h2><p>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>\n<p>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p>\n<p>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p>\n<h2 id=\"6-索引的缺点\"><a href=\"#6-索引的缺点\" class=\"headerlink\" title=\"6). 索引的缺点\"></a>6). 索引的缺点</h2><p>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</p>\n<p>空间方面：索引需要占物理空间。</p>\n<h2 id=\"7-索引的分类\"><a href=\"#7-索引的分类\" class=\"headerlink\" title=\"7). 索引的分类\"></a>7). 索引的分类</h2><p>普通索引和唯一性索引：索引列的值的唯一性</p>\n<p>单个索引和复合索引：索引列所包含的列数</p>\n<p>聚簇索引与非聚簇索引：聚簇索引按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚簇索引必须是唯一的。聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了；而非聚集索引是把一个很大的范围，转换成一个小的地图，然后你需要在这个小地图中找你要寻找的信息的位置，最后通过这个位置，再去找你所需要的记录。</p>\n<h2 id=\"8-主键、自增主键、主键索引与唯一索引概念区别\"><a href=\"#8-主键、自增主键、主键索引与唯一索引概念区别\" class=\"headerlink\" title=\"8). 主键、自增主键、主键索引与唯一索引概念区别\"></a>8). 主键、自增主键、主键索引与唯一索引概念区别</h2><p>主键：指字段 唯一、不为空值 的列；</p>\n<p>主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；</p>\n<p>自增主键：字段类型为数字、自增、并且是主键；</p>\n<p>唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。</p>\n<h2 id=\"9-主键就是聚集索引吗？主键和索引有什么区别？\"><a href=\"#9-主键就是聚集索引吗？主键和索引有什么区别？\" class=\"headerlink\" title=\"9). 主键就是聚集索引吗？主键和索引有什么区别？\"></a>9). 主键就是聚集索引吗？主键和索引有什么区别？</h2><p>　　主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。</p>\n<h1 id=\"3-数据库事务\"><a href=\"#3-数据库事务\" class=\"headerlink\" title=\"3.数据库事务\"></a>3.数据库事务</h1><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p>\n<h2 id=\"事务的特征\"><a href=\"#事务的特征\" class=\"headerlink\" title=\"事务的特征\"></a>事务的特征</h2><ul>\n<li><p>原子性(Atomicity)：事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚；</p>\n</li>\n<li><p>一致性(Consistency)：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态；</p>\n</li>\n<li><p>隔离性(Isolation)：并发执行的事务之间不能相互影响；</p>\n</li>\n<li><p>持久性(Durability)：事务一旦提交，对数据库中数据的改变是永久性的。</p>\n</li>\n</ul>\n<h2 id=\"事务并发带来的问题\"><a href=\"#事务并发带来的问题\" class=\"headerlink\" title=\"事务并发带来的问题\"></a>事务并发带来的问题</h2><ul>\n<li>丢失修改：丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png\" alt=\"img\"></p>\n<ul>\n<li>脏读：一个事务读取了另一个事务未提交的数据；</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png\" alt=\"img\"></p>\n<ul>\n<li>不可重复读：不可重复读的重点是<strong>修改</strong>，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png\" alt=\"img\"></p>\n<ul>\n<li>幻读：幻读的重点在于<strong>新增或者删除</strong>，同样条件下两次读出来的记录数不一样。</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png\" alt=\"img\"></p>\n<h2 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h2><h3 id=\"未提交读（READ-UNCOMMITTED）\"><a href=\"#未提交读（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"未提交读（READ UNCOMMITTED）\"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>\n<h3 id=\"提交读（READ-COMMITTED）\"><a href=\"#提交读（READ-COMMITTED）\" class=\"headerlink\" title=\"提交读（READ COMMITTED）\"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>\n<h3 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。（在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务commit或rollback。但是，其他事务的insert/delete操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复select的结果一样，除非本事务中update数据库。）</p>\n<h3 id=\"可串行化-serializable-可串行化（SERIALIZABLE）\"><a href=\"#可串行化-serializable-可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化-serializable)可串行化（SERIALIZABLE）\"></a>可串行化-serializable)可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>\n<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>\n<hr>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png\" alt=\"img\"></p>\n<p>ps：MySQL默认的隔离级别是可重复读REPEATABLE READ。</p>\n<h2 id=\"4-MySQL的事务支持\"><a href=\"#4-MySQL的事务支持\" class=\"headerlink\" title=\"4.MySQL的事务支持\"></a>4.MySQL的事务支持</h2><p>MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关：</p>\n<ul>\n<li>MyISAM：不支持事务，用于只读程序提高性能；</li>\n<li>InnoDB：支持ACID事务、行级锁、并发；</li>\n<li>Berkeley DB：支持事务。</li>\n</ul>\n<h1 id=\"5-MySQL中的悲观锁与乐观锁的实现\"><a href=\"#5-MySQL中的悲观锁与乐观锁的实现\" class=\"headerlink\" title=\"5.MySQL中的悲观锁与乐观锁的实现\"></a>5.MySQL中的悲观锁与乐观锁的实现</h1><ol>\n<li>悲观锁</li>\n</ol>\n<p>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。   </p>\n<ol start=\"2\">\n<li>乐观锁</li>\n</ol>\n<p>乐观锁的特点先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号或者时间戳，然后按照如下方式实现：</p>\n<ol start=\"3\">\n<li>悲观锁与乐观锁的应用场景</li>\n</ol>\n<p>一般情况下，<strong>读多写少更适合用乐观锁，读少写多更适合用悲观锁</strong>。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。</p>\n<h1 id=\"6-JDBC-对事务的支持\"><a href=\"#6-JDBC-对事务的支持\" class=\"headerlink\" title=\"6.JDBC 对事务的支持\"></a>6.JDBC 对事务的支持</h1><p>对于JDBC而言，每条单独的语句都是一个事务，即每个语句后都隐含一个commit。实际上，Connection 提供了一个auto-commit的属性来指定事务何时结束。当auto-commit为true时，当每个独立SQL操作的执行完毕，事务立即自动提交，也就是说，每个SQL操作都是一个事务；当auto-commit为false时，每个事务都必须显式调用commit方法进行提交，或者显式调用rollback方法进行回滚。auto-commit默认为true。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">    conn.setAutoCommit(<span class=\"keyword\">false</span>);  <span class=\"comment\">//将自动提交设置为false        </span></span><br><span class=\"line\">    ps.executeUpdate(<span class=\"string\">&quot;修改SQL&quot;</span>); <span class=\"comment\">//执行修改操作  </span></span><br><span class=\"line\">    ps.executeQuery(<span class=\"string\">&quot;查询SQL&quot;</span>);  <span class=\"comment\">//执行查询操作                 </span></span><br><span class=\"line\">    conn.commit();      <span class=\"comment\">//当两个操作成功后手动提交     </span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">    conn.rollback();    <span class=\"comment\">//一旦其中一个操作出错都将回滚，使两个操作都不成功  </span></span><br><span class=\"line\">    e.printStackTrace();  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>　　为了能够将多条SQL当成一个事务执行，必须首先通过</p>\n<p>​          </p>\n","categories":["数据库"]},{"title":"Java基础","url":"/2021/03/24/210324Javabase/","content":"<h1 id=\"StringBuilder-和-StringBuffer\"><a href=\"#StringBuilder-和-StringBuffer\" class=\"headerlink\" title=\"StringBuilder 和 StringBuffer\"></a><strong>StringBuilder</strong> <strong>和</strong> <strong>StringBuffer</strong></h1><p><strong>StringBuffer</strong> 是线程安全的 <strong>StringBuilder</strong> 是不安全的</p>\n<h1 id=\"Java实现连续空间的内存分配\"><a href=\"#Java实现连续空间的内存分配\" class=\"headerlink\" title=\"Java实现连续空间的内存分配?\"></a>Java实现连续空间的内存分配?</h1><p>基本数据类型的数组，存放在栈内存里，连续分配对象数组,在栈内存里的引用是连续分配的，实际数据分配在堆内存，不是连续分配的。</p>\n<h1 id=\"创建对象的方式有哪几种？\"><a href=\"#创建对象的方式有哪几种？\" class=\"headerlink\" title=\"创建对象的方式有哪几种？\"></a>创建对象的方式有哪几种？</h1><h1 id=\"接口和抽象类有什么区别\"><a href=\"#接口和抽象类有什么区别\" class=\"headerlink\" title=\"接口和抽象类有什么区别\"></a>接口和抽象类有什么区别</h1><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。</p>\n<p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。</p>\n<p>人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.</p>\n<p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p>\n<p>第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。<br>第二点． 接口可以多继承，抽象类不行<br>第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。<br>第四点． 接口中基本数据类型为static 而抽类象不是的。</p>\n<p>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>\n<h1 id=\"浅拷贝与深拷贝的区别\"><a href=\"#浅拷贝与深拷贝的区别\" class=\"headerlink\" title=\"浅拷贝与深拷贝的区别\"></a>浅拷贝与深拷贝的区别</h1><p><strong>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</strong></p>\n<p><strong>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</strong></p>\n<p>ps:Java中的拷贝需要实现java.lang.Cloneable接口，然后重写clone()方法，这个无论深、浅拷贝都需要这样做</p>\n<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p><strong>编译时多态</strong><br>方法重载 都是编译时多态。根据实际参数的数据类型、个数和次序，Java 在编译时能够确定执行重载方法中的哪一个。</p>\n<p>方法覆盖 表现出两种多态性，当对象引用本类实例时，为编译时多态，否则为运行时多态。</p>\n<p><strong>运行时多态</strong><br>通过父类对象引用变量引用子类对象来实现。当父类对象引用子类实例时。通过接口类型变量引用实现接口的类的对象来实现 。运行时多态主要是通过继承和接口实现的。</p>\n<h1 id=\"Java注解的理解\"><a href=\"#Java注解的理解\" class=\"headerlink\" title=\"Java注解的理解\"></a>Java注解的理解</h1><p>Java 语言中的类、方法、变量、参数和包等都可以注解标记，程序运行期间我们可以获取到相应的注解以及注解中定义的内容，这样可以帮助我们做一些事情。</p>\n<h1 id=\"Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？\"><a href=\"#Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？\" class=\"headerlink\" title=\"Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？\"></a>Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</h1><p>反射介绍：</p>\n<p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及 动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n<p>反射的优缺点如下：</p>\n<ul>\n<li><p>优点：运行期类型的判断，动态加载类，提高代码灵活度。</p>\n</li>\n<li><p>缺点：</p>\n</li>\n</ul>\n<ol>\n<li><p>性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。</p>\n</li>\n<li><p>安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</p>\n</li>\n</ol>\n<h1 id=\"为什么框架需要反射技术\"><a href=\"#为什么框架需要反射技术\" class=\"headerlink\" title=\"为什么框架需要反射技术\"></a>为什么框架需要反射技术</h1><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机 制没有用，实际上有很多设计、开发都与反射机制有关。动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>\n<p>我们在使用 JDBC 连接数据库时使用 Class.forName() 通过反射加载数据库的驱动程序；<br>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；<br>动态配置实例的属性；</p>\n<h1 id=\"获取Class对象的两种方式\"><a href=\"#获取Class对象的两种方式\" class=\"headerlink\" title=\"获取Class对象的两种方式\"></a>获取Class对象的两种方式</h1><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了两种方式获取 Class 对象:</p>\n<p>知道具体类的情况下可以使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class alunbarClass = TargetObject.class;      </span><br></pre></td></tr></table></figure>\n\n\n<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象</p>\n<p>通过 Class.forName() 传入类的路径获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class alunbarClass1 = Class.forName(<span class=\"string\">&quot;cn.javaguide.TargetObject&quot;</span>); </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"内存泄露和内存溢出的场景\"><a href=\"#内存泄露和内存溢出的场景\" class=\"headerlink\" title=\"内存泄露和内存溢出的场景\"></a>内存泄露和内存溢出的场景</h1><p>内存泄漏：内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不 到及时释放，从而造成内存空间的浪费称为内存泄漏。</p>\n<p>Java 内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。</p>\n<p>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生 于 OLD 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况。</p>\n<p>内存溢出场景：</p>\n<ul>\n<li>JVM Heap（堆）溢出：OutOfMemoryError: Java heap space： 发生这种问题的原因是 java 虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已 经用满了。JVM 在启动的时候会自动设置 JVM Heap 的值， 可以利用 JVM 提供的-Xmn -Xms -Xmx 等选项可进行设置。Heap的大小是新生代和老年代之和。</li>\n</ul>\n<p>解决方法：</p>\n<ol>\n<li><p>手动设置 JVM Heap（堆）的大小。</p>\n</li>\n<li><p>检查程序，看是否有死循环或不必要地重复创建大量对象。</p>\n</li>\n</ol>\n<ul>\n<li>Metaspace溢出：java.lang.OutOfMemoryError: Metaspace 程序中使用了大量的 jar 或 class，使 java 虚拟机装载类的空间不够，与 metaspace 大小有关。方法区用于存放 Java 类型的相关信息。在类装载器加载 class 文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的 内存占用又已经达到 -XX:MaxMetaspaceSize 设置的最大值，将会抛出 OutOfMemoryError 异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</li>\n</ul>\n<p>解决方法:</p>\n<ol>\n<li>通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。</li>\n</ol>\n<ul>\n<li>栈溢出： java.lang.StackOverflowError : Thread Stack space：线程的方法嵌套调用层次太多(如递归调用)，以致于把栈区溢出了。</li>\n</ul>\n<p>解决方法：</p>\n<ol>\n<li>修改程序。</li>\n<li>通过 -Xss: 来设置每个线程的 Stack 大小即可。</li>\n</ol>\n<h1 id=\"强引用，弱引用，软引用，虚引用\"><a href=\"#强引用，弱引用，软引用，虚引用\" class=\"headerlink\" title=\"强引用，弱引用，软引用，虚引用\"></a>强引用，弱引用，软引用，虚引用</h1><h2 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h2><p>大部分引用实际上都是，最普遍。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object object = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">String str = <span class=\"string\">&quot;StrongReference&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个对象具有强引用，那就类似于<strong>必不可少的</strong>物品，不会被垃圾回收器回收。<strong>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</strong></p>\n<h2 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h2><p>软引用是用来描述一些<strong>有用但并不是必需</strong>的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。<br>软引用在实际中有重要的应用，例如浏览器的后退按钮，这个后退时显示的网页内容可以重新进行请求或者从缓存中取出：</p>\n<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p>\n<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出这时候就可以使用软引用</p>\n<h2 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h2><p>弱引用也是用来描述<strong>非必需对象</strong>的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p>\n<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<u>所以被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</u></p>\n<h2 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h2><p>虚引用和前面的软引用、弱引用不同，它并<strong>不影响对象的生命周期</strong>。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，<strong>在任何时候都可能被垃圾回收器回收</strong>。虚引用主要用来跟踪对象被垃圾回收的活动。</p>\n<p><strong>虚引用必须和引用队列关联使用</strong>，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>被回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>强引用</td>\n<td>从来不会</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>jvm垃圾回收时</td>\n<td>对象缓存</td>\n<td>gc运行后</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>未知</td>\n<td>未知</td>\n<td>未知</td>\n</tr>\n</tbody></table>\n<h1 id=\"讲一下-Java-的-BIO-NIO-AIO\"><a href=\"#讲一下-Java-的-BIO-NIO-AIO\" class=\"headerlink\" title=\"讲一下 Java 的 BIO,NIO,AIO?\"></a>讲一下 Java 的 BIO,NIO,AIO?</h1><h2 id=\"BIO-Blocking-I-O-：\"><a href=\"#BIO-Blocking-I-O-：\" class=\"headerlink\" title=\"BIO (Blocking I/O)：\"></a>BIO (Blocking I/O)：</h2><p>同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>\n<h2 id=\"NIO-Non-blocking-New-I-O\"><a href=\"#NIO-Non-blocking-New-I-O\" class=\"headerlink\" title=\"NIO (Non-blocking/New I/O):\"></a>NIO (Non-blocking/New I/O):</h2><p>NIO 是一种同步非阻塞的 I/O 模型，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。Java NIO使我们可以进行非阻塞IO操作。比如说， 单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后， 线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一 些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。JDK 的 NIO 底层由 epoll 实现。</p>\n<p>通常来说 NIO 中的所有 IO 都是从 Channel（通道） 开始的。</p>\n<p>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</p>\n<p>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</p>\n<h2 id=\"AIO-Asynchronous-I-O-：\"><a href=\"#AIO-Asynchronous-I-O-：\" class=\"headerlink\" title=\"AIO (Asynchronous I/O)：\"></a>AIO (Asynchronous I/O)：</h2><p>异步非阻塞IO模型，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的 线程进行后续的操作。AIO 的应用还不是很广泛。</p>\n<h1 id=\"Java中finalize-方法的使用\"><a href=\"#Java中finalize-方法的使用\" class=\"headerlink\" title=\"Java中finalize()方法的使用\"></a>Java中finalize()方法的使用</h1><p>finalize()是 Object的protected 方法，子类可以覆盖该方法以实现资源清理工作，GC 在回收对象之前调用该方法。</p>\n<p><strong>finalize()方法中一般用于释放非 Java 资源（如打开的文件资源、数据库连接等），或是调用非Java方法（native方法）时分配的内存（比如 C 语言的 malloc()系列函数）。</strong></p>\n<p>避免使用的原因：</p>\n<p>首先，由于 finalize()方法的调用时机具有不确定性，从一个对象变得不可到达开始，到 finalize()方法被执行，所花费的时间这段时间是任意长的。我们并不能依赖 finalize()方法能 及时的回收占用的资源，可能出现的情况是在我们耗尽资源之前，gc 却仍未触发，因而通常的做法是提供显示的 close()方法供客户端手动调用。另外，重写 finalize()方法意味着延长了回收对象时需要进行更多的操作，从而延长了对象回收的时间。</p>\n<h1 id=\"什么是GC-Root\"><a href=\"#什么是GC-Root\" class=\"headerlink\" title=\"什么是GC Root\"></a>什么是GC Root</h1><p>首先我们知道标记算法，JVM的标记算法我们可以了解为一个可达性算法，所以所有的可达性算法都会有起点，那么这个起点就是GC Root。也就是需要通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。</p>\n<h2 id=\"GC-Root的对象\"><a href=\"#GC-Root的对象\" class=\"headerlink\" title=\"GC Root的对象\"></a>GC Root的对象</h2><ul>\n<li>方法区中的静态变量和常量引用的对象</li>\n<li>虚拟机栈中引用对象</li>\n<li>本地方法栈中引用对象</li>\n</ul>\n<h1 id=\"单例模型\"><a href=\"#单例模型\" class=\"headerlink\" title=\"单例模型\"></a>单例模型</h1><p>下述内容来源于<a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\">菜鸟教程</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">1、懒汉式，线程不安全</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：是</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：否</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：易</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span></span><br><span class=\"line\"><span class=\"comment\">这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2、懒汉式，线程安全</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：是</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：易</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</span></span><br><span class=\"line\"><span class=\"comment\">优点：第一次调用才初始化，避免内存浪费。</span></span><br><span class=\"line\"><span class=\"comment\">缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</span></span><br><span class=\"line\"><span class=\"comment\">getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">3、饿汉式</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：否</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：易</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式比较常用，但容易产生垃圾对象。</span></span><br><span class=\"line\"><span class=\"comment\">优点：没有加锁，执行效率会提高。</span></span><br><span class=\"line\"><span class=\"comment\">缺点：类加载时就初始化，浪费内存。</span></span><br><span class=\"line\"><span class=\"comment\">它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">4、双检锁/双重校验锁（DCL，即 double-checked locking）</span></span><br><span class=\"line\"><span class=\"comment\">JDK 版本：JDK1.5 起</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：是</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：较复杂</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</span></span><br><span class=\"line\"><span class=\"comment\">getInstance() 的性能对应用程序很关键。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">5、登记式/静态内部类</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：是</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：一般</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</span></span><br><span class=\"line\"><span class=\"comment\">这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">6、枚举</span></span><br><span class=\"line\"><span class=\"comment\">JDK 版本：JDK1.5 起</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：否</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：易</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</span></span><br><span class=\"line\"><span class=\"comment\">这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</span></span><br><span class=\"line\"><span class=\"comment\">不能通过 reflection attack 来调用私有构造方法。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;       </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java中-gt-gt-和-gt-gt-gt-的区别\"><a href=\"#Java中-gt-gt-和-gt-gt-gt-的区别\" class=\"headerlink\" title=\"Java中&gt;&gt;和&gt;&gt;&gt;的区别\"></a>Java中&gt;&gt;和&gt;&gt;&gt;的区别</h1><p>Java 中的位运算符：</p>\n<p>‘&gt;&gt;’表示带符号右移，如：int i=15; i&gt;&gt;2 的结果是 3，移出的部分将被抛弃。<br>转为二进制的形式可能更好理解，0000 1111(15)右移 2 位的结果是 0000 0011(3)，0001 1010(18)右移 3 位的结果是 0000 0011(3)。</p>\n<p>‘&gt;&gt;&gt;’无符号右移：<br>按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补零。对于正数来说和带符号右移相同，对于负数来说不同。<br>其他结构和&gt;&gt;相似。</p>\n<h1 id=\"讲一下volatile关键字的作用\"><a href=\"#讲一下volatile关键字的作用\" class=\"headerlink\" title=\"讲一下volatile关键字的作用\"></a>讲一下volatile关键字的作用</h1><p>volatile可以保证可见性，有序性，但不能保证原子性.</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a><strong>可见性</strong></h2><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong></p>\n<h2 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a><strong>有序性</strong></h2><p>有序性即程序执行的顺序按照代码的先后顺序执行</p>\n<h1 id=\"synchronized-作用，讲一讲底层实现\"><a href=\"#synchronized-作用，讲一讲底层实现\" class=\"headerlink\" title=\"synchronized 作用，讲一讲底层实现\"></a>synchronized 作用，讲一讲底层实现</h1><h2 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a><strong>原子性</strong></h2><p><strong>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong></p>\n<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。但是像i++、i+=1等操作字符就不是原子性的，它们是分成<strong>读取、计算、赋值</strong>几步操作，原值在这些步骤还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。</p>\n<p>被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。</p>\n<p><strong>注意！面试时经常会问比较synchronized和volatile，它们俩特性上最大的区别就在于原子性，volatile不具备原子性。</strong></p>\n<h2 id=\"可见性-1\"><a href=\"#可见性-1\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p><strong>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</strong></p>\n<p>synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</p>\n<p>而volatile的实现类似，被volatile修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性。</p>\n<h2 id=\"有序性-1\"><a href=\"#有序性-1\" class=\"headerlink\" title=\"有序性\"></a>有序性</h2><p><strong>有序性值程序执行的顺序按照代码先后执行。</strong></p>\n<p>synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</p>\n<h2 id=\"可重入性\"><a href=\"#可重入性\" class=\"headerlink\" title=\"可重入性\"></a>可重入性</h2><p>synchronized和ReentrantLock都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</p>\n<h1 id=\"说说-synchronized关键字和-volatile关键字的区别\"><a href=\"#说说-synchronized关键字和-volatile关键字的区别\" class=\"headerlink\" title=\"说说 synchronized关键字和 volatile关键字的区别\"></a>说说 synchronized关键字和 volatile关键字的区别</h1><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键 字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代 码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁 带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提 升，实际开发中使用 synchronized 关键字的场景还是更多一些。</p>\n<p>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字 两者都能保证。</p>\n<p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://blog.csdn.net/qq_39192827/article/details/85611873\">https://blog.csdn.net/qq_39192827/article/details/85611873</a></p>\n<p>[2] <a href=\"https://www.jianshu.com/p/9d573539022c\">深入理解synchronized底层原理，一篇文章就够了！</a></p>\n","categories":["Java"],"tags":["面试"]},{"title":"Git","url":"/2021/03/28/Git/","content":"<h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><p>学习git之前，我们需要先明白一个概念</p>\n<p><strong>版本控制！</strong></p>\n<h2 id=\"什么是版本控制\"><a href=\"#什么是版本控制\" class=\"headerlink\" title=\"什么是版本控制\"></a>什么是版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>\n<ul>\n<li>实现跨区域多人协同开发</li>\n<li>追踪和记载一个或者多个文件的历史记录</li>\n<li>组织和保护你的源代码和文档</li>\n<li>统计工作量</li>\n<li>并行开发、提高开发效率</li>\n<li>跟踪记录整个软件的开发过程</li>\n<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>\n</ul>\n<p>简单说就是用于管理多人协同开发项目的技术。</p>\n<p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p>\n<p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0C4qeLxMgoTg9B154ibahsUaibiaV7DgH9GTFQZj3Kyhf5fxrj6G2U5HFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>多人开发就必须要使用版本控制！</p>\n<h2 id=\"常见的版本控制工具\"><a href=\"#常见的版本控制工具\" class=\"headerlink\" title=\"常见的版本控制工具\"></a>常见的版本控制工具</h2><p>我们学习的东西，一定是当下最流行的！</p>\n<p>主流的版本控制器有如下这些：</p>\n<ul>\n<li><strong>Git</strong></li>\n<li><strong>SVN</strong>（Subversion）</li>\n<li><strong>CVS</strong>（Concurrent Versions System）</li>\n<li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li>\n<li><strong>TFS</strong>（Team Foundation Server）</li>\n<li>Visual Studio Online</li>\n</ul>\n<p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p>\n<h2 id=\"版本控制分类\"><a href=\"#版本控制分类\" class=\"headerlink\" title=\"版本控制分类\"></a>版本控制分类</h2><h3 id=\"1、本地版本控制\"><a href=\"#1、本地版本控制\" class=\"headerlink\" title=\"1、本地版本控制\"></a><strong>1、本地版本控制</strong></h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Dg3fHrbPqbNEOMO9GTjFhVaukMZWx54icS7eS2x8A7BEu0VB9ibwEhzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h3 id=\"2、集中版本控制-SVN\"><a href=\"#2、集中版本控制-SVN\" class=\"headerlink\" title=\"2、集中版本控制  SVN\"></a><strong>2、集中版本控制  SVN</strong></h3><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p>\n<h3 id=\"3、分布式版本控制-Git\"><a href=\"#3、分布式版本控制-Git\" class=\"headerlink\" title=\"3、分布式版本控制     Git\"></a><strong>3、分布式版本控制     Git</strong></h3><p>每个人都拥有全部的代码！安全隐患！</p>\n<p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>\n<p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h2 id=\"Git与SVN的主要区别\"><a href=\"#Git与SVN的主要区别\" class=\"headerlink\" title=\"Git与SVN的主要区别\"></a>Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p>\n<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>\n<h1 id=\"聊一聊Git的历史\"><a href=\"#聊一聊Git的历史\" class=\"headerlink\" title=\"聊一聊Git的历史\"></a>聊一聊Git的历史</h1><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>\n<p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>\n<p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p>\n<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p>\n<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>\n<p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p>\n<h1 id=\"Git环境配置\"><a href=\"#Git环境配置\" class=\"headerlink\" title=\"Git环境配置\"></a>Git环境配置</h1><h2 id=\"软件下载\"><a href=\"#软件下载\" class=\"headerlink\" title=\"软件下载\"></a>软件下载</h2><p>打开 [git官网] <a href=\"https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82\">https://git-scm.com/，下载git对应操作系统的版本。</a></p>\n<p>所有东西下载慢的话就可以去找镜像！</p>\n<p>官网下载太慢，我们可以使用淘宝镜像下载：<a href=\"http://npm.taobao.org/mirrors/git-for-windows/\">http://npm.taobao.org/mirrors/git-for-windows/</a></p>\n<p><img src=\"C:\\Users\\dell\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210328143055320.png\" alt=\"image-20210328143055320\"></p>\n<p>下载对应的版本即可安装！</p>\n<p>安装：无脑下一步即可！安装完毕就可以使用了！</p>\n<h2 id=\"启动Git\"><a href=\"#启动Git\" class=\"headerlink\" title=\"启动Git\"></a>启动Git</h2><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p>\n<p><strong>Git CMD：</strong>Windows风格的命令行</p>\n<p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p>\n<h2 id=\"常用的Linux命令\"><a href=\"#常用的Linux命令\" class=\"headerlink\" title=\"常用的Linux命令\"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p>\n<p>1）、cd : (Change Directory)改变目录。</p>\n<p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p>\n<p>3）、pwd : (print work directory)显示当前所在的目录路径。</p>\n<p>4）、ls(ll):  (list)都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p>\n<p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p>\n<p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p>\n<p>7）、mkdir: (Make Directory) 新建一个目录,就是新建一个文件夹。</p>\n<p>8）、rm -r : (Remove Directory) 删除一个文件夹, rm -r src 删除src目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！</span><br></pre></td></tr></table></figure>\n\n<p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p>\n<p>10）、reset 重新初始化终端/清屏。</p>\n<p>11）、clear 清屏。</p>\n<p>12）、history 查看命令历史。</p>\n<p>13）、help 帮助。</p>\n<p>14）、exit 退出。</p>\n<p>15）、#表示注释</p>\n<h2 id=\"Git-配置\"><a href=\"#Git-配置\" class=\"headerlink\" title=\"Git 配置\"></a>Git 配置</h2><p>所有的配置文件，其实都保存在本地！</p>\n<p>查看配置 git config -l</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>查看不同级别的配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#查看系统config</span><br><span class=\"line\">git config --system --list　　</span><br><span class=\"line\">#查看当前用户（global）配置</span><br><span class=\"line\">git config --global  --list</span><br></pre></td></tr></table></figure>\n\n<p><strong>Git相关的配置文件：</strong></p>\n<p>1）、Git\\etc\\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p>\n<p>2）、C:\\Users\\Administrator\\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p>\n<h2 id=\"设置用户名与邮箱（用户标识，必要）\"><a href=\"#设置用户名与邮箱（用户标识，必要）\" class=\"headerlink\" title=\"设置用户名与邮箱（用户标识，必要）\"></a>设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;名称&quot;  #名称</span><br><span class=\"line\">git config --global user.email 邮箱   #邮箱</span><br></pre></td></tr></table></figure>\n\n<p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p>\n<p>可以查看当前用户（global）配置<br>git config –global  –list</p>\n<h1 id=\"Git基本原理\"><a href=\"#Git基本原理\" class=\"headerlink\" title=\"Git基本原理\"></a>Git基本原理</h1><h2 id=\"三个区域\"><a href=\"#三个区域\" class=\"headerlink\" title=\"三个区域\"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<ul>\n<li>Workspace：工作区，就是你平时存放项目代码的地方</li>\n<li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>\n<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>\n<li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>\n</ul>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p>git的工作流程一般是这样的：</p>\n<p>１、在工作目录中添加、修改文件；</p>\n<p>２、将需要进行版本管理的文件放入暂存区域；</p>\n<p>３、将暂存区域的文件提交到git仓库。</p>\n<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h1 id=\"Git项目搭建\"><a href=\"#Git项目搭建\" class=\"headerlink\" title=\"Git项目搭建\"></a>Git项目搭建</h1><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>\n<p>日常使用只要记住下图6个命令：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h2 id=\"本地仓库搭建\"><a href=\"#本地仓库搭建\" class=\"headerlink\" title=\"本地仓库搭建\"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>\n<p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 在当前目录新建一个Git代码库</span><br><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n\n<p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p>\n<h2 id=\"克隆远程仓库\"><a href=\"#克隆远程仓库\" class=\"headerlink\" title=\"克隆远程仓库\"></a>克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class=\"line\">$ git clone [url]  </span><br></pre></td></tr></table></figure>\n\n<p>2、去 gitee 或者 github 上克隆一个测试！</p>\n<h1 id=\"Git文件操作\"><a href=\"#Git文件操作\" class=\"headerlink\" title=\"Git文件操作\"></a>Git文件操作</h1><h2 id=\"文件的四种状态\"><a href=\"#文件的四种状态\" class=\"headerlink\" title=\"文件的四种状态\"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>\n<ul>\n<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li>\n<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li>\n<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li>\n<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>\n</ul>\n<h2 id=\"查看文件状态\"><a href=\"#查看文件状态\" class=\"headerlink\" title=\"查看文件状态\"></a>查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#查看指定文件状态</span><br><span class=\"line\">git status [filename]</span><br><span class=\"line\">#查看所有文件状态</span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"># git add .                  添加所有文件到暂存区# git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git commit -a</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"忽略文件\"><a href=\"#忽略文件\" class=\"headerlink\" title=\"忽略文件\"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>\n<p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p>\n<ol>\n<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>\n<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li>\n<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>\n<li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>\n<li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li>\n</ol>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#为注释</span><br><span class=\"line\">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class=\"line\">!lib.txt     #但lib.txt除外</span><br><span class=\"line\">&#x2F;temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class=\"line\">build&#x2F;       #忽略build&#x2F;目录下的所有文件</span><br><span class=\"line\">doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"码云的使用\"><a href=\"#码云的使用\" class=\"headerlink\" title=\"码云的使用\"></a>码云的使用</h2><p>这个其实可以作为大家未来找工作的一个重要信息！</p>\n<p>1、注册登录码云，完善个人信息</p>\n<p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 进入 C:\\Users\\Administrator\\.ssh 目录</span><br><span class=\"line\"># 生成公钥</span><br><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>3、将公钥信息public key 添加到码云账户中即可！</p>\n<p>4、使用码云创建一个自己的仓库！</p>\n<h1 id=\"GIT分支\"><a href=\"#GIT分支\" class=\"headerlink\" title=\"GIT分支\"></a>GIT分支</h1><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p>\n<p>git分支中常用指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，并切换到该分支</span><br><span class=\"line\">git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\">#远程提交</span><br><span class=\"line\">git push -u origin &lt;你要推送的分支名&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>\n\n<p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p>\n<p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ\">https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ</a></p>\n"},{"title":"操作系统面试知识点记录","url":"/2021/03/21/operating-system-interview/","content":"<h1 id=\"1-进程和线程的区别\"><a href=\"#1-进程和线程的区别\" class=\"headerlink\" title=\"1.进程和线程的区别\"></a>1.进程和线程的区别</h1><p>1）进程是资源分配的最小单位，线程是任务执行的最小单位。</p>\n<p>2）一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在。</p>\n<p>3）进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</p>\n<p>4）线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。</p>\n<p>5）线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p>\n<p>6）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p>\n<p>速记：单位，依赖，内存，通信</p>\n<h1 id=\"2-进程的调度算法\"><a href=\"#2-进程的调度算法\" class=\"headerlink\" title=\"2.进程的调度算法\"></a>2.进程的调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>\n<h2 id=\"1-批处理系统\"><a href=\"#1-批处理系统\" class=\"headerlink\" title=\"1. 批处理系统\"></a>1. 批处理系统</h2><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>\n<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>\n<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>\n<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>\n<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>\n<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>\n<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>\n<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>\n<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>\n<h2 id=\"2-交互式系统\"><a href=\"#2-交互式系统\" class=\"headerlink\" title=\"2. 交互式系统\"></a>2. 交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>\n<p><strong>2.1 时间片轮转</strong></p>\n<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>\n<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>\n<ul>\n<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>\n<li>而如果时间片过长，那么实时性就不能得到保证。</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png\" alt=\"img\"></p>\n<p><strong>2.2 优先级调度</strong></p>\n<p>为每个进程分配一个优先级，按优先级进行调度。</p>\n<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>\n<p><strong>2.3 多级反馈队列</strong></p>\n<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>\n<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>\n<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>\n<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png\" alt=\"img\"></p>\n<h2 id=\"3-实时系统\"><a href=\"#3-实时系统\" class=\"headerlink\" title=\"3. 实时系统\"></a>3. 实时系统</h2><p>实时系统要求一个请求在一个确定时间内得到响应。</p>\n<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>\n<p>速记：先进先出，短作业优先，最短剩余时间优先，时间片轮转，优先级调度，多级反馈队列</p>\n<h1 id=\"3-进程间通信的几种方式\"><a href=\"#3-进程间通信的几种方式\" class=\"headerlink\" title=\"3.进程间通信的几种方式\"></a>3.进程间通信的几种方式</h1><ul>\n<li><p>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>\n</li>\n<li><p>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>\n</li>\n<li><p>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>\n</li>\n<li><p>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p>\n</li>\n<li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问。主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p>\n</li>\n<li><p>套接字：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>\n</li>\n</ul>\n<h1 id=\"4-线程通信的方式\"><a href=\"#4-线程通信的方式\" class=\"headerlink\" title=\"4.线程通信的方式\"></a>4.线程通信的方式</h1><p>  a) 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</p>\n<p>  b) 信号量(Semphares)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>\n<p>  c) 事件(Event):Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>\n<h1 id=\"5-什么是死锁？死锁产生的条件？\"><a href=\"#5-什么是死锁？死锁产生的条件？\" class=\"headerlink\" title=\"5.什么是死锁？死锁产生的条件？\"></a>5.什么是死锁？死锁产生的条件？</h1><p>  1)死锁的概念</p>\n<p>　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>\n<p>2). 死锁产生的四个必要条件</p>\n<p>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</p>\n<p>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</p>\n<p>非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放</p>\n<p>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系</p>\n<h1 id=\"6-死锁处理策略\"><a href=\"#6-死锁处理策略\" class=\"headerlink\" title=\"6.死锁处理策略\"></a>6.死锁处理策略</h1><p>1）死锁检测与死锁恢复</p>\n<ol>\n<li>每种类型一个资源的死锁检测（找环）</li>\n<li>每种类型多个资源的死锁检测（矩阵）</li>\n<li>死锁恢复（利用抢占恢复，利用回滚恢复，通过杀死进程恢复）</li>\n</ol>\n<p>2）死锁预防</p>\n<p>死锁预防基本原理：破坏死锁发生的四个必要条件之一不成立。</p>\n<ol>\n<li>破坏互斥条件</li>\n</ol>\n<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>\n<ol start=\"2\">\n<li>破坏占有和等待条件</li>\n</ol>\n<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>\n<ol start=\"3\">\n<li><p>破坏不可抢占条件</p>\n</li>\n<li><p>破坏环路等待</p>\n</li>\n</ol>\n<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>\n<h1 id=\"7-进程有哪几种状态\"><a href=\"#7-进程有哪几种状态\" class=\"headerlink\" title=\"7.进程有哪几种状态\"></a>7.进程有哪几种状态</h1><ul>\n<li>就绪状态（ready）：等待被调度</li>\n<li>运行状态（running）</li>\n<li>阻塞状态（waiting）：等待资源</li>\n</ul>\n<p>应该注意以下内容：</p>\n<ol>\n<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>\n<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>\n</ol>\n<h1 id=\"8-线程有几种状态\"><a href=\"#8-线程有几种状态\" class=\"headerlink\" title=\"8.线程有几种状态\"></a>8.线程有几种状态</h1><p>在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：</p>\n<p><img src=\"http://static.zybuluo.com/Rico123/ot7o6218591iwj9py999hs1u/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg\" alt=\"线程的状态.jpg-59.9kB\"></p>\n<h1 id=\"9-虚拟内存\"><a href=\"#9-虚拟内存\" class=\"headerlink\" title=\"9.虚拟内存\"></a>9.虚拟内存</h1><p><strong>虚拟内存使得应用程序认为它拥有一个连续的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。</strong></p>\n<p>虚拟内存的<strong>目的</strong>是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>\n<p>虚拟内存的<strong>基本思想</strong>是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。</p>\n<p>虚拟内存<strong>优点</strong>：</p>\n<ul>\n<li><p>在内存中可以保留多个进程，系统并发度提高</p>\n</li>\n<li><p>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</p>\n</li>\n</ul>\n<h1 id=\"10-页面置换算法\"><a href=\"#10-页面置换算法\" class=\"headerlink\" title=\"10.页面置换算法\"></a>10.页面置换算法</h1><ul>\n<li><p>FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p>\n</li>\n<li><p>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</p>\n</li>\n<li><p>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</p>\n</li>\n<li><p>OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p>\n</li>\n</ul>\n<h1 id=\"11-颠簸\"><a href=\"#11-颠簸\" class=\"headerlink\" title=\"11.颠簸\"></a>11.颠簸</h1><p>​        颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。</p>\n<p>　　内存颠簸的解决策略包括：</p>\n<ul>\n<li><p>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；</p>\n</li>\n<li><p>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；</p>\n</li>\n<li><p>否则，还剩下两个办法：终止该进程或增加物理内存容量</p>\n</li>\n</ul>\n<h1 id=\"12-分页和分段有什么区别（内存管理）\"><a href=\"#12-分页和分段有什么区别（内存管理）\" class=\"headerlink\" title=\"12.分页和分段有什么区别（内存管理）\"></a>12.分页和分段有什么区别（内存管理）</h1><p>​        段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p>\n<p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p>\n<p>​        段页式：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>\n<p><strong>两者的相同点：</strong></p>\n<p>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。<br>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中 的内存是连续的。</p>\n<p><strong>两者的不同点：</strong></p>\n<ul>\n<li>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li>\n<li>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</li>\n<li>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li>\n<li>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</li>\n<li>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li>\n<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>\n</ul>\n<h1 id=\"13-常用的IO模型\"><a href=\"#13-常用的IO模型\" class=\"headerlink\" title=\"13.常用的IO模型\"></a>13.常用的IO模型</h1><ul>\n<li>阻塞式I/O：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</li>\n<li>非阻塞式I/O：进程发起 IO 系统调用后，内核返回一个错误码而不会被阻塞；应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。如果内核缓冲区有数据，内核就会把数据返回进程。</li>\n<li>I/O复用（select和poll)：使用 select 或者 poll 等待数据，可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后把数据从内核复制到进程中。</li>\n<li>信号驱动式I/O（SIGIO)：当进程发起一个 IO 操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用 IO 读取数据。</li>\n<li>异步I/O（aio_系列函数）：当进程发起一个 IO 操作，进程返回不阻塞，但也不能返回结果；内核把整个 IO 处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</li>\n</ul>\n<h1 id=\"14-select\"><a href=\"#14-select\" class=\"headerlink\" title=\"14.select\"></a>14.select</h1><p>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制，poll 中的描述符是 pollfd 类型的数组；</p>\n<h1 id=\"15-fork函数的作用\"><a href=\"#15-fork函数的作用\" class=\"headerlink\" title=\"15.fork函数的作用\"></a>15.fork函数的作用</h1><p>在 Linux 中 fork 函数是非常重要的函数，它的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程。</p>\n<p><strong>调用 fork(),当控制转移到内核中的 fork 代码后，内核开始做：</strong></p>\n<ol>\n<li>分配新的内存块和内核数据结构给子进程。</li>\n<li>将父进程部分数据结构内容拷贝至子进程。</li>\n<li>将子进程添加到系统进程列表。</li>\n<li>fork返回开始调度器，调度。</li>\n</ol>\n<p><strong>特点：</strong></p>\n<p>1)调用一次，返回两次并发执行</p>\n<p>2)相同但是独立的地址空间</p>\n<p>3)fork 的返回值：fock 函数调用一次却返回两次；向父进程返回子进程的 ID，向子进程中返回 0，</p>\n<p>4)fork 的子进程返回为 0；</p>\n<p>5)父进程返回的是子进程的 pid。</p>\n<p><strong>fork 调用失败的原因</strong></p>\n<p>1)系统中有太多进程。</p>\n<p>2)实际用户的进程数超过限制。</p>\n<h1 id=\"16-协程的概念\"><a href=\"#16-协程的概念\" class=\"headerlink\" title=\"16.协程的概念\"></a>16.协程的概念</h1><p><strong>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</strong>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>\n<p>对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。无论是进程还是线程，都是由操作系统所管理的。</p>\n<p><strong>协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行</strong>。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>\n<p><strong>协程既不是进程也不是线程，协程仅仅是一个特殊的函数</strong>，协程它进程和进程不是一个维度的。</p>\n<p>一个进程可以包含多个线程，一个线程可以包含多个协程。</p>\n<p>一个线程内的多个协程虽然可以切换，但是<strong>多个协程是串行执行的，只能在一个线程内运行，没法利用 CPU 多核能力。</strong></p>\n<p>协程与进程一样，切换是存在上下文切换问题的。</p>\n<h1 id=\"17-linux-进程和线程？\"><a href=\"#17-linux-进程和线程？\" class=\"headerlink\" title=\"17.linux 进程和线程？\"></a>17.linux 进程和线程？</h1><p>进程通过 fork()创建</p>\n<p>线程通过 pthread_create() 函数创建</p>\n<h1 id=\"18-通过进程id查看占用的端口，通过端口号查看占用的进程-id\"><a href=\"#18-通过进程id查看占用的端口，通过端口号查看占用的进程-id\" class=\"headerlink\" title=\"18. 通过进程id查看占用的端口，通过端口号查看占用的进程 id\"></a>18. 通过进程id查看占用的端口，通过端口号查看占用的进程 id</h1><p>通过进程id查看占用的端口:<br>netstat -nap | grep 进程id<br>通过端口号查看占用的进程id :<br>netstat -nap | grep 端口号</p>\n<h1 id=\"19-僵尸进程产生的原因\"><a href=\"#19-僵尸进程产生的原因\" class=\"headerlink\" title=\"19.僵尸进程产生的原因\"></a>19.僵尸进程产生的原因</h1><p>**僵尸进程是指它的父进程没有等待(调用 wait/waitpid)**。如果子进程先结束而父进程后结束，即子进程结束后，父进程还在继续运行但是并未调用 wait/waitpid 那子进程就会成为僵尸进程。但如果子进程后结束，即父进程先结束了，但没有调用 wait/waitpid 来等待子进程的结束， 此时子进程还在运行，父进程已经结束。那么并不会产生僵尸进程。应为每个进程结束时， 系统都会扫描当前系统中运行的所有进程，看看有没有哪个进程时刚刚结束的这个进程的子 进程，如果有就有 init 来接管它，成为它的父进程。</p>\n<p><strong>进程设置僵尸状态的目的是维护子进程的信息，以便父进程在以后某个时间获取</strong>。要在当前 进程中生成一个子进程，一般需要调用 fork 这个系统调用，fork 这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，可以通过返回值来判断其 返回点。如果子进程先于父进程退出， 同时父进程又没有调用 wait/waitpid，则该子进程将成为僵尸进程。</p>\n<p>在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是 仍然保留了一些信息（如进程号 pid 退出状态 运行时间等）。这些保留的信息直到进程通过调用 wait/waitpid 时才会释放。这样就导致了一个问题，如果没有调用 wait/waitpid 的话，那 么保留的信息就不会释放。比如进程号就会被一直占用了。但系统所能使用的进程号的有限 的，如果产生大量的僵尸进程，将导致系统没有可用的进程号而导致系统不能创建进程。所 以我们应该避免僵尸进程。</p>\n<p><strong>如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用 的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p>\n<h1 id=\"20-孤儿进程产生的原因？\"><a href=\"#20-孤儿进程产生的原因？\" class=\"headerlink\" title=\"20.孤儿进程产生的原因？\"></a>20.孤儿进程产生的原因？</h1><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤 儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，管理孤儿进程这个重任就落到了 init 进程身上，因此孤儿进程并 不会有什么危害。</p>\n<h1 id=\"21-讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？\"><a href=\"#21-讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？\" class=\"headerlink\" title=\"21.讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？\"></a>21.讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？</h1><p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序。根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>\n<ol>\n<li>用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。</li>\n<li>内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。<br>运行的程序基本都是运行在用户态。如果我们调用操作系统提供的内核态级别的子功能那就需要系统调用了。</li>\n</ol>\n<p>系统调用：<strong>与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都 必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</strong></p>\n<p>系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。补充：</p>\n<p>用户态切换到内核态的几种方式</p>\n<p><strong>系统调用</strong>: 系统调用是用户态主动要求切换到内核态的一种方式， 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</p>\n<p><strong>异常</strong>：当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</p>\n<p><strong>硬件设备的中断</strong>: 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核态的转换。</p>\n<h1 id=\"22-平常用什么-linux-命令比较多\"><a href=\"#22-平常用什么-linux-命令比较多\" class=\"headerlink\" title=\"22.平常用什么 linux 命令比较多\"></a>22.平常用什么 linux 命令比较多</h1><p>pwd:显示当前所在位置</p>\n<p>sudo + 其他命令：管理员身份运行</p>\n<p>grep:需要搜索的字符串，要搜索的文件 –color： 搜索命令 –color表示高亮显示</p>\n<p>ps -A：列出所有进程</p>\n<p>ps -ef | grep 进程关键字</p>\n<p>kill 进程pid：杀死进程</p>\n<p>find 目录 参数 ： 寻找目录（查）。在/home目录下查找以 .txt 结尾的文件名:find /home -name “*.txt” </p>\n<p>ls ：查看目录信息</p>\n<p>free：显示系统内存的使用情况</p>\n<h1 id=\"23-中断的分类\"><a href=\"#23-中断的分类\" class=\"headerlink\" title=\"23.中断的分类\"></a>23.中断的分类</h1><ul>\n<li><p>中断可以分为同步中断（synchronous）和异步中断(asynchronous)。</p>\n</li>\n<li><p>中断可分为硬中断和软中断。</p>\n</li>\n<li><p>中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。</p>\n</li>\n</ul>\n<p>同步中断是在指令执行时由 CPU 主动产生的，受到 CPU 控制，其执行点是可控的。异步中断是 CPU 被动接收到的，由外设发出的电信号引起，其发生时间不可预测。</p>\n<h1 id=\"24-软中断和硬中断\"><a href=\"#24-软中断和硬中断\" class=\"headerlink\" title=\"24.软中断和硬中断\"></a>24.软中断和硬中断</h1><p>从本质上讲，中断(硬)是一种电信号，当设备有某种事情发生的时候，他就会产生中断，通过 总线把电信号发送给中断控制器。如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，跳到中断处理程序的入口点， 进行中断处理。</p>\n<p>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的 IRQ（中断请求）。</p>\n<p>软中断是由当前正在运行的进程所产生的。</p>\n<p>软中断比硬中断少了一个硬件发送信号的步骤。产生软中断的进程一定是当前正在运行的进 程，因此它们不会中断 CPU。但是它们会中断调用代码的流程。如果硬件需要 CPU 去做一些事情，那么这个硬件会使 CPU 中断当前正在运行的代码。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://blog.csdn.net/justloveyou_/article/details/78304294\">https://blog.csdn.net/justloveyou_/article/details/78304294</a></p>\n<p>[2]<a href=\"http://www.cyc2018.xyz/\">http://www.cyc2018.xyz/</a></p>\n<p>[3]<a href=\"https://leetcode-cn.com/circle/discuss/XXGdoF\">https://leetcode-cn.com/circle/discuss/XXGdoF</a></p>\n","categories":["操作系统"]},{"title":"计算机网络","url":"/2021/03/23/computer-networks-interview/","content":"<h1 id=\"1-Http和Https的区别\"><a href=\"#1-Http和Https的区别\" class=\"headerlink\" title=\"1.Http和Https的区别\"></a>1.Http和Https的区别</h1><p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>\n<ul>\n<li><p>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p>\n</li>\n<li><p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p>\n</li>\n<li><p>开销：Https通信需要证书，而证书一般需要向认证机构购买；\n　</p>\n</li>\n</ul>\n<p>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>\n<h1 id=\"2-HTTP-是哪一层的协议？http常见的状态码\"><a href=\"#2-HTTP-是哪一层的协议？http常见的状态码\" class=\"headerlink\" title=\"2.HTTP 是哪一层的协议？http常见的状态码\"></a>2.HTTP 是哪一层的协议？http常见的状态码</h1><p>HTTP 协议 属于应用层的协议。</p>\n<p><strong>HTTP 协议是基于 TCP 协议的</strong>，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>\n<p>另外， HTTP协议是无状态的协议，它<strong>无法记录客户端用户的状态</strong> 一般我们都是通过Session 来记录客户端用户的状态。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">状态码</th>\n<th align=\"center\">类别</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1XX</td>\n<td align=\"center\">Informational（信息性状态码）</td>\n<td align=\"center\">接收的请求正在处理</td>\n</tr>\n<tr>\n<td align=\"center\">2XX</td>\n<td align=\"center\">Success（成功状态码）</td>\n<td align=\"center\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td align=\"center\">3XX</td>\n<td align=\"center\">Redirection（重定向状态码）</td>\n<td align=\"center\">需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td align=\"center\">4XX</td>\n<td align=\"center\">Client Error（客户端错误状态码）</td>\n<td align=\"center\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td align=\"center\">5XX</td>\n<td align=\"center\">Server Error（服务器错误状态码）</td>\n<td align=\"center\">服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<h2 id=\"1XX-信息\"><a href=\"#1XX-信息\" class=\"headerlink\" title=\"1XX 信息\"></a>1XX 信息</h2><ul>\n<li><u><strong>100 Continue</strong></u> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>\n</ul>\n<h2 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h2><ul>\n<li><u><strong>200 OK</strong></u></li>\n<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>\n<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>\n</ul>\n<h2 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h2><ul>\n<li><u><strong>301 Moved Permanently</strong></u> ：永久性重定向</li>\n<li><u><strong>302 Found</strong></u> ：临时性重定向</li>\n<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>\n<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>\n<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>\n<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>\n</ul>\n<h2 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h2><ul>\n<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>\n<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>\n<li><u><strong>403 Forbidden</strong></u> ：请求被拒绝。(可能没有权限)</li>\n<li><u><strong>404 Not Found</strong></u> :  没有对应资源</li>\n</ul>\n<h2 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h2><ul>\n<li><u><strong>500 Internal Server Error</strong></u>  ：服务器正在执行请求时发生错误。（有内部错误）</li>\n<li><u><strong>503 Service Unavailable</strong></u> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>\n</ul>\n<h1 id=\"3-对称式加密与非对称式加密\"><a href=\"#3-对称式加密与非对称式加密\" class=\"headerlink\" title=\"3.对称式加密与非对称式加密\"></a>3.对称式加密与非对称式加密</h1><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称 加密算法有DES、AES等；</p>\n<p>非对称密钥加密，加密和解密使用不同的密钥。通信发送方获得接收方的公开密钥之后，就 可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。可以更安全地将公 开密钥传输给通信发送方；运算速度慢。典型的非对称加密算法有RSA、DSA等</p>\n<p>HTTPS 采用的加密方式: HTTPS 采用混合的加密机制。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</p>\n<h1 id=\"4-HTTP-2-0\"><a href=\"#4-HTTP-2-0\" class=\"headerlink\" title=\"4.HTTP/2.0\"></a>4.HTTP/2.0</h1><h2 id=\"HTTP-1-x-缺陷\"><a href=\"#HTTP-1-x-缺陷\" class=\"headerlink\" title=\"HTTP/1.x 缺陷\"></a>HTTP/1.x 缺陷</h2><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>\n<ul>\n<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>\n<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>\n<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>\n</ul>\n<h2 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h2><h3 id=\"二进制分帧层\"><a href=\"#二进制分帧层\" class=\"headerlink\" title=\"二进制分帧层\"></a>二进制分帧层</h3><ul>\n<li><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p>\n</li>\n<li><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>\n</li>\n</ul>\n<h3 id=\"服务端推送\"><a href=\"#服务端推送\" class=\"headerlink\" title=\"服务端推送\"></a>服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。</p>\n<h3 id=\"首部压缩\"><a href=\"#首部压缩\" class=\"headerlink\" title=\"首部压缩\"></a>首部压缩</h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>\n<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>\n<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>\n<h1 id=\"5-HTTP报文详解\"><a href=\"#5-HTTP报文详解\" class=\"headerlink\" title=\"5.HTTP报文详解\"></a>5.HTTP报文详解</h1><h2 id=\"请求和响应报文\"><a href=\"#请求和响应报文\" class=\"headerlink\" title=\"请求和响应报文\"></a>请求和响应报文</h2><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p>\n<p>请求报文结构：</p>\n<ul>\n<li>第一行是包含了请求方法、URL、协议版本；</li>\n<li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li>\n<li>一个空行用来分隔首部和内容主体 Body</li>\n<li>最后是请求的内容主体</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET http://www.example.com/ HTTP/1.1</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class=\"line\">Cache-Control: max-age=0</span><br><span class=\"line\">Host: www.example.com</span><br><span class=\"line\">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class=\"line\">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class=\"line\">Proxy-Connection: keep-alive</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla/5.0 xxx</span><br><span class=\"line\"></span><br><span class=\"line\">param1=1&amp;param2=2</span><br></pre></td></tr></table></figure>\n\n<p>响应报文结构：</p>\n<ul>\n<li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li>\n<li>接下来多行也是首部内容</li>\n<li>一个空行分隔首部和内容主体</li>\n<li>最后是响应的内容主体</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Age: 529651</span><br><span class=\"line\">Cache-Control: max-age=604800</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 648</span><br><span class=\"line\">Content-Type: text/html; charset=UTF-8</span><br><span class=\"line\">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class=\"line\">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class=\"line\">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class=\"line\">Keep-Alive: timeout=4</span><br><span class=\"line\">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class=\"line\">Proxy-Connection: keep-alive</span><br><span class=\"line\">Server: ECS (sjc/16DF)</span><br><span class=\"line\">Vary: Accept-Encoding</span><br><span class=\"line\">X-Cache: HIT</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Example Domain&lt;/title&gt;</span><br><span class=\"line\">\t// 省略... </span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-HTTP-1-1-新特点\"><a href=\"#6-HTTP-1-1-新特点\" class=\"headerlink\" title=\"6.HTTP/1.1 新特点\"></a>6.HTTP/1.1 新特点</h1><ul>\n<li>默认是长连接</li>\n<li>支持流水线</li>\n<li>支持同时打开多个 TCP 连接</li>\n<li>支持虚拟主机</li>\n<li>新增状态码 100</li>\n<li>支持分块传输编码</li>\n<li>新增缓存处理指令 max-age</li>\n</ul>\n<h1 id=\"7-GET和POST的区别\"><a href=\"#7-GET和POST的区别\" class=\"headerlink\" title=\"7.GET和POST的区别\"></a>7.GET和POST的区别</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 <strong>请求头</strong> 中。而POST请求会把提交的数据则放置在是HTTP请求报文的 **请求体 **中。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>\n<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>\n<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>\n<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>\n<h2 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>\n<p>所有的安全方法也都是幂等的。</p>\n<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>\n<h2 id=\"请求的大小\"><a href=\"#请求的大小\" class=\"headerlink\" title=\"请求的大小\"></a>请求的大小</h2><p>GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p>\n<h1 id=\"8-TCP-IP-4-层模型了解么\"><a href=\"#8-TCP-IP-4-层模型了解么\" class=\"headerlink\" title=\"8.TCP/IP 4 层模型了解么\"></a>8.TCP/IP 4 层模型了解么</h1><p>TCP/IP 4 层模型:</p>\n<ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层</li>\n</ol>\n<h1 id=\"9-OSI网络体系结构与TCP-IP协议模型\"><a href=\"#9-OSI网络体系结构与TCP-IP协议模型\" class=\"headerlink\" title=\"9.OSI网络体系结构与TCP/IP协议模型\"></a>9.OSI网络体系结构与TCP/IP协议模型</h1><p>​    我们知道TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对OSI七层模型的各层进行简要的介绍：</p>\n<p>　　　　　　　　　<img src=\"http://static.zybuluo.com/Rico123/0qwq331jj8bzgmqst282f6lp/OSI%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8ETCPIP%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png\" alt=\"OSI网络体系结构与TCPIP协议模型.png-51.3kB\">　</p>\n<p>1). 物理层</p>\n<p>　　参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。</p>\n<p>2). 数据链路层（data link layer）</p>\n<p>　　接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p>\n<p>3). 网络层</p>\n<p>　　将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。</p>\n<p>　　　　　　<img src=\"http://static.zybuluo.com/Rico123/ed9145bf4nus32fr7umxxnk7/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E8%B7%AF%E5%B1%82.png\" alt=\"数据链路层与网路层.png-58.4kB\">　　　　</p>\n<p>4). 传输层（transport layer）</p>\n<p>　　在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。</p>\n<p>　　　　　<img src=\"http://static.zybuluo.com/Rico123/5td1y45fm09cbhgw07o6fgfc/%E7%BD%91%E8%B7%AF%E5%B1%82%E4%B8%8E%E4%BC%A0%E8%BE%93%E5%B1%82.png\" alt=\"网路层与传输层.png-52.8kB\">　　　　　</p>\n<p>　　实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。</p>\n<p>5). 会话层（Session Layer）</p>\n<p>　　会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。</p>\n<p>6). 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密</p>\n<p>　　表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p>\n<p>7). 应用层（Application layer）：为用户的应用进程提供网络通信服务</p>\n<h1 id=\"10-三次握手\"><a href=\"#10-三次握手\" class=\"headerlink\" title=\"10.三次握手\"></a>10.三次握手</h1><p><img src=\"/images/pasted-210323threehandshake.jpg\"></p>\n<p><img src=\"/images/pasted-210323fourhandshake.jpg\"></p>\n<p><img src=\"/images/pasted-210323statechange.jpg\"></p>\n<h2 id=\"文字说明\"><a href=\"#文字说明\" class=\"headerlink\" title=\"文字说明\"></a>文字说明</h2><p>三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：</p>\n<ul>\n<li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>\n</li>\n<li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>\n</li>\n<li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>\n</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/Rico123/c7m5fo6qdua0q7me88jm9w10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png\" alt=\"三次握手.png-12.4kB\"></p>\n<h2 id=\"三次握手的原因\"><a href=\"#三次握手的原因\" class=\"headerlink\" title=\"三次握手的原因\"></a>三次握手的原因</h2><p>三次握手的目的是建立可靠的通信信道，三次握手最主要的目的就是双方确认自己与对方的 发送与接收是正常的。</p>\n<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>\n<h2 id=\"为什么两次不行\"><a href=\"#为什么两次不行\" class=\"headerlink\" title=\"为什么两次不行\"></a>为什么两次不行</h2><p>​        为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。</p>\n<p>　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p>\n<h1 id=\"11-四次挥手\"><a href=\"#11-四次挥手\" class=\"headerlink\" title=\"11.四次挥手\"></a>11.四次挥手</h1><p><img src=\"/images/pasted-210323groupchange.jpg\"></p>\n<h2 id=\"文字说明-1\"><a href=\"#文字说明-1\" class=\"headerlink\" title=\"文字说明\"></a>文字说明</h2><ul>\n<li><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>\n</li>\n<li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p>\n</li>\n<li><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>\n</li>\n<li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。<br><img src=\"http://static.zybuluo.com/Rico123/ardiuu1otopo9f1jd4df18iz/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\" alt=\"四次挥手.png-12.6kB\"></p>\n</li>\n</ul>\n<h2 id=\"CLOSE-WAIT-状态问题：\"><a href=\"#CLOSE-WAIT-状态问题：\" class=\"headerlink\" title=\"CLOSE-WAIT 状态问题：\"></a>CLOSE-WAIT 状态问题：</h2><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN 连接释放报文。</p>\n<h2 id=\"TIME-WAIT-状态问题-这个问题问过很多次但总是答得不甚满意-：\"><a href=\"#TIME-WAIT-状态问题-这个问题问过很多次但总是答得不甚满意-：\" class=\"headerlink\" title=\"TIME-WAIT 状态问题(这个问题问过很多次但总是答得不甚满意)：\"></a>TIME-WAIT 状态问题(这个问题问过很多次但总是答得不甚满意)：</h2><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>\n<p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>\n<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一 个新的连接不会出现旧的连接请求报文。</p>\n<p>通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。</p>\n<h1 id=\"12-TCP滑动窗口是干什么的\"><a href=\"#12-TCP滑动窗口是干什么的\" class=\"headerlink\" title=\"12.TCP滑动窗口是干什么的\"></a>12.TCP滑动窗口是干什么的</h1><p>滑动窗口：窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接 收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>\n<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。接收窗口只会对窗口内 最后一个按序到达的字节进行确认。如果发送窗口内的字节已经发送并且收到了确认，那么 就将发送窗口向右滑动一定距离，直到第一个字节不是已发送并且已确认的状态；接收窗口 的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向滑动接收窗口。</p>\n<h1 id=\"13-TCP的可靠性体现在哪里\"><a href=\"#13-TCP的可靠性体现在哪里\" class=\"headerlink\" title=\"13.TCP的可靠性体现在哪里\"></a>13.TCP的可靠性体现在哪里</h1><p>对于可靠性，TCP通过以下方式进行保证：</p>\n<ul>\n<li><p>数据包校验（校验和）：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>\n</li>\n<li><p>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>\n</li>\n<li><p>丢弃重复数据：对于重复数据，能够丢弃重复数据；</p>\n</li>\n<li><p>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>\n</li>\n<li><p>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>\n</li>\n<li><p>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>\n</li>\n<li><p>拥塞控制：当网络拥塞时，减少数据的发送。</p>\n</li>\n</ul>\n<h1 id=\"14-TCP流量控制\"><a href=\"#14-TCP流量控制\" class=\"headerlink\" title=\"14.TCP流量控制\"></a>14.TCP流量控制</h1><p><strong>流量控制如何实现</strong>：流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>\n<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送 速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<h1 id=\"15-拥塞控制如何实现\"><a href=\"#15-拥塞控制如何实现\" class=\"headerlink\" title=\"15.拥塞控制如何实现\"></a>15.拥塞控制如何实现</h1><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞 程度更高。因此当出现拥塞时，应当控制发送方的速率。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>\n<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。</p>\n<p>1）<strong>慢启动：</strong>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p>\n<p>2） <strong>拥塞避免：</strong>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。如果出现了超时，则令慢开始门限 = 拥塞窗口大小 / 2，然后重新执行慢开始。</p>\n<p><img src=\"http://static.zybuluo.com/Rico123/whi0y5sbc3tx9qcdp0s532gw/%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png\" alt=\"慢开始与拥塞避免.png-90.3kB\"></p>\n<p>3）<strong>快重传：</strong>快重传要求接收方在收到一个 <strong>失序的报文段</strong> 后就立即发出 <strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>\n<p><img src=\"http://static.zybuluo.com/Rico123/wuktdms9jtg4s9m4pe5kcbiq/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg\" alt=\"快重传.jpg-42.3kB\"></p>\n<p>4）<strong>快恢复</strong>：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>\n<h1 id=\"16-TCP和UDP有什么区别？及其适用的场景\"><a href=\"#16-TCP和UDP有什么区别？及其适用的场景\" class=\"headerlink\" title=\"16.TCP和UDP有什么区别？及其适用的场景\"></a>16.TCP和UDP有什么区别？及其适用的场景</h1><p>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：</p>\n<ul>\n<li><p>TCP是面向连接的，UDP是无连接的；</p>\n</li>\n<li><p>TCP是可靠的，UDP是不可靠的；</p>\n</li>\n<li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p>\n</li>\n<li><p>TCP是面向字节流的，UDP是面向报文的；</p>\n</li>\n<li><p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p>\n</li>\n<li><p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p>\n</li>\n</ul>\n<p><strong>TCP应用场景</strong>：</p>\n<p>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、 排序等操作，相比之下效率没有UDP高。举几个例子：文件传输、接受邮件、远程登录。</p>\n<p><strong>UDP应用场景</strong>：</p>\n<p>效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话、广播通信（广播、多播）。</p>\n<p>1). TCP对应的应用层协议</p>\n<ul>\n<li><p>FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</p>\n</li>\n<li><p>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</p>\n</li>\n<li><p>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</p>\n</li>\n<li><p>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p>\n</li>\n<li><p>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</p>\n</li>\n</ul>\n<p>2). UDP对应的应用层协议</p>\n<ul>\n<li><p>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p>\n</li>\n<li><p>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>\n</li>\n<li><p>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p>\n</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/Rico123/r3gm4e6y9hlgqllw8ba10676/TCP%E5%92%8CUDP%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.png\" alt=\"TCP和UDP分别对应的常见应用层协议.png-41.5kB\"></p>\n<h1 id=\"17-UDP为何快\"><a href=\"#17-UDP为何快\" class=\"headerlink\" title=\"17.UDP为何快\"></a>17.UDP为何快</h1><p><strong>UDP为何快？</strong></p>\n<ol>\n<li>不需要建立连接</li>\n<li>对于收到的数据，不用给出确认</li>\n<li>没有超时重发机制</li>\n<li>没有流量控制和拥塞控制</li>\n</ol>\n<h1 id=\"18-Mac-地址和-ip-地址的区别？既然有了-Mac-地址，为什么还要-ip-地址呢？\"><a href=\"#18-Mac-地址和-ip-地址的区别？既然有了-Mac-地址，为什么还要-ip-地址呢？\" class=\"headerlink\" title=\"18.Mac 地址和 ip 地址的区别？既然有了 Mac 地址，为什么还要 ip 地址呢？\"></a>18.Mac 地址和 ip 地址的区别？既然有了 Mac 地址，为什么还要 ip 地址呢？</h1><p>MAC地址是烧录在网卡或者接口上的<strong>物理地址</strong>，具有<strong>全球唯一性</strong>，一般不能被改变。IP地址是网络中的主机或接口在网络中的<strong>逻辑地址</strong>，在<strong>同一个网络内具有唯一性</strong>。</p>\n<h1 id=\"19-当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。\"><a href=\"#19-当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。\" class=\"headerlink\" title=\"19.当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。\"></a>19.当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。</h1><ol>\n<li>浏览器查找域名的IP地址 （DNS：获取域名对应的IP）</li>\n<li> 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>\n<li>TCP/IP链接建立起来后，浏览器向web服务器发送HTTP请求（cookies会随着请求发送给服务器）</li>\n<li>服务器处理请求 （请求 处理请求 参数、cookies、生成一个HTML响应）</li>\n<li>服务器返回HTTP报文，发回一个HTML响应。</li>\n<li>浏览器解析渲染页面，浏览器开始显示HTML。</li>\n<li>连接结束</li>\n</ol>\n<p>使用的协议:</p>\n<p><strong>DNS</strong>: 获取域名对应的IP TCP: 与服务器建立TCP连接</p>\n<p><strong>IP</strong>: 建立TCP协议时，需要发送数据，发送数据在网络层上使用IP协议</p>\n<p><strong>OSPF</strong>：IP数据包在路由器之间，路由选择使用OSPF协议</p>\n<p><strong>ARP</strong>：路由器在与服务器进行通信的过程中，将IP地址装换成MAC地址</p>\n<p><strong>HTTP</strong>：客户端浏览器与Web服务器之间的应用层通信协议，在TCP建立完成后，使用HTTP协议访问网页</p>\n<h1 id=\"20-网络层的ARP协议工作原理\"><a href=\"#20-网络层的ARP协议工作原理\" class=\"headerlink\" title=\"20.网络层的ARP协议工作原理\"></a>20.<strong>网络层的ARP协议工作原理</strong></h1><p>​    <strong>网络层的ARP协议完成了IP地址与物理地址的映射</strong>。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>\n<h1 id=\"21-电子邮件的发送过程\"><a href=\"#21-电子邮件的发送过程\" class=\"headerlink\" title=\"21.电子邮件的发送过程?\"></a>21.电子邮件的发送过程?</h1><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>\n<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>\n<ol>\n<li>用户A的邮箱是QQ邮箱，他要发往的邮箱是163邮箱，用户A写好一封邮件点击发送， 即提交到了QQ邮箱服务器，使用的是SMTP协议。</li>\n<li>QQ邮箱会对A发送邮件的收件地址进行解析，判断是否为内部邮箱的账号，如果也是QQ邮箱，会直接存储到自己的存储空间，如果不是则会发送到指定邮箱服务器，使用 的也是SMTP协议。</li>\n<li>163的邮箱服务器收到邮件后会再次判断该邮件是否为自己的邮件，如果是则存到自己的存储空间，等待POP3服务去读取邮件。</li>\n<li>用户B收到消息后，打开客户端访问163服务器，调用POP3服务。</li>\n<li>Pop3服务接到指令后，读取存储空间中发送给B的未读邮件服务。</li>\n<li>将读取到的邮件返回给客户端软件。</li>\n</ol>\n<h1 id=\"22-DNS解析过程，DNS劫持了解吗？\"><a href=\"#22-DNS解析过程，DNS劫持了解吗？\" class=\"headerlink\" title=\"22.DNS解析过程，DNS劫持了解吗？\"></a>22.DNS解析过程，DNS劫持了解吗？</h1><p>DNS完成的工作是：域名到IP地址的解析。将域名和IP地址相互映射的一个分布式数据库。</p>\n<ul>\n<li><p>第一步：客户机提出域名解析请求，并将该请求发送给本地域名服务器。</p>\n</li>\n<li><p>第二步：当本地域名服务器收到请求后，就先查询本地缓存，如果有该纪录项，则本地域名服务器就直接把查询结果返回。</p>\n</li>\n<li><p>第三步：如果本地缓存中没该纪录，则本地域名服务器就直接把请求发给根域名服务器，然 后根域名服务器再返回给本地域名服务器一个所查询域(根子域)主域名服务器地址。</p>\n</li>\n<li><p>第四步：本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自 己的缓存，如果没该纪录，则返回相关下级域名服务器地址。</p>\n</li>\n<li><p>第五步：重复第四步，直到找到正确纪录。</p>\n</li>\n<li><p>第六步：本地域名服务器把返回结果保存到缓存，以备下一次使用，同时还将结果返回给客 户机。</p>\n</li>\n</ul>\n<p>DNS劫持：在DNS服务器中，将www..com的域名对应的IP地址进行了变化。你解析出来的 域名对应的IP，在劫持前后不一样。</p>\n<p>HTTP劫持：你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。</p>\n<p>DNS在区域传输的时候使用TCP协议,其他时候使用UDP协议。</p>\n<h1 id=\"23-session和cookie的问题？\"><a href=\"#23-session和cookie的问题？\" class=\"headerlink\" title=\"23.session和cookie的问题？\"></a>23.session和cookie的问题？</h1><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式</p>\n<p>Cookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录用户的状态</p>\n<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将Cookie 信息加密然后使用到的时候再去服务器端解密。</p>\n<h1 id=\"24-HTTP是不保存状态的协议-如何保存用户状态\"><a href=\"#24-HTTP是不保存状态的协议-如何保存用户状态\" class=\"headerlink\" title=\"24.HTTP是不保存状态的协议,如何保存用户状态?\"></a>24.HTTP是不保存状态的协议,如何保存用户状态?</h1><p>HTTP 是一种无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。主要通过session机制来进行解决，Session 的主要作用就是通过服务端记录用户的状态。</p>\n<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下， 我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>\n<p>ps:<strong>Cookie</strong> 被禁用怎么办： 最常用的就是利用 URL 把 Session ID 直接附加在URL路径的后面。</p>\n<h1 id=\"25-Session-与-Cookie-的对比\"><a href=\"#25-Session-与-Cookie-的对比\" class=\"headerlink\" title=\"25.Session 与 Cookie 的对比\"></a>25.Session 与 Cookie 的对比</h1><ul>\n<li><p>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p>\n</li>\n<li><p>大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>\n</li>\n<li><p>安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>\n</li>\n<li><p>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>\n</li>\n</ul>\n<h1 id=\"26-IP地址的划分\"><a href=\"#26-IP地址的划分\" class=\"headerlink\" title=\"26.IP地址的划分\"></a>26.IP地址的划分</h1><p>IP 地址的编址方式经历了三个历史阶段：</p>\n<ul>\n<li>分类</li>\n<li>子网划分</li>\n<li>无分类</li>\n</ul>\n<h2 id=\"1-分类\"><a href=\"#1-分类\" class=\"headerlink\" title=\"1. 分类\"></a>1. 分类</h2><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>\n<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png\" alt=\"img\"></p>\n<ul>\n<li>A类地址：以0开头，第一个字节范围：0~127；（地址范围1.0.0.0到127.255.255.255）</li>\n<li>B类地址：以10开头，第一个字节范围：128~191；（地址范围128.0.0.0-191.255.255.255）</li>\n<li>C类地址：以110开头，第一个字节范围：192~223；（地址范围192.0.0.0-223.255.255.255）</li>\n<li>D类地址：以1110开头，第一个字节范围为224~239；（地址范围224.0.0.0到239.255.255.255。）</li>\n<li>E类地址：以1111开头，保留地址</li>\n</ul>\n<h2 id=\"2-子网划分\"><a href=\"#2-子网划分\" class=\"headerlink\" title=\"2. 子网划分\"></a>2. 子网划分</h2><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>\n<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>\n<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>\n<p>注意，外部网络看不到子网的存在。</p>\n<h2 id=\"3-无分类\"><a href=\"#3-无分类\" class=\"headerlink\" title=\"3. 无分类\"></a>3. 无分类</h2><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>\n<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>\n<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>\n<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>\n<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p>\n<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>\n<h1 id=\"27-DDos攻击了解吗？\"><a href=\"#27-DDos攻击了解吗？\" class=\"headerlink\" title=\"27.DDos攻击了解吗？\"></a>27.DDos攻击了解吗？</h1><p>分布式拒绝服务，一般来说是指攻击者利用一些被控制的设备对目标网站在较短的时间内发 起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://leetcode-cn.com/circle/discuss/XXGdoF\">https://leetcode-cn.com/circle/discuss/XXGdoF</a></p>\n<p>[2]<a href=\"https://blog.csdn.net/justloveyou_/article/details/78303617?spm=1001.2014.3001.5501\">https://blog.csdn.net/justloveyou_/article/details/78303617?spm=1001.2014.3001.5501</a></p>\n<p>[3]<a href=\"http://www.cyc2018.xyz/\">http://www.cyc2018.xyz/</a></p>\n","categories":["计算机网络"],"tags":["面试"]},{"title":"华为面经体验","url":"/2021/04/08/HuaweiMainjing210408/","content":"<h1 id=\"http-协议如何保证可靠性\"><a href=\"#http-协议如何保证可靠性\" class=\"headerlink\" title=\"http 协议如何保证可靠性\"></a>http 协议如何保证可靠性</h1><p><strong>重要的数据，要加密</strong>，比如用户名密码，我们需要加密，这样即使被抓包监听，他们也不知道原始数据是什么（如果简单的md5，是可以暴力破解），所以加密方法越复杂越安全，根据需要，常见的是 md5(不可逆)，aes（可逆），自由组合吧,你还可以加一些特殊字符啊，没有做不到只有想不到， 举例：username = aes(username), pwd = MD5(pwd + username);。。。。。</p>\n<p><strong>非重要数据，要签名</strong>，签名的目的是为了防止篡改，比如<a href=\"http://www.xxx.com/getnews?id=1%EF%BC%8C%E8%8E%B7%E5%8F%96id%E4%B8%BA1%E7%9A%84%E6%96%B0%E9%97%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E7%AD%BE%E5%90%8D%E9%82%A3%E4%B9%88%E9%80%9A%E8%BF%87id=2,%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%962%E7%9A%84%E5%86%85%E5%AE%B9%E7%AD%89%E7%AD%89%E3%80%82%E6%80%8E%E6%A0%B7%E7%AD%BE%E5%90%8D%E5%91%A2%EF%BC%9F%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8sign%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8E%9F%E9%93%BE%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%E5%8A%A0%E4%B8%80%E4%B8%AAsign%E5%8F%82%E6%95%B0%EF%BC%8Csign=md5(id=1)%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E5%8F%97%E5%88%B0%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%AA%8C%E8%AF%81sign%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8Emd5(id=1)%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%AD%89%E4%BA%8E%E8%AF%B4%E6%98%8E%E6%AD%A3%E5%B8%B8%E8%AF%B7%E6%B1%82%E3%80%82%E8%BF%99%E4%BC%9A%E6%9C%89%E4%B8%AA%E5%BC%8A%E7%AB%AF%EF%BC%8C%E5%81%87%E5%A6%82%E8%A7%84%E5%88%99%E8%A2%AB%E5%8F%91%E7%8E%B0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E4%BC%9A%E8%A2%AB%E4%BC%AA%E9%80%A0%EF%BC%8C%E6%89%80%E4%BB%A5%E9%80%82%E5%BD%93%E5%A4%8D%E6%9D%82%E4%B8%80%E4%BA%9B%EF%BC%8C%E8%BF%98%E6%98%AF%E8%83%BD%E5%A4%9F%E6%8F%90%E9%AB%98%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E3%80%82\">http://www.xxx.com/getnews?id=1，获取id为1的新闻，如果不签名那么通过id=2,就可以获取2的内容等等。怎样签名呢？通常使用sign，比如原链接请求的时候加一个sign参数，sign=md5(id=1)，服务器接受到请求，验证sign是否等于md5(id=1)，如果等于说明正常请求。这会有个弊端，假如规则被发现，那么就会被伪造，所以适当复杂一些，还是能够提高安全性的。</a></p>\n<p><strong>登录态怎么做，</strong>http是无状态的，也就是服务器没法自己判断两个请求是否有联系，那么登录之后，以后的接口怎么判定是否登录呢，简单的做法，在数据库中存一个token字段（名字随意），当用户调用登陆接口成功的时候，就将该字段设一个值，（比如aes(过期时间)），同时返回给前端，以后每次前端请求带上该值，服务器首先校验是否过期，其次校验是否正确，不通过就让其登陆。（redis 做这个很方便哦，key有过期时间）。</p>\n<p>具体可参考：</p>\n<p><a href=\"https://blog.csdn.net/l18848956739/article/details/81011194\">如何保证http传输安全性</a> </p>\n<p><a href=\"%5Bhttps://hellogoogle.blog.csdn.net/article/details/94440881?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1329187.12416.16178842483851657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control%5D(https://hellogoogle.blog.csdn.net/article/details/94440881?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1329187.12416.16178842483851657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control)\">【Java】【通信安全】怎么保证http请求的安全性</a></p>\n<h1 id=\"IP-TCP-UDP首部详解\"><a href=\"#IP-TCP-UDP首部详解\" class=\"headerlink\" title=\"IP,TCP,UDP首部详解\"></a>IP,TCP,UDP首部详解</h1><h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><p><img src=\"https://img-blog.csdn.net/20160916110056051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p><img src=\"https://img-blog.csdn.net/20160916110125505?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p><img src=\"https://img-blog.csdn.net/20160916110144427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_39584315/article/details/79387811?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242\">IP、TCP、UDP首部详解</a></p>\n<h1 id=\"多线程相关面试题\"><a href=\"#多线程相关面试题\" class=\"headerlink\" title=\"多线程相关面试题\"></a>多线程相关面试题</h1><p>具体可参考：</p>\n<p> <a href=\"https://www.cnblogs.com/weibanggang/p/9470462.html\">多线程面试题</a></p>\n<h1 id=\"IPv4和-IPv6的地址长度分别是多少位？\"><a href=\"#IPv4和-IPv6的地址长度分别是多少位？\" class=\"headerlink\" title=\"IPv4和 IPv6的地址长度分别是多少位？\"></a>IPv4和 IPv6的地址长度分别是多少位？</h1><p>ipv4的地址是32位，用点分十进制表示，每八位划分，也就是四个0~255的十进制数，这是很常见的。</p>\n<p>ipv6的地址是128位，一般用点分十六进制表示，每八位划分，也就是十六个0x00~0xff的十六进制数。</p>\n<p>IPv6的地址空间更大。IPv4中规定IP地址长度为32,即有2^32-1个地址；而IPv6中IP地址的长度为128,即有2^128-1个地址。夸张点说就是，如果IPV6被广泛应用以后，全世界的每一粒沙子都会有相对应的一个IP地址。</p>\n<h1 id=\"ArrayList和LinkedList的区别，以及应用场景\"><a href=\"#ArrayList和LinkedList的区别，以及应用场景\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别，以及应用场景\"></a>ArrayList和LinkedList的区别，以及应用场景</h1><ol>\n<li>ArrayList是基于数组实现的，其构造函数为：</li>\n</ol>\n<p>private transient Object[] elementData;</p>\n<p>private int size;</p>\n<p>ArryList初始化时，elementData数组大小默认为10；</p>\n<p>每次add（）时，先调用ensureCapacity（）保证数组不会溢出，如果此时已满，会扩展为数组length的1.5倍+1，然后用array.copy的方法，将原数组拷贝到新的数组中；</p>\n<p>ArrayList线程不安全，Vector方法是同步的，线程安全；</p>\n<ol start=\"2\">\n<li>LinkedList是基于双链表实现的：</li>\n</ol>\n<p>Object element;</p>\n<p>Entry next,previous;</p>\n<p>初始化时，有个header Entry，值为null；</p>\n<p>使用header的优点是：在任何一个条目（包括第一个和最后一个）都有一个前置条目和一个后置条目，因此在LinkedList对象的开始或者末尾进行插入操作没有特殊的地方；</p>\n<p><strong>使用场景：</strong></p>\n<p>如果应用程序对各个索引位置的元素进行大量的存取或删除操作，ArrayList对象要远优于LinkedList对象；<br>如果应用程序主要是对列表进行循环，并且循环时候进行插入或者删除操作，LinkedList对象要远优于ArrayList对象；</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/github_37130188/article/details/96508345\">ArrayList和LinkedList的区别，以及应用场景</a></p>\n<h1 id=\"如何实现线程同步\"><a href=\"#如何实现线程同步\" class=\"headerlink\" title=\"如何实现线程同步\"></a>如何实现线程同步</h1><h2 id=\"Synchronized-用在普通方法和-static-上的区别\"><a href=\"#Synchronized-用在普通方法和-static-上的区别\" class=\"headerlink\" title=\"Synchronized 用在普通方法和 static 上的区别\"></a>Synchronized 用在普通方法和 static 上的区别</h2><p>当使用synchronized修饰静态方法时，线程此时获得的锁对象是类的Class对象（<strong>堆内存中只有唯一一个Class对象，因为Class对象是在类加载时产生的，而类加载只执行一次</strong>），因此会锁住整个类，其他线程无法访问该类的同步静态方法，但是可以访问非同步的方法</p>\n<p>回答2：</p>\n<p>synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；</p>\n<p>synchronized修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p>\n<p>具体可参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_33819764/article/details/81736729\">【多线程】实现线程同步的几种方法</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_43658899/article/details/107230699\">Synchronized关键字加在普通方法上和加在静态方法上有什么区别?</a></p>\n<p><a href=\"https://www.cnblogs.com/suger43894/p/12171341.html\">synchronized底层原理</a></p>\n<h1 id=\"如何实现线程安全\"><a href=\"#如何实现线程安全\" class=\"headerlink\" title=\"如何实现线程安全\"></a>如何实现线程安全</h1><p>线程安全在三个方面体现</p>\n<p>1.原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</p>\n<p>2.可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</p>\n<p>3.有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>\n<ul>\n<li><strong>原子性</strong>：JDK里面提供了很多atomic类，AtomicInteger,AtomicLong,AtomicBoolean等等。</li>\n</ul>\n<p>它们是通过CAS完成原子性。</p>\n<ul>\n<li><strong>原子性：</strong>synchronized是一种同步锁，通过锁实现原子操作。</li>\n</ul>\n<p>JDK提供锁分两种：一种是synchronized，依赖JVM实现锁，因此在这个关键字作用对象的作用范围内是同一时刻只能有一个线程进行操作；另一种是LOCK，是JDK提供的代码层面的锁，依赖CPU指令，代表性的是ReentrantLock。</p>\n<p>synchronized修饰的对象有四种：</p>\n<p>（1）修饰代码块，作用于调用的对象；</p>\n<p>（2）修饰方法，作用于调用的对象；</p>\n<p>（3）修饰静态方法，作用于所有对象；</p>\n<p>（4）修饰类，作用于所有对象。</p>\n<ul>\n<li><p>可见性—volatile</p>\n<p>对于可见性，JVM提供了synchronized和volatile。这里我们看volatile。</p>\n<p>（1）volatile的可见性是通过内存屏障和禁止重排序实现的</p>\n<p>volatile会在写操作时，会在写操作后加一条store屏障指令，将本地内存中的共享变量值刷新到主内存：<br>volatile在进行读操作时，会在读操作前加一条load指令，从内存中读取共享变量：</p>\n<p>2）但是volatile不是原子性的，进行++操作不是安全的。执行后发现线程不安全，原因是 执行conut++ 时分成了三步，第一步是取出当前内存 count 值，这时 count 值时最新的，接下来执行了两步操作，分别是 +1 和重新写回主存。假设有两个线程同时在执行 count++ ，两个内存都执行了第一步，比如当前 count 值为 5 ，它们都读到了，然后两个线程分别执行了 +1 ，并写回主存，这样就丢掉了一次加一的操作。</p>\n<p>（3）volatile适用的场景</p>\n<p>既然volatile不适用于计数，那么volatile适用于哪些场景呢：</p>\n<p>\\1. 对变量的写操作不依赖于当前值</p>\n<p>\\2. 该变量没有包含在具有其他变量不变的式子中</p>\n</li>\n<li><p>有序性</p>\n</li>\n</ul>\n<p>有序性是指，在JMM中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>可以通过volatile、synchronized、lock保证有序性。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_40459875/article/details/80290875\">Java中如何保证线程安全性</a></p>\n<h1 id=\"Java中如何保证线程安全性\"><a href=\"#Java中如何保证线程安全性\" class=\"headerlink\" title=\"Java中如何保证线程安全性\"></a>Java中如何保证线程安全性</h1><p> <a href=\"https://blog.csdn.net/weixin_40459875/article/details/80290875\">ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</a></p>\n<p>ReentrantLock的介绍<br>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。在java关键字synchronized隐式支持重入性（关于synchronized可以看这篇文章），synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：1. 重入性的实现原理；2. 公平锁和非公平锁。<br>具体参考：<br><a href=\"https://blog.csdn.net/ThinkWon/article/details/102469388\">ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</a></p>\n<h1 id=\"MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖\"><a href=\"#MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖\" class=\"headerlink\" title=\"MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖\"></a>MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖</h1><h2 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h2><p>前面提到mysql中是通过B+树来组织一张表数据的，而B+树每个节点上都有一个关键字，在进行搜索的时候要从根节点开始查找，直到在叶子节点上查询到对应的关键字和这行数据。那么MySQL中是使用什么作为B+树节点上的关键字呢？答案是主键索引，MySQL是通过主键索引作为B+树节点上的关键字来组织数据的。那么MySQL又是怎样确定使用哪个字段作为主键索引呢？规则如下：</p>\n<p>如果建表时指定了主键，则使用主键作为B+树节点的关键字。<br>如果表中没有主键，但是有唯一索引，则会选取一个唯一索引作为关键字。<br>如果既没有主键也没有唯一索引，MySQL会自动生成一个6字节的整型唯一标识作为关键字。<br>也就是说，MySQL每张表中都必须有一个主键索引，使用这个主键索引作为关键字将整张表组织成一棵B+树。</p>\n<h2 id=\"聚簇索引和非聚簇索引\"><a href=\"#聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"聚簇索引和非聚簇索引\"></a>聚簇索引和非聚簇索引</h2><p>在MySQL中不管是InnoDB还是MyISAM都是使用B+树来组织表中的数据的。但是在具体实现方法上略有不同。InnoDB的主键索引是聚簇索引，在InnoDB的实现中，把主键作为关键字组织到B+树的各个节点上，而叶子节点上存储的是主键列的值和对应的整行数据。注意这里说的是将表中实际的一整行数据直接存到叶子节点上MyISAM是非聚簇索引，在MyISAM的实现中，叶子节点中存储的是一行数据在磁盘上的地址（可以理解为行号）。所以聚簇索引和非聚簇索引本质的区别就是B+树的叶子节点上存储的是行数据还是行数据的地址（行号）。</p>\n<h1 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h1><h2 id=\"索引的类型：\"><a href=\"#索引的类型：\" class=\"headerlink\" title=\"索引的类型：\"></a>索引的类型：</h2><p><strong>普通索引：</strong><br>最基本的索引，没有任何限制，是我们大多数情况下使用到的索引<br>如何创建：<br>1.直接创建：<br>CREATE INDEX index_name ON table(column(length))<br>2.修改原有表结构：<br>ALTER TABLE table_name ADD INDEX index_name ON(column(length))<br>若是char、varchar类型length可不填，默认字段的实际长度，若是blob、text类型则必须指定长度<br><strong>唯一索引：</strong><br>与普通索引类似，不同之处在于索引列的值必须唯一，但允许有空值(和主键不同之处)，若是联合索引，则列值得组合必须唯一<br>如何创建：<br>1.直接创建：<br>CREATE UNIQUE INDEX index_name ON table(column(length))<br>2.修改原有表结构：<br>ALTER TABLE table ADD UNIQUE index_name ON(column(length))<br><strong>主键索引：</strong><br>不允许有空值，主键索引建立的规则是int优于varchar，一般在剪标的时候创建，最好是与表的其他字段不想关的列或者是业务不相关的列，一般为int且是AUTO_INCREMENT自增长类型的<br><strong>联合索引：</strong><br>通俗地讲就是，索引包含多个字段但只有一个名称，这个才是本篇文章要讲的重点<br>如何创建：<br>CREATE INDEX index_name ON table_name(column1(length1),column2(length2……))<br>一个联合索引根据”最左前缀”会包含多个索引：<br>比如：建立了联合索引(A,B,C)，实际上它包含了3个索引，分别是(A)、(A,B)、(A,B,C)，即包含了联合索引的左子集，这也是为什么我们建了联合索引(A,B,C)，就没必要再单独建一个普通索引(A)的原因<br>建立联合索引的时候，通常需要将其他相关的查询都拿来参考，以便做综合评估，进一步提高索引的使用效率与查询效率<br><strong>联合索引的特点：</strong><br>实例的背景——在T_news表中建立以ischecked、channel_id、audit_time3个字段为联合索引<br>a.最左前缀：索引where时的条件要按照建立索引的时候字段的排列顺序<br>实例如下：<br>where条件单独使用ischecked字段，符合最左前缀，联合索引起作用</p>\n<h1 id=\"创建索引的几个原则\"><a href=\"#创建索引的几个原则\" class=\"headerlink\" title=\"创建索引的几个原则\"></a>创建索引的几个原则</h1><p><strong>a.最左前缀匹配原则</strong>，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like ‘%…’)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，若建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整<br><strong>b.=和in可以乱序，</strong>比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会优化成索引可识别的形式<br><strong>c.尽量选择区分度高(cardinality越大越好)的列作为索引</strong>,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，一般需要join的字段都要求是0.1以上，当然，使用场景不同，该值也难以确定<br><strong>d.索引列不能是表达式的一部分或mysql函数的参数</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，因为b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，成本太大，故不能走索引，所以语句应写成create_time = unix_timestamp(’2014-05-29’)<br><strong>e.尽量的扩展索引，</strong>不要新建索引，比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/linbiaorui/article/details/72793527\">mysql索引优化</a> </p>\n<h1 id=\"Java语言的特点和特性\"><a href=\"#Java语言的特点和特性\" class=\"headerlink\" title=\"Java语言的特点和特性\"></a>Java语言的特点和特性</h1><h2 id=\"1-Java语言的主要特点：\"><a href=\"#1-Java语言的主要特点：\" class=\"headerlink\" title=\"1.　　Java语言的主要特点：\"></a>1.　　<strong>Java</strong>语言的主要特点：</h2><p>　　　1. 跨平台性</p>\n<p>　　　所谓的跨平台性，是指软件可以不受计算机硬件和操作系统的约束而在任意计算机环境下正常运行。这是软件发展的趋势和编程人员追求的目标。之所以这样说，是因为计算机硬件的种类繁多，操作系统也各不相同，不同的用户和公司有自己不同的计算机环境偏好，而软件为了能在这些不同的环境里正常运行，就需要独立于这些平台。而在<strong>Java</strong>语言中， <strong>Java</strong>自带的虚拟机很好地实现了跨平台性。 <strong>Java</strong>源程序代码经过编译后生成二进制的字节码是与平台无关的，但是可被<strong>Java</strong>虚拟机识别的一种机器码指令。 <strong>Java</strong>虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得<strong>Java</strong>语言具备跨平台性。</p>\n<p>　　　2. 面向对象</p>\n<p>　　　面向对象是指以对象为基本粒度，其下包含属性和方法。对象的说明用属性表达，而通过使用方法来操作这个对象。面向对象技术使得应用程序的开发变得简单易用，节省代码。<strong>Java</strong>是一种面向对象<strong>的语言</strong>，也继承了面向对象的诸多好处，如代码扩展、代码复用等。</p>\n<p>　　　3. 安全性</p>\n<p>　　　安全性可以分为四个层面，即语言级安全性、编译时安全性、运行时安全性、可执行代码安全性。语言级安全性指<strong>Java</strong>的数据结构是完整的对象，这些封装过的数据类型具有安全性。编译时要进行<strong>Java</strong>语言和语义的检查，保证每个变量对应一个相应的值，编译后生成<strong>Java</strong>类。运行时<strong>Java</strong>类需要类加载器载入www jxzxmr net，并经由字节码校验器校验之后才可以运行。 <strong>Java</strong>类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。</p>\n<p>　　　4. 多线程</p>\n<p>　　　多线程在操作系统中已得到了最成功的应用。多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于支持事务并发和多任务处理。 <strong>Java</strong>除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。</p>\n<p>　　　5. 简单易用</p>\n<p>　　　<strong>Java</strong>源代码的书写不拘泥于特定的环境，可以用记事本、文本编辑器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。</p>\n<h2 id=\"2-Java语言的几大特性：\"><a href=\"#2-Java语言的几大特性：\" class=\"headerlink\" title=\"2.　　Java语言的几大特性：\"></a>2.　　<strong>Java</strong>语言的几大<strong>特性</strong>：</h2><p>　　　1.封装： </p>\n<p>　　　封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在<strong>java</strong>中通过关键字private，protected和public实现封装。什么是封装？封装把对象的所有组成部分组合在一起，封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。</p>\n<p>　　　2.继承：</p>\n<p>　　　继承是面向对象最显著的一个<strong>特性</strong>。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 <strong>Java</strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。这种技术使得复用以前的代码非常容易，能够大大缩短开发周期，降低开发费用</p>\n<p>　　　3.多态： </p>\n<p>　　　按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的<strong>特性</strong>以不同的方式运作 多态的话，我觉得是更好的利用了继承这一<strong>特性</strong>，然后为什么能实现多态，因为可以重写父类的方法。说重写可能不清楚，具体来说就是子类父类可以存在分别存在名字相同的属性或者方法，然后可视声明的类去调用相应的方法等。</p>\n<p>　　　4.抽象：<br>　　　抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法，我觉得理解成一种方法比较好。就是我们通过对事物的认知，将某一或者一类事物的属性变化成<strong>JAVA</strong>语言能识别的类。</p>\n<h1 id=\"static关键字总结\"><a href=\"#static关键字总结\" class=\"headerlink\" title=\"static关键字总结\"></a>static关键字总结</h1><h2 id=\"静态变量和静态方法\"><a href=\"#静态变量和静态方法\" class=\"headerlink\" title=\"静态变量和静态方法\"></a><strong>静态变量和静态方法</strong></h2><p>static关键字最基本的用法是：</p>\n<p>1、被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来</p>\n<p>2、被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来\\</p>\n<h2 id=\"静态块\"><a href=\"#静态块\" class=\"headerlink\" title=\"静态块\"></a><strong>静态块</strong></h2><p>静态块也是static的重要应用之一。也是用于初始化一个类的时候做操作用的，和静态变量、静态方法一样，<strong>静态块里面的代码只执行一次，且只在初始化类的时候执行</strong>。静态块很简单，不过提三个小细节：</p>\n<ol>\n<li><p><strong>静态资源的加载顺序是严格按照静态资源的定义顺序来加载的</strong>。</p>\n</li>\n<li><p><strong>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问</strong>。</p>\n</li>\n<li><p><strong>静态代码块是严格按照父类静态代码块-&gt;子类静态代码块的顺序加载的，且只加载一次</strong>。</p>\n<p>最后一个小例子：</p>\n</li>\n</ol>\n<p>具体可参考：</p>\n<p> <a href=\"https://www.cnblogs.com/swisszhang/p/9892992.html\">static关键字作用总结</a></p>\n<h1 id=\"final的用法\"><a href=\"#final的用法\" class=\"headerlink\" title=\"final的用法\"></a>final的用法</h1><h3 id=\"1-修饰数据\"><a href=\"#1-修饰数据\" class=\"headerlink\" title=\"1.修饰数据\"></a>1.修饰数据</h3><h3 id=\"2-修饰方法参数\"><a href=\"#2-修饰方法参数\" class=\"headerlink\" title=\"2.修饰方法参数\"></a>2.修饰方法参数</h3><h3 id=\"3-修饰方法\"><a href=\"#3-修饰方法\" class=\"headerlink\" title=\"3.修饰方法\"></a>3.修饰方法</h3><h3 id=\"4-修饰类\"><a href=\"#4-修饰类\" class=\"headerlink\" title=\"4.修饰类\"></a>4.修饰类</h3><p>总结<br>final关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：</p>\n<ol>\n<li><p>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；</p>\n</li>\n<li><p>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；</p>\n</li>\n<li><p>修饰方法，表示该方法无法被重写；</p>\n</li>\n<li><p>修饰类，表示该类无法被继承。</p>\n</li>\n</ol>\n<p>上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。</p>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><h2 id=\"volatile的第一个特性–保证可见性\"><a href=\"#volatile的第一个特性–保证可见性\" class=\"headerlink\" title=\"volatile的第一个特性–保证可见性\"></a>volatile的第一个特性–保证可见性</h2><p>解决内存可见性问题方式的一种是加锁，但是使用锁太笨重，因为它会带来线程上下文的切换开销。Java提供了一种弱形式的同步，也就是volatile关键字。该关键字确保对一个变量的更新对其他线程马上可见。</p>\n<p><strong>当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。</strong></p>\n<p><strong>当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。</strong></p>\n<p>理解volatile保证可见性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。</p>\n<h2 id=\"volatile的第二个特性–保证有序性\"><a href=\"#volatile的第二个特性–保证有序性\" class=\"headerlink\" title=\"volatile的第二个特性–保证有序性\"></a>volatile的第二个特性–保证有序性</h2><p>Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。</p>\n<blockquote>\n<p>什么是数据依赖性？<br>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>\n</blockquote>\n<p>在单线程下重排序可以保证最终执行结果与程序顺序执行的结果一致，但是在多线程下就会出现问题。</p>\n<h2 id=\"volatile保证有序性和可见性的原理–内存屏障\"><a href=\"#volatile保证有序性和可见性的原理–内存屏障\" class=\"headerlink\" title=\"volatile保证有序性和可见性的原理–内存屏障\"></a>volatile保证有序性和可见性的原理–内存屏障</h2><p>前面介绍了volatile关键字的两大特性，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序。</p>\n<h3 id=\"什么是内存屏障\"><a href=\"#什么是内存屏障\" class=\"headerlink\" title=\"什么是内存屏障\"></a>什么是内存屏障</h3><p>维基百科中对内存屏障的描述如下：</p>\n<blockquote>\n<p>内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，它使得 CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行, 也就是说在memory barrier 之前的指令和memory barrier之后的指令不会由于系统优化等原因而导致乱序。<br>大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。<br>语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。</p>\n</blockquote>\n<p>在JVM中提供了四类内存屏障指令：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-06ae616adae545c36a01f7eaa192ac52_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"内存屏障的插入\"><a href=\"#内存屏障的插入\" class=\"headerlink\" title=\"内存屏障的插入\"></a>内存屏障的插入</h3><p>了解什么是内存屏障之后，我们再来看看JMM是如何插入内存屏障的。</p>\n<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p>\n<ul>\n<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>\n<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>\n<li>在每个volatile读操作的前面插入一个LoadLoad屏障。</li>\n<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>\n</ul>\n<p>在此策略下，volatile写操作插入内存屏障后生成的指令序列如下图所示。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-e6737695804284045f66f0e1163425b0_720w.jpg\" alt=\"img\"></p>\n<p>由于StoreStore屏障保障上面所有的普通写在volatile写之前刷新到主内存，StoreStore屏障可以保证在volaitle写之前，其前面的所有普通写操作已经对任意处理器可见了。</p>\n<p>volatile读操作插入内存屏障后生成的指令序列如下图所示。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-c1a18b0fea3fcd2efe52ca35f658d1d1_720w.jpg\" alt=\"img\"></p>\n<p>需要注意的是，在实际执行时，为了保证效率，编译器可以根据具体的情况省略不必要的屏障。</p>\n<p>关于volatile的特性和实现原理就介绍到这里。</p>\n<p>具体参考：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/151289085\">volatile关键字的作用以及原理</a></p>\n<h1 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h1><p><strong>存储引擎</strong>说白了就是如何存储数据、如何为存储的数据建立<strong>索引</strong>和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以<strong>存储引擎</strong>也可以称为表类型（即存储和操作此表的类型）。</p>\n<p>在Oracle 和SQL Server等数据库中只有一种<strong>存储引擎</strong>，所有数据存储管理机制都是一样的。而MySql数据库提供了多种<strong>存储引擎</strong>。用户可以根据不同的需求为数据表选择不同的<strong>存储引擎</strong>，用户也可以根据自己的需要编写自己的<strong>存储引擎</strong>。</p>\n<p>\\2.   <strong>存储引擎</strong>的类型及特点</p>\n<table>\n<thead>\n<tr>\n<th><strong>引擎名称</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺陷</strong></th>\n<th><strong>应用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>MyISAM</strong></td>\n<td>独立于操作系统，这说明可以轻松地将其从Windows服务器移植到Linux服务器</td>\n<td>不支持事务/行级锁/外键约束</td>\n<td>适合管理邮件或Web服务器日志数据</td>\n</tr>\n<tr>\n<td><strong>InnoDB</strong></td>\n<td>健壮的事务型<strong>存储引擎</strong>；支持事务/行级锁/外键约束自动灾难恢复/AUTO_INCREMENT</td>\n<td></td>\n<td>需要事务支持，并且有较高的并发读取频率</td>\n</tr>\n<tr>\n<td><strong>MEMORY</strong></td>\n<td>为得到最快的响应时间，采用的逻辑存储介质是系统内存</td>\n<td>当mysqld守护进程崩溃时，所有的Memory数据都会丢失；不能使用BLOB和TEXT这样的长度可变的数据类型</td>\n<td>临时表</td>\n</tr>\n<tr>\n<td><strong>MERGE</strong></td>\n<td>是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表</td>\n<td></td>\n<td>常应用于日志和数据仓库</td>\n</tr>\n<tr>\n<td><strong>ARCHIVE</strong></td>\n<td>归档的意思，支持<strong>索引</strong>，拥有很好的压缩机制</td>\n<td>仅支持插入和查询功能</td>\n<td>经常被用来当做仓库使用</td>\n</tr>\n</tbody></table>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><h2 id=\"什么是索引\"><a href=\"#什么是索引\" class=\"headerlink\" title=\"什么是索引\"></a>什么是索引</h2><p>索引是对<a href=\"https://coding.imooc.com/?c=data\">数据库</a>表中一个或多个列（例如，employee 表的姓名 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</p>\n<p>例如这样一个查询：select * from table1 where id=10000。如果没有索引，必须遍历整个表，直到ID等于10000的这一行被找到为止；有了索引之后(必须是在ID这一列上建立的索引)，即可在索引中查找。由于索引是经过某种算法优化过的，因而查找次数要少的多。可见，索引是用来定位的。</p>\n<h2 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a><strong>分类：</strong></h2><p><strong>唯一索引</strong></p>\n<p>唯一索引是不允许其中任何两行具有相同索引值的索引。<br>当现有数据中存在重复的键值时，大多数<a href=\"https://coding.imooc.com/?c=data\">数据库</a>不允许将新创建的唯一索引与表一起保存。<a href=\"https://coding.imooc.com/?c=data\">数据库</a>还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p>\n<p><strong>主键索引</strong></p>\n<p><a href=\"https://coding.imooc.com/?c=data\">数据库</a>表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。<br>在<a href=\"https://coding.imooc.com/?c=data\">数据库</a>关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>\n<p><strong>聚集索引</strong></p>\n<p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。<br>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>\n<p>具体参考：</p>\n<p><a href=\"https://www.imooc.com/article/11725\"><strong>【程序员必读系列】-数据库索引的原理</strong></a></p>\n<h1 id=\"分布式、微服务和集群的初步了解\"><a href=\"#分布式、微服务和集群的初步了解\" class=\"headerlink\" title=\"分布式、微服务和集群的初步了解\"></a>分布式、微服务和集群的初步了解</h1><p><strong>微服务</strong></p>\n<p>简单来说微服务就是很小的服务，<strong>小到一个服务只对应一个单一的功能，只做一件事</strong>。这个服务可以单独部署运行，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</p>\n<p><strong>微服务架构</strong></p>\n<p>在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。</p>\n<p><strong>分布式</strong></p>\n<p>分布式服务顾名思义服务是<strong>分散部署在不同的机器上</strong>，一个服务可能负责几个功能，是一种面向SOA架构的，服务之间也是通过rpc来交互或者是webservice来交互的。</p>\n<p>逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署，生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。<br>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难.</p>\n<p>具体参考：</p>\n<p><a href=\"https://www.cnblogs.com/yaoyao-sun/p/10422019.html\">分布式、微服务和集群的初步了解</a></p>\n<h1 id=\"Java类加载器与双亲委派模式的详解\"><a href=\"#Java类加载器与双亲委派模式的详解\" class=\"headerlink\" title=\"Java类加载器与双亲委派模式的详解\"></a>Java类加载器与双亲委派模式的详解</h1><p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_38055381/article/details/81382115\">Java类加载器与双亲委派模式的详解</a></p>\n<h1 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h1><p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p>\n<h1 id=\"B树，B-树的原理及区别\"><a href=\"#B树，B-树的原理及区别\" class=\"headerlink\" title=\"B树，B+树的原理及区别\"></a>B树，B+树的原理及区别</h1><h2 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B-树\"></a>B-树</h2><p><img src=\"/images/pasted-210408Btree.jpg\"></p>\n<h2 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+树\"></a>B+树</h2><pre><code>  1.其定义基本与B-树同，除了：\n</code></pre>\n<p>​      2.非叶子结点的子树指针与关键字个数相同；</p>\n<p>​      3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</p>\n<p>​      4.为所有叶子结点增加一个链指针；</p>\n<p>​      5.所有关键字都在叶子结点出现；</p>\n<p><img src=\"/images/pasted-210408B+tree.jpg\"></p>\n<p> B+的特性：</p>\n<p>​      1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>\n<p>​      2.不可能在非叶子结点命中；</p>\n<p>​      3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>\n<p>​      4.更适合文件索引系统；</p>\n<h2 id=\"为什么B-树比B树更适合数据库索引？\"><a href=\"#为什么B-树比B树更适合数据库索引？\" class=\"headerlink\" title=\"为什么B+树比B树更适合数据库索引？\"></a>为什么B+树比B树更适合数据库索引？</h2><p>1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>\n<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>\n<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>\n<p>4、B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p>\n<p>具体参考：<a href=\"https://blog.csdn.net/wuzzi/article/details/90208999\">为什么说B+树比B树更适合数据库索引？</a></p>\n<h1 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h1><h2 id=\"红黑树规则\"><a href=\"#红黑树规则\" class=\"headerlink\" title=\"红黑树规则\"></a>红黑树规则</h2><p>红黑树有必须要遵守的规则，称为红-黑规则：</p>\n<p>每个节点不是红色就是黑色的；<br>根节点总是黑色的；<br>红色节点的子节点必须是黑色的（反之不一定）。也就是从每个叶子到根的路径上不能有两个连续的红色节点；<br>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</p>\n<h2 id=\"红黑树性能分析\"><a href=\"#红黑树性能分析\" class=\"headerlink\" title=\"红黑树性能分析\"></a>红黑树性能分析</h2><p>红黑树的查找、插入和删除时间复杂度都为O(logN)，额外的开销是每个节点的存储空间都稍微增加了一点，因为一个存储红黑树节点的颜色变量。插入和删除的时间要增加一个常数因子，因为要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是 O(logN)，(时间复杂度的计算要省略常数)，但实际上红黑树的插入和删除比普通的二叉树是要慢的。</p>\n<p>红黑树适用于查找的次数比插入和删除的次数大很多的情况，红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。</p>\n<p>具体参考：<br>原文链接：<a href=\"https://blog.csdn.net/Mr_Wanderer/article/details/113872720\">https://blog.csdn.net/Mr_Wanderer/article/details/113872720</a></p>\n<h1 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h1><p>二叉搜索树作为一种数据结构，其查找、插入和删除操作的时间复杂度都为O(logn)，底数为2。</p>\n<p>但是我们说这个时间复杂度是在平衡的二叉搜索树上体现的，也就是如果插入的数据是随机的，则效率很高，但是如果插入的数据是有序的，比如从小到大的顺序【10,20,30,40,50】插入到二叉搜索树中：从大到小就是全部在左边，这和链表没有任何区别了，这种情况下查找的时间复杂度为O(N)，而不是O(logN)。当然这是在最不平衡的条件下，实际情况下，<strong>二叉搜索树的效率应该在O(N)和O(logN)之间，这取决于树的不平衡程度</strong>。</p>\n<h1 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h1><p>查找、插入和删除在平均和最坏情况下都是O（log n）。</p>\n<p> 高度为 h 的 AVL 树，节点数 N 最多2^h − 1；</p>\n<h1 id=\"浅拷贝和深拷贝\"><a href=\"#浅拷贝和深拷贝\" class=\"headerlink\" title=\"浅拷贝和深拷贝\"></a>浅拷贝和深拷贝</h1><h2 id=\"浅拷贝（Shallow-Copy）：\"><a href=\"#浅拷贝（Shallow-Copy）：\" class=\"headerlink\" title=\"浅拷贝（Shallow Copy）：\"></a><strong>浅拷贝</strong>（Shallow Copy）：</h2><p>①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1218256/201710/1218256-20171011182513121-1029542999.png\" alt=\"img\"></p>\n<p>浅拷贝的实现方式主要有三种：</p>\n<p>一、通过拷贝构造方法实现浅拷贝：</p>\n<p>拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。</p>\n<p>二、通过重写clone()方法进行浅拷贝：</p>\n<p>Object类是类结构的根类，其中有一个方法为protected Object <strong>clone</strong>() throws <a href=\"http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/CloneNotSupportedException.html\">CloneNotSupportedException</a>，这个方法就是进行的浅拷贝。有了这个浅拷贝模板，我们可以通过调用clone()方法来实现对象的浅拷贝。但是需要注意：1、Object类虽然有这个方法，但是这个方法是受保护的（被protected修饰），所以我们无法直接使用。2、使用clone方法的类必须实现Cloneable接口，否则会抛出异常CloneNotSupportedException。对于这两点，我们的解决方法是，在要使用clone方法的类中重写clone()方法，通过super.clone()调用Object类中的原clone方法。</p>\n<p>基本数据类型是值传递，所以修改值后不会影响另一个对象的该属性值；</p>\n<p>引用数据类型是地址传递（引用传递），所以修改值后另一个对象的该属性值会同步被修改。</p>\n<h2 id=\"深拷贝：\"><a href=\"#深拷贝：\" class=\"headerlink\" title=\"深拷贝：\"></a>深拷贝：</h2><p>首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象图进行拷贝！</p>\n<p>简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。</p>\n<p>深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1218256/201710/1218256-20171011190501371-68869476.png\" alt=\"img\"></p>\n<p>因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。</p>\n<p>深拷贝的实现方法主要有两种：</p>\n<p>一、通过重写clone方法来实现深拷贝</p>\n<p>与通过重写clone方法实现浅拷贝的基本思路一样，只需要为对象图的每一层的每一个对象都实现Cloneable接口并重写clone方法，最后在最顶层的类的重写的clone方法中调用所有的clone方法即可实现深拷贝。简单的说就是：每一层的每个对象都进行浅拷贝=深拷贝。</p>\n<p>分析结果可以验证：进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。</p>\n<p>二、通过对象序列化实现深拷贝</p>\n<p>虽然层次调用clone方法可以实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写clone方法太过繁琐。</p>\n<p>将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。</p>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><p>JVM在进行GC时，并不是对这三个区域统一回收。 大部分时候，回收都是新生代~<br>●新生代<br><strong>●幸存区(form，to)</strong><br>●老年区<br>GC两种类:轻GC (普通的GC)， 重GC (全局GC)<br>GC常见面试题目:<br>●JVM的内存模型和分区~详细到每个区放什么?<br><img src=\"https://img-blog.csdnimg.cn/20200715153153103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p> 图 JVM内存模型和分区</p>\n<p>●堆里面的分区有哪些?<br>Eden, form, to, 老年区,说说他们的特点!<br>●GC的算法有哪些?<br>标记清除法，标记整理,复制算法，引用计数器<br>●轻GC和重GC分别在什么时候发生?</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_42671148/article/details/108274558\">JVM-狂神学习笔记</a></p>\n<h1 id=\"线程池的作用\"><a href=\"#线程池的作用\" class=\"headerlink\" title=\"线程池的作用\"></a>线程池的作用</h1><p>在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程<br>　　<strong>第一</strong>：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>　　<strong>第二</strong>：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>　　<strong>第三</strong>：提高线程的可管理性。<br>常用线程池：ExecutorService 是主要的实现类，其中常用的有 :<br>Executors.newSingleThreadPool()</p>\n<p>  　　newFixedThreadPool()</p>\n<p>  　　newcachedTheadPool()</p>\n<p>  　 newScheduledThreadPool()</p>\n<p>具体参考：</p>\n<p><a href=\"https://www.cnblogs.com/zeze/p/6548649.html\">线程池的作用</a></p>\n<p><a href=\"https://www.cnblogs.com/superfj/p/7544971.html\">由浅入深理解Java线程池及线程池的如何使用</a></p>\n<h1 id=\"局部性\"><a href=\"#局部性\" class=\"headerlink\" title=\"局部性\"></a>局部性</h1><p>局部性通常分为：<strong>时间局部性</strong>和<strong>空间局部性</strong>。</p>\n<p>1）时间局部性<br>时间局部性是指被引用过一次的内存位置很可能在不远的将来再被多次引用。</p>\n<p>2）空间局部性<br>空间局部性是指如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用其附近的一个内存位置。</p>\n<p>3）局部性原理举例</p>\n<ul>\n<li>在硬件层，局部性原理允许计算机设计者通过引入小而快的高速缓存存储器来保存最近被引用的指令和数据项，从而提高对主存的访问速度。</li>\n<li>在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。</li>\n<li>类似的，操作系统用主存来缓存磁盘文件系统中最近被使用的磁盘块。</li>\n<li>在应用程序的设计，如Web浏览器将最近被请求的文档放在本地磁盘上，利用的就是时间局部性。大容量的Web服务器将最近被请求的文档放在前端磁盘高速缓存中，不需要服务器的干预就可满足对这些文档的请求。</li>\n</ul>\n<h1 id=\"Linux-文件与目录管理\"><a href=\"#Linux-文件与目录管理\" class=\"headerlink\" title=\"Linux 文件与目录管理\"></a>Linux 文件与目录管理</h1><h2 id=\"处理目录的常用命令\"><a href=\"#处理目录的常用命令\" class=\"headerlink\" title=\"处理目录的常用命令\"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p>\n<ul>\n<li>ls（英文全拼：list files）: 列出目录及文件名</li>\n<li>cd（英文全拼：change directory）：切换目录</li>\n<li>pwd（英文全拼：print work directory）：显示目前的目录</li>\n<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>\n<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>\n<li>cp（英文全拼：copy file）: 复制文件或目录</li>\n<li>rm（英文全拼：remove）: 删除文件或目录</li>\n<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>\n</ul>\n<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>\n<h2 id=\"Linux-文件内容查看\"><a href=\"#Linux-文件内容查看\" class=\"headerlink\" title=\"Linux 文件内容查看\"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>\n<ul>\n<li>cat 由第一行开始显示文件内容</li>\n<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>\n<li>nl  显示的时候，顺道输出行号！</li>\n<li>more 一页一页的显示文件内容</li>\n<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>\n<li>head 只看头几行</li>\n<li>tail 只看尾巴几行</li>\n</ul>\n<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>\n<h1 id=\"Linux下的编译和执行\"><a href=\"#Linux下的编译和执行\" class=\"headerlink\" title=\"Linux下的编译和执行\"></a>Linux下的编译和执行</h1><p>具体参考：</p>\n<p> <a href=\"https://blog.csdn.net/u013793399/article/details/51365311\">在Linux系统下编译并执行C++程序</a></p>\n<h1 id=\"Spring相关面试题\"><a href=\"#Spring相关面试题\" class=\"headerlink\" title=\"Spring相关面试题\"></a>Spring相关面试题</h1><p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_41701956/article/details/81389067\">近5年来的 Spring 相关面试题整理</a></p>\n<h1 id=\"JVM垃圾回收机制\"><a href=\"#JVM垃圾回收机制\" class=\"headerlink\" title=\"JVM垃圾回收机制\"></a>JVM垃圾回收机制</h1><p>具体参考：</p>\n<p><a href=\"%5Bhttps://jpeony.blog.csdn.net/article/details/80950336?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control%5D(https://jpeony.blog.csdn.net/article/details/80950336?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control)\">【JVM】垃圾回收机制(1)–如何判定对象可以回收</a></p>\n<h1 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h1><p>SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。</p>\n<h2 id=\"SQL注入攻击的总体思路\"><a href=\"#SQL注入攻击的总体思路\" class=\"headerlink\" title=\"SQL注入攻击的总体思路\"></a>SQL注入攻击的总体思路</h2><p>　　1：寻找到SQL注入的位置</p>\n<p>　　2：判断服务器类型和后台数据库类型</p>\n<p>　　3：针对不同的服务器和数据库特点进行SQL注入攻击</p>\n<h1 id=\"各网络层的协议\"><a href=\"#各网络层的协议\" class=\"headerlink\" title=\"各网络层的协议\"></a>各网络层的协议</h1><p>TCP/IP体系结构</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200823014026904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI4MjA2Mw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"img\"></p>\n<p>TCP/IP协议各层功能</p>\n<p>各层所包含的协议</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200823014123331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI4MjA2Mw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>协议栈<br>各层的所有协议被称为协 议栈(protocol stack).因特网的协议栈由5个层次组成：物理层，数据链路层，网络层，运输层，应用层。</p>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><p>(1)应用层(application layer) 应用层是体系结构中的最高层。应用层直接为用户的应用进程提供服务。这里的进程就是指正在运行的程序。在因特网中的应用层协议很多， 如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等等。<br>应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中 的应用程序交换信息分组。我们将这种位于应用层的信息分组称为报文（message）。</p>\n<h2 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h2><p>迈输层提供了在应用程序端点之间传送应用层报文的服务。<br>(2)运输层(transport layer) 运输层的任务就是负责向两个主机中进程之间的通信提 供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多 个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付给上面 应用层中的相应的进程。运输层分组称为报文段。<br>运输层主要使用以下两种协议：<br>① 传输控制协议TCP (Transmission Control Protocol) 面向连接的，数据传输的单位<br>是报文段(segment),能够提供可靠的交付。<br>② 用户数据报协议UDP (User Datagram Protocol) 无连接的，数据传输的单位是用<br>户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付(best-effortdelivery)”<br>TCP与UDP区别<br>协议，即TCP和UDP,利用其中的任何一个都能传输应用层报文。TCP向它的应用程序提供了 面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流童控制(即发送方/接 收方速率匹配)。TCP也将长报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时， 源抑制其传输速率。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务 的服务，不提供可靠性，没有流量控制，也没有拥塞控制。</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><p>(3)因特网的网络层负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主 机。源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址， 就像你向邮政信件提供目的地址一样。在 TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报，或简称为数据报。<br>因特网的网络层包括著名的IP协议，该协议定义了数据报中的各个字段以及端系统和路 由器如何作用于这些字段。仅有一个IP协议，所有具有网络层的因特网组件都必须运行IP协议。</p>\n<h2 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h2><p>(4)数据链路层(data link layer) 常简称为链路层。我们知道，两个主机之间的数据 传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间(主机和路由器之 间或两个路由器之间)传送数据是直接传送的(点对点)。这时就需要使用专门的链路层的 协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧 (framing),在两个相邻结点间的链路上“透明”地传送帧(frame)中的数据。每一帧包括数据 和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</p>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><p>链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将 该帧中的一个一个比特从一个节点移动到下一个节点。该层中的协议仍然是链路相关的，并 且进一步与链路（例如，双绞铜线、单模光纤）的实际传输媒体相关。例如，以太网具有许 多物理层协议：关于双绞铜线的，关于同轴电缆的，关于光纤的，等等。在每种情况下，跨 越这些链路移动一个比特的方式不同。</p>\n<h1 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h1><p>一篇比较好的并查集：<a href=\"https://blog.csdn.net/qq_42011541/article/details/83378709\">https://blog.csdn.net/qq_42011541/article/details/83378709</a></p>\n<p>N个人要坐在桌子上吃饭，但是人们拒绝和陌生人坐在一张桌子上。什么样的不算陌生人呢？主要是朋友的朋友的朋友的…..只要能扯上关系就不算陌生人。能扯上关系就可以坐在一张桌子上。所以至少要准备多少张桌子？</p>\n<p>思路：其实就是对并查集进行合并操作，只要俩人认识，就组队。把队组好以后，看最后有多少个组(集合)就行了。最初每个人都自成一组，所以有多少人就有多少组。但是随着他们组队，每两个组合并成一个组，总的组数就会少1。如果组队的时候发现，他俩已经早就‘扯上关系了’，也就表名他俩早就是一组了，那就不用继续合并了，也就不用再 -1 了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnionFind</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] parent;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] weight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;<span class=\"comment\">//代表并查集中元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> groups;<span class=\"comment\">//代表并查集中有多少个集合（小组）</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UnionFind</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.weight = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.groups = size;<span class=\"comment\">//因为初始的时候每个人自成一组，所以有多少人就有多少组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.parent[i] = i;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.weight[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> element)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (element != parent[element]) &#123;</span><br><span class=\"line\">            parent[element] = parent[parent[element]];</span><br><span class=\"line\">            element = parent[element];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isConnected</span><span class=\"params\">(<span class=\"keyword\">int</span> firstElement, <span class=\"keyword\">int</span> secondElement)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(firstElement) == find(secondElement);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unionElements</span><span class=\"params\">(<span class=\"keyword\">int</span> firstElement, <span class=\"keyword\">int</span> secondElement)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> firstRoot = find(firstElement);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> secondRoot = find(secondElement);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//如果已经属于同一个集合了，就不用再合并了。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (firstRoot == secondRoot) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (weight[firstRoot] &gt; weight[secondRoot]) &#123;</span><br><span class=\"line\">            parent[secondRoot] = firstRoot;</span><br><span class=\"line\">            weight[firstRoot] += weight[secondRoot];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//weight[firstRoot] &lt;= weight[secondRoot]</span></span><br><span class=\"line\">            parent[firstRoot] = secondRoot;</span><br><span class=\"line\">            weight[secondRoot] += weight[firstRoot];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//合并 firstElement 和 secondElement 所在的两个组后，就少了一组。</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.groups--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getGroups</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.groups;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        java.util.Scanner scanner = <span class=\"keyword\">new</span> java.util.Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> times = scanner.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; times; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = scanner.nextInt();</span><br><span class=\"line\">            UnionFind union = <span class=\"keyword\">new</span> UnionFind(size);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> input = scanner.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; input; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//因为测试数据是从1开始，而我们的并查集是从数组的第0位开始</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> first = scanner.nextInt() - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> second = scanner.nextInt() - <span class=\"number\">1</span>;</span><br><span class=\"line\">                union.unionElements(first, second);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(union.getGroups());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;　</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"transient关键字\"><a href=\"#transient关键字\" class=\"headerlink\" title=\"transient关键字\"></a>transient关键字</h1><p>transient关键字的作用是：被transient修饰的变量不参与序列化和反序列化。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。</p>\n<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><p>简要解释：<br>　　序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>　　序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，<br>然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>\n<p>具体参考：</p>\n<p><a href=\"https://www.cnblogs.com/yangchunze/p/6728086.html\">什么是Java序列化，如何实现java序列化</a></p>\n<h1 id=\"线程的优先级\"><a href=\"#线程的优先级\" class=\"headerlink\" title=\"线程的优先级\"></a>线程的优先级</h1><p>Java线程可以有优先级的设定，高优先级的线程比低优先级的线程有更高的几率得到执行（不完全正确，请参考下面的“线程优先级的问题“）。</p>\n<ol>\n<li>记住当线程的优先级没有指定时，所有线程都携带普通优先级。</li>\n<li>优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。</li>\n<li>记住优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态。</li>\n<li>与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。</li>\n<li>由调度程序决定哪一个线程被执行。</li>\n<li>t.setPriority()用来设定线程的优先级。</li>\n<li>记住在线程开始方法被调用之前，线程的优先级应该被设定。</li>\n<li>你可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级。</li>\n</ol>\n<h1 id=\"Java线程和操作系统线程的关系\"><a href=\"#Java线程和操作系统线程的关系\" class=\"headerlink\" title=\"Java线程和操作系统线程的关系\"></a>Java线程和操作系统线程的关系</h1><p>Java中的线程：</p>\n<p><strong>特别注意：这些线程的状态时JVM中的线程状态！不是操作系统中的线程状态。</strong></p>\n<p><img src=\"https://img-blog.csdn.net/20180418174102632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ3JpbmdLb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/CringKong/article/details/79994511\">Java线程和操作系统线程的关系</a></p>\n<h1 id=\"从输入URL到页面展示的详细过程\"><a href=\"#从输入URL到页面展示的详细过程\" class=\"headerlink\" title=\"从输入URL到页面展示的详细过程\"></a>从输入URL到页面展示的详细过程</h1><p>大致过程：</p>\n<ul>\n<li>1、输入网址</li>\n<li>2、DNS解析</li>\n<li>3、建立tcp连接</li>\n<li>4、客户端发送HTPP请求</li>\n<li>5、服务器处理请求</li>\n<li>6、服务器响应请求</li>\n<li>7、浏览器展示HTML</li>\n<li>8、浏览器发送请求获取其他在HTML中的资源。</li>\n</ul>\n<h2 id=\"1、输入地址\"><a href=\"#1、输入地址\" class=\"headerlink\" title=\"1、输入地址\"></a>1、输入地址</h2><p>  当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>\n<h2 id=\"2、浏览器查找域名的-IP-地址\"><a href=\"#2、浏览器查找域名的-IP-地址\" class=\"headerlink\" title=\"2、浏览器查找域名的 IP 地址\"></a>2、浏览器查找域名的 IP 地址</h2><p>　　1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>\n<p>   2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p>\n<p>　  3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</p>\n<p>　　4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。</p>\n<p>　　5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p>\n<p>　　6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>\n<h2 id=\"3、浏览器向-web-服务器发送一个-HTTP-请求\"><a href=\"#3、浏览器向-web-服务器发送一个-HTTP-请求\" class=\"headerlink\" title=\"3、浏览器向 web 服务器发送一个 HTTP 请求\"></a>3、浏览器向 web 服务器发送一个 HTTP 请求</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>\n<p>建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。</p>\n<p>　　客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>\n<p>　　| 请求方法URI协议/版本</p>\n<p>​        | 请求头(Request Header)</p>\n<p>　　| 请求正文：</p>\n<h2 id=\"4、服务器的永久重定向响应\"><a href=\"#4、服务器的永久重定向响应\" class=\"headerlink\" title=\"4、服务器的永久重定向响应\"></a>4、服务器的永久重定向响应</h2><p>​        服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“<a href=\"http://www.google.com/%E2%80%9D\">http://www.google.com/”</a> 而非“<a href=\"http://google.com/%E2%80%9D%E3%80%82\">http://google.com/”。</a></p>\n<p>　　为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<a href=\"http://www.yy.com/%E5%92%8Chttp://yy.com/%EF%BC%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%9A%E8%AE%A4%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E7%BB%93%E6%9E%9C%E9%80%A0%E6%88%90%E6%AF%8F%E4%B8%AA%E6%90%9C%E7%B4%A2%E9%93%BE%E6%8E%A5%E9%83%BD%E5%87%8F%E5%B0%91%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E6%8E%92%E5%90%8D%E3%80%82%E8%80%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9F%A5%E9%81%93301%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%BC%9A%E6%8A%8A%E8%AE%BF%E9%97%AE%E5%B8%A6www%E7%9A%84%E5%92%8C%E4%B8%8D%E5%B8%A6www%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%92%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E6%8E%92%E5%90%8D%E4%B8%8B%E3%80%82%E8%BF%98%E6%9C%89%E5%B0%B1%E6%98%AF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E9%80%A0%E6%88%90%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E6%80%A7%E5%8F%98%E5%B7%AE%EF%BC%8C%E5%BD%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%90%8D%E5%AD%97%E6%97%B6%EF%BC%8C%E5%AE%83%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%9C%A8%E7%BC%93%E5%AD%98%E9%87%8C%E5%87%BA%E7%8E%B0%E5%A5%BD%E5%87%A0%E6%AC%A1%E3%80%82\">http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。</a></p>\n<h2 id=\"5、浏览器跟踪重定向地址\"><a href=\"#5、浏览器跟踪重定向地址\" class=\"headerlink\" title=\"5、浏览器跟踪重定向地址\"></a>5、浏览器跟踪重定向地址</h2><p>  现在浏览器知道了 “<a href=\"http://www.google.com/&quot;%E6%89%8D%E6%98%AF%E8%A6%81%E8%AE%BF%E9%97%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%83%E4%BC%9A%E5%8F%91%E9%80%81%E5%8F%A6%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82%E3%80%82%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89%E5%95%A5%E5%A5%BD%E8%AF%B4%E7%9A%84\">http://www.google.com/&quot;才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的</a></p>\n<h2 id=\"6、服务器处理请求\"><a href=\"#6、服务器处理请求\" class=\"headerlink\" title=\"6、服务器处理请求\"></a>6、服务器处理请求</h2><p>　　经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？</p>\n<p>　　后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p>\n<p>　　一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>\n<h2 id=\"7、服务器返回一个-HTTP-响应\"><a href=\"#7、服务器返回一个-HTTP-响应\" class=\"headerlink\" title=\"7、服务器返回一个 HTTP 响应\"></a>7、服务器返回一个 HTTP 响应</h2><p>　　经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。</p>\n<p>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>\n<p>l 状态行</p>\n<p>l 响应头(Response Header)</p>\n<p>l 响应正文</p>\n<h2 id=\"8、浏览器显示-HTML\"><a href=\"#8、浏览器显示-HTML\" class=\"headerlink\" title=\"8、浏览器显示 HTML\"></a>8、浏览器显示 HTML</h2><p>　　在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：(暂略)</p>\n<h2 id=\"9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）\"><a href=\"#9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）\" class=\"headerlink\" title=\"9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）\"></a>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</h2><p>​        其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：</p>\n<p>图片：<a href=\"http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif\">http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif</a></p>\n<p>CSS式样表：<a href=\"http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css\">http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css</a></p>\n<p>JavaScript 文件：<a href=\"http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js\">http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js</a></p>\n<p>　　这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p>\n<p>不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中</p>\n<h1 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h1><h2 id=\"1-什么是DNS？\"><a href=\"#1-什么是DNS？\" class=\"headerlink\" title=\"1)什么是DNS？\"></a>1)什么是DNS？</h2><p>　　DNS（Domain Name System，域名系统），因特网上作为域名和<a href=\"http://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80\">IP地址</a>相互映射的一个<a href=\"http://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93\">分布式数据库</a>，能够使用户更方便的访问<a href=\"http://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91\">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a href=\"http://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA\">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>\n<p>　　通俗的讲，我们更习惯于记住一个网站的名字，比如<a href=\"http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。\">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</a></p>\n<h2 id=\"2-DNS查询的两种方式：递归查询和迭代查询\"><a href=\"#2-DNS查询的两种方式：递归查询和迭代查询\" class=\"headerlink\" title=\"2)DNS查询的两种方式：递归查询和迭代查询\"></a>2)DNS查询的两种方式：递归查询和迭代查询</h2><p>1、递归解析</p>\n<p>  当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图\\所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p>\n<p>2、迭代解析</p>\n<p>　　当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p>\n<h2 id=\"4-DNS负载均衡\"><a href=\"#4-DNS负载均衡\" class=\"headerlink\" title=\"4)DNS负载均衡\"></a>4)DNS负载均衡</h2><p>　　当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>\n<h1 id=\"重定向原因\"><a href=\"#重定向原因\" class=\"headerlink\" title=\"重定向原因\"></a>重定向原因</h1><p>（1）网站调整（如改变网页目录结构）；</p>\n<p>（2）网页被移到一个新地址；</p>\n<p>（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</p>\n<p>​    这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>\n<h1 id=\"状态码301和302\"><a href=\"#状态码301和302\" class=\"headerlink\" title=\"状态码301和302\"></a>状态码301和302</h1><h2 id=\"1）301和302的区别。\"><a href=\"#1）301和302的区别。\" class=\"headerlink\" title=\"1）301和302的区别。\"></a>1）301和302的区别。</h2><p>　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。</p>\n<p>　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</p>\n<p>　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 所以302好于301。</p>\n<h2 id=\"2）什么时候进行301或者302跳转呢？\"><a href=\"#2）什么时候进行301或者302跳转呢？\" class=\"headerlink\" title=\"2）什么时候进行301或者302跳转呢？\"></a>2）什么时候进行301或者302跳转呢？</h2><p>​    当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。</p>\n<p>清晰明确而言：使用301跳转的大概场景如下：</p>\n<p>1、域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</p>\n<p>2、在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</p>\n<p>3、空间服务器不稳定，换空间的时候。</p>\n<h1 id=\"如何判断一个对象是否应该被回收\"><a href=\"#如何判断一个对象是否应该被回收\" class=\"headerlink\" title=\"如何判断一个对象是否应该被回收\"></a>如何判断一个对象是否应该被回收</h1><p>这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析。由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法。</p>\n<h3 id=\"1、引用计数法\"><a href=\"#1、引用计数法\" class=\"headerlink\" title=\"1、引用计数法\"></a>1、引用计数法</h3><p>引用计数法的逻辑非常简单，但是存在问题，java并不采用这种方式进行对象存活判断。</p>\n<p>引用计数法的逻辑是：在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。</p>\n<p>这种方法来标记对象的状态会存在很多问题：</p>\n<p>jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。 </p>\n<h3 id=\"2、可达性分析算法\"><a href=\"#2、可达性分析算法\" class=\"headerlink\" title=\"2、可达性分析算法\"></a>2、可达性分析算法</h3><p>在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。<br><img src=\"https://img-blog.csdnimg.cn/20190529111953162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTk2NzYx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_42996761/article/details/90667725\">如何判断一个对象是否应该被回收</a></p>\n<h1 id=\"Java内存泄露和内存溢出的区别和联系\"><a href=\"#Java内存泄露和内存溢出的区别和联系\" class=\"headerlink\" title=\"Java内存泄露和内存溢出的区别和联系\"></a>Java内存泄露和内存溢出的区别和联系</h1><h2 id=\"1、内存泄漏memory-leak\"><a href=\"#1、内存泄漏memory-leak\" class=\"headerlink\" title=\"1、内存泄漏memory leak :\"></a>1、内存泄漏memory leak :</h2><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>\n<h2 id=\"2、内存溢出-out-of-memory\"><a href=\"#2、内存溢出-out-of-memory\" class=\"headerlink\" title=\"2、内存溢出 out of memory :\"></a>2、内存溢出 out of memory :</h2><p>指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p>\n<h2 id=\"3、二者的关系：\"><a href=\"#3、二者的关系：\" class=\"headerlink\" title=\"3、二者的关系：\"></a>3、二者的关系：</h2><ol>\n<li>内存泄漏的堆积最终会导致内存溢出</li>\n<li>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</li>\n<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</li>\n<li>内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。</li>\n</ol>\n<h2 id=\"内存泄露的场景\"><a href=\"#内存泄露的场景\" class=\"headerlink\" title=\"内存泄露的场景\"></a>内存泄露的场景</h2><ol>\n<li>静态集合类引起内存泄漏：静态成员的生命周期是整个程序运行期间。</li>\n<li>调用 remove()方法时不起作用</li>\n<li>各种连接对象( IO 流对象、数据库连接对象、网络连接对象)使用后未关闭：因为每个流 在操作系统层面都对应了打开的文件句柄，流没有关闭，会导致操作系统的文件句柄一 直处于打开状态，而jvm会消耗内存来跟踪操作系统打开的文件句柄。</li>\n<li>监听器的使用：在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li>\n<li>不正确使用单例模式是引起内存泄漏：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</li>\n</ol>\n<h2 id=\"内存泄漏解决措施\"><a href=\"#内存泄漏解决措施\" class=\"headerlink\" title=\"内存泄漏解决措施\"></a>内存泄漏解决措施</h2><ol>\n<li><p>尽量减少使用静态变量，类的静态变量的生命周期和类同步的。</p>\n</li>\n<li><p>声明对象引用之前，明确内存对象的有效作用域，尽量减小对象的作用域，将类的成员 变量改写为方法内的局部变量；</p>\n</li>\n<li><p>减少长生命周期的对象持有短生命周期的引用；</p>\n</li>\n<li><p>使用 StringBuilder 和 StringBuffer 进行字符串连接，Sting 和 StringBuilder 以及 StringBuffer 等都可以代表字符串，其中 String 字符串代表的是不可变的字符串，后两者表示 可变的字符串。如果使用多个 String 对象进行字符串连接运算，在运行时可能产生大量临时字符串，这些字符串会保存在内存中从而导致程序性能下降。</p>\n</li>\n<li><p>对于不需要使用的对象手动设置 null 值，不管 GC 何时会开始清理，我们都应及时的将无用的对象标记为可被清理的对象；</p>\n</li>\n<li><p>各种连接（数据库连接，网络连接，IO 连接）操作，务必显示调用 close 关闭。</p>\n</li>\n</ol>\n<h2 id=\"内存溢出的场景\"><a href=\"#内存溢出的场景\" class=\"headerlink\" title=\"内存溢出的场景\"></a>内存溢出的场景</h2><h3 id=\"JVM-Heap（堆）溢出：\"><a href=\"#JVM-Heap（堆）溢出：\" class=\"headerlink\" title=\"JVM Heap（堆）溢出：\"></a><strong>JVM Heap（堆）溢出</strong>：</h3><p> 发生这种问题的原因是 java 虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已 经用满了。</p>\n<p>解决方法：</p>\n<ol>\n<li>手动设置 JVM Heap（堆）的大小。</li>\n<li>检查程序，看是否有死循环或不必要地重复创建大量对象。</li>\n</ol>\n<h2 id=\"Metaspace溢出\"><a href=\"#Metaspace溢出\" class=\"headerlink\" title=\"Metaspace溢出\"></a><strong>Metaspace溢出</strong></h2><p>Metaspace 程序中使用了大量的 jar 或 class，使 java 虚拟机装载类的空间不够，与 metaspace 大小有关。方法区用于存放 Java 类型的相关信息。在类装载器加载 class 文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的 内存占用又已经达到 -XX:MaxMetaspaceSize 设置的最大值，将会抛出 OutOfMemoryError 异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</p>\n<p>解决方法:</p>\n<ol>\n<li>通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。</li>\n</ol>\n<h2 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a><strong>栈溢出</strong></h2><p>java.lang.StackOverflowError : Thread Stack space：线程的方法嵌套调用层次太多(如递归调用)，以致于把栈区溢出了。</p>\n<p>解决方法：</p>\n<ol>\n<li>修改程序。</li>\n<li>通过 -Xss: 来设置每个线程的 Stack 大小即可。</li>\n</ol>\n<p>具体参考：</p>\n<p><a href=\"https://my.oschina.net/sunmin/blog/3034336\">JAVA内存泄漏和内存溢出的区别和联系</a></p>\n<h1 id=\"散列函数和Hash冲突\"><a href=\"#散列函数和Hash冲突\" class=\"headerlink\" title=\"散列函数和Hash冲突\"></a>散列函数和Hash冲突</h1><h2 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h2><ol>\n<li>直接定值法：例如线性函数</li>\n<li>数字分析法：根据数字特性来决定</li>\n<li>除留余数法：例如除以某个质数</li>\n<li>平方取中法</li>\n<li>基数转换法</li>\n<li>折叠法</li>\n</ol>\n<h2 id=\"Hash冲突\"><a href=\"#Hash冲突\" class=\"headerlink\" title=\"Hash冲突\"></a>Hash冲突</h2><ol>\n<li><p>开放定址法：</p>\n<ul>\n<li><p>线性探测再散列 di = 1 , 2 , 3 , … , m-1</p>\n</li>\n<li><p>平方探测再散列 di = 1 , -1 , 2, -2 , 3 , -3 , … , k , -k(取相应数的平方)</p>\n</li>\n<li><p>随机探测再散列 di 是一组伪随机数列</p>\n</li>\n</ul>\n</li>\n<li><p>链接法：</p>\n<p>将所有哈希地址相同的记录都链接在同一链表中。</p>\n</li>\n<li><p>再哈希法：</p>\n<p>再次进行另一个哈希函数计算，直到冲突不发生。</p>\n</li>\n<li><p>建立公共溢出区</p>\n<p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>\n</li>\n</ol>\n<h1 id=\"Integer比较大小要注意的地方\"><a href=\"#Integer比较大小要注意的地方\" class=\"headerlink\" title=\"Integer比较大小要注意的地方\"></a>Integer比较大小要注意的地方</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"number\">1</span>;</span><br><span class=\"line\">Integer b = <span class=\"number\">1</span>;</span><br><span class=\"line\">System.out.println(a == b);     <span class=\"comment\">// true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">Integer c = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer d = <span class=\"number\">128</span>;</span><br><span class=\"line\">System.out.println(c == d);    <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>这是因为 Integer 类在内存中有一个值的范围为[-128, 127]的对象池。只要 Integer 对象的值在[-128, 127]范围内，都是从这个对象池中取。所以只要是这个范围的 Integer 对象，只要值相同，就是同一个对象。那么 == 的结果，就是 true。超过了这个范围，则会 new 新的 Integer 对象，尽管值相同，但是已经是不同的对象了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>);</span><br><span class=\"line\">Integer b = <span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>);</span><br><span class=\"line\">System.out.println(a == b);    <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>那么结果就是 false 了，因为他重新生成对象了；</p>\n<p>如果超过了 [-128, 127] 之间的值，被装箱后的 Integer 对象并不会被重用，即相当于每次装箱时都新建一个 Integer 对象，所以 Integer c = 128，Integer d = 128 参考的不同的对象。内存地址不同，结果是 false，对象如果要比较值，应该用 .equals()方法。<br><em>注意</em>：只有 Integer 类有对象池，其他的 Short…Double 都没有对象池</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/fly_sky23/article/details/85162859\">Java中两个Integer比较大小需要注意的误区</a></p>\n<h1 id=\"Mysql实现乐观锁\"><a href=\"#Mysql实现乐观锁\" class=\"headerlink\" title=\"Mysql实现乐观锁\"></a>Mysql实现乐观锁</h1><p>具体参考：</p>\n<p> <a href=\"https://blog.csdn.net/gaopeijiayou/article/details/100152780\">mysql实现乐观锁</a></p>\n<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><h2 id=\"线程池简介\"><a href=\"#线程池简介\" class=\"headerlink\" title=\"线程池简介\"></a>线程池简介</h2><ol>\n<li>线程池的概念：</li>\n</ol>\n<p>​     线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>\n<ol start=\"2\">\n<li>线程池的工作机制</li>\n</ol>\n<p>​     2.1 在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</p>\n<p>​     2.1 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>\n<ol start=\"3\">\n<li>使用线程池的原因：</li>\n</ol>\n<p>​    多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。</p>\n<h2 id=\"四种常见线程池\"><a href=\"#四种常见线程池\" class=\"headerlink\" title=\"四种常见线程池\"></a>四种常见线程池</h2><ol>\n<li>线程池的返回值ExecutorService简介：</li>\n</ol>\n<p>​     ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程</p>\n<ol start=\"2\">\n<li><p>具体的4种常用的线程池实现如下：（返回值都是ExecutorService）</p>\n<p>2.1  Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务</p>\n<p>2.2 Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。</p>\n<p>2.3 Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行</p>\n<p>2.4 Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>\n</li>\n</ol>\n<h2 id=\"三-缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor\"><a href=\"#三-缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor\" class=\"headerlink\" title=\"三. 缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor\"></a>三. 缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor</h2><p>\\1. 缓冲队列BlockingQueue简介：</p>\n<p>​     BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。</p>\n<p>\\2. 常用的几种BlockingQueue：</p>\n<ul>\n<li>ArrayBlockingQueue（int i）:规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。</li>\n<li>LinkedBlockingQueue（）或者（int i）:大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。</li>\n<li>PriorityBlockingQueue（）或者（int i）:类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。</li>\n<li>SynchronizedQueue（）:特殊的BlockingQueue，对其的操作必须是放和取交替完成。</li>\n</ul>\n<p>\\3. 自定义线程池（ThreadPoolExecutor和BlockingQueue连用）：</p>\n<p>   <em>自定义线程池，可以用ThreadPoolExecutor类创建，它有多个构造方法来创建线程池。</em></p>\n<p>  <em>常见的构造函数：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)</em></p>\n<p>具体参考：</p>\n<p><a href=\"https://www.cnblogs.com/jiawen010/p/11855768.html\">4种常用线程池介绍</a></p>\n","tags":["面经"]}]