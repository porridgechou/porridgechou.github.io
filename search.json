[{"title":"兄弟们冲冲冲！","url":"/2021/03/16/first%20blog/","content":"<h1 id=\"欢迎来到我的blog\"><a href=\"#欢迎来到我的blog\" class=\"headerlink\" title=\"欢迎来到我的blog\"></a>欢迎来到我的blog</h1><p>然后懒人表示什么都没有更新！<br>记得别咸鱼！</p>\n"},{"title":"网络编程","url":"/2021/03/18/network-coding/","content":"<h1 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h1><p>ip地址：InetAddress</p>\n<ul>\n<li><p>127.0.0.1 ：本机localhost</p>\n</li>\n<li><p>ip地址的分类</p>\n</li>\n<li><ul>\n<li>ipv4/ipv6</li>\n<li><ul>\n<li>IPV4 4个字节组成</li>\n<li>IPV6 128位，8个无符号整数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li></li>\n</ul>\n"},{"title":"try to upload","url":"/2021/03/17/try-to-upload/","content":"<p><img src=\"/images/pasted-210317pjl.jpg\" alt=\"pjl\"><br><img src=\"/images/pasted-210317whz.jpg\" alt=\"pjl\"></p>\n"},{"title":"HTML学习","url":"/2021/03/18/html-learning/","content":"<h1 id=\"HTML简介\"><a href=\"#HTML简介\" class=\"headerlink\" title=\"HTML简介\"></a>HTML简介</h1><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>html learning<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>标题一<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>段落一<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>!DOCTYPE html 声明为 HTML5 文档</li>\n<li>html 元素是 HTML 页面的根元素</li>\n<li>head元素包含了文档的元（meta）数据，如 meta charset=”utf-8”定义网页编码格式为 <strong>utf-8</strong>。</li>\n</ul>\n<p>只有 body区域 (白色部分) 才会在浏览器中显示。</p>\n<h1 id=\"HTML-基础\"><a href=\"#HTML-基础\" class=\"headerlink\" title=\"HTML 基础\"></a>HTML 基础</h1><p>HTML 标题（Heading）是通过h1-h6标签来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    标题一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>HTML 段落是通过标签 p 来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    段落一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>HTML 链接是通过标签 a来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://&quot;</span>&gt;</span></span><br><span class=\"line\">   链接一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>HTML 图像是通过标签 img 来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">loading</span>=<span class=\"string\">&quot;porrige&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;/images/logo.jpg&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;258&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"HTML元素\"><a href=\"#HTML元素\" class=\"headerlink\" title=\"HTML元素\"></a>HTML元素</h1><p>如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 br标签：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"HTML属性\"><a href=\"#HTML属性\" class=\"headerlink\" title=\"HTML属性\"></a>HTML属性</h1><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>class</td>\n<td>为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td>\n</tr>\n<tr>\n<td>id</td>\n<td>定义元素的唯一id</td>\n</tr>\n<tr>\n<td>style</td>\n<td>规定元素的行内样式（inline style）</td>\n</tr>\n<tr>\n<td>title</td>\n<td>描述了元素的额外信息 (作为工具条使用)</td>\n</tr>\n</tbody></table>\n<h1 id=\"HTML标题\"><a href=\"#HTML标题\" class=\"headerlink\" title=\"HTML标题\"></a>HTML标题</h1><p>标题（Heading）是通过 h1-h6标签进行定义的。</p>\n<p>h1定义最大的标题（主要）。 h6定义最小的标题（次要）。</p>\n<h2 id=\"HTML水平线\"><a href=\"#HTML水平线\" class=\"headerlink\" title=\"HTML水平线\"></a>HTML水平线</h2><p>hr标签在 HTML 页面中创建水平线。</p>\n<p>hr 元素可用于分隔内容。</p>\n<h2 id=\"HTML-注释\"><a href=\"#HTML-注释\" class=\"headerlink\" title=\"HTML 注释\"></a>HTML 注释</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"自己写输入输出问题","url":"/2021/03/20/javacode-io/","content":"<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        String[] params = br.readLine().trim().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = Integer.parseInt(params[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = Integer.parseInt(params[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = Integer.parseInt(params[<span class=\"number\">2</span>]);</span><br><span class=\"line\">        String[] strArr = br.readLine().trim().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] scores = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) scores[i] = Integer.parseInt(strArr[i]);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有输入输出写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        BufferedWriter writer = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(System.out));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> T = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> N = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">            String tables = reader.readLine();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> M = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">            String enters = reader.readLine();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] res = solve(tables, enters);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r : res) &#123;</span><br><span class=\"line\">                writer.write(Integer.toString(r));</span><br><span class=\"line\">                writer.newLine();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        writer.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["Java编程"]},{"title":"操作系统面试知识点记录","url":"/2021/03/21/operating-system-interview/","content":"<h1 id=\"1-进程和线程的区别\"><a href=\"#1-进程和线程的区别\" class=\"headerlink\" title=\"1. 进程和线程的区别\"></a>1. 进程和线程的区别</h1><p>1）进程是资源分配的最小单位，线程是任务执行的最小单位。</p>\n<p>2）一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在。</p>\n<p>3）进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</p>\n<p>4）线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。</p>\n<p>5）线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p>\n<p>6）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p>\n<p>速记：单位，依赖，内存，通信</p>\n<h1 id=\"2-进程的调度算法\"><a href=\"#2-进程的调度算法\" class=\"headerlink\" title=\"2. 进程的调度算法\"></a>2. 进程的调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>\n<h2 id=\"1-批处理系统\"><a href=\"#1-批处理系统\" class=\"headerlink\" title=\"1. 批处理系统\"></a>1. 批处理系统</h2><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>\n<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>\n<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>\n<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>\n<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>\n<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>\n<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>\n<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>\n<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>\n<h2 id=\"2-交互式系统\"><a href=\"#2-交互式系统\" class=\"headerlink\" title=\"2. 交互式系统\"></a>2. 交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>\n<p><strong>2.1 时间片轮转</strong></p>\n<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>\n<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>\n<ul>\n<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>\n<li>而如果时间片过长，那么实时性就不能得到保证。</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png\" alt=\"img\"></p>\n<p><strong>2.2 优先级调度</strong></p>\n<p>为每个进程分配一个优先级，按优先级进行调度。</p>\n<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>\n<p><strong>2.3 多级反馈队列</strong></p>\n<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>\n<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>\n<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>\n<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png\" alt=\"img\"></p>\n<h2 id=\"3-实时系统\"><a href=\"#3-实时系统\" class=\"headerlink\" title=\"3. 实时系统\"></a>3. 实时系统</h2><p>实时系统要求一个请求在一个确定时间内得到响应。</p>\n<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>\n<p>速记：先进先出，短作业优先，最短剩余时间优先，时间片轮转，优先级调度，多级反馈队列</p>\n<h1 id=\"3-进程间通信的几种方式\"><a href=\"#3-进程间通信的几种方式\" class=\"headerlink\" title=\"3. 进程间通信的几种方式\"></a>3. 进程间通信的几种方式</h1><ul>\n<li><p>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>\n</li>\n<li><p>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>\n</li>\n<li><p>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>\n</li>\n<li><p>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p>\n</li>\n<li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问。主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p>\n</li>\n<li><p>套接字：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>\n</li>\n</ul>\n<h1 id=\"4-线程通信的方式\"><a href=\"#4-线程通信的方式\" class=\"headerlink\" title=\"4. 线程通信的方式\"></a>4. 线程通信的方式</h1><p>  a) 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</p>\n<p>  b) 信号量(Semphares)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>\n<p>  c) 事件(Event):Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>\n<h1 id=\"5-什么是死锁？死锁产生的条件？\"><a href=\"#5-什么是死锁？死锁产生的条件？\" class=\"headerlink\" title=\"5. 什么是死锁？死锁产生的条件？\"></a>5. 什么是死锁？死锁产生的条件？</h1><p>  1)死锁的概念</p>\n<p>　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>\n<p>2). 死锁产生的四个必要条件</p>\n<p>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</p>\n<p>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</p>\n<p>非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放</p>\n<p>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系</p>\n<h1 id=\"6-死锁处理策略\"><a href=\"#6-死锁处理策略\" class=\"headerlink\" title=\"6. 死锁处理策略\"></a>6. 死锁处理策略</h1><p>1）死锁检测与死锁恢复</p>\n<ol>\n<li>每种类型一个资源的死锁检测（找环）</li>\n<li>每种类型多个资源的死锁检测（矩阵）</li>\n<li>死锁恢复（利用抢占恢复，利用回滚恢复，通过杀死进程恢复）</li>\n</ol>\n<p>2）死锁预防</p>\n<p>死锁预防基本原理：破坏死锁发生的四个必要条件之一不成立。</p>\n<ol>\n<li>破坏互斥条件</li>\n</ol>\n<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>\n<ol start=\"2\">\n<li>破坏占有和等待条件</li>\n</ol>\n<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>\n<ol start=\"3\">\n<li><p>破坏不可抢占条件</p>\n</li>\n<li><p>破坏环路等待</p>\n</li>\n</ol>\n<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>\n<h1 id=\"7-进程有哪几种状态\"><a href=\"#7-进程有哪几种状态\" class=\"headerlink\" title=\"7. 进程有哪几种状态\"></a>7. 进程有哪几种状态</h1><ul>\n<li>就绪状态（ready）：等待被调度</li>\n<li>运行状态（running）</li>\n<li>阻塞状态（waiting）：等待资源</li>\n</ul>\n<p>应该注意以下内容：</p>\n<ol>\n<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>\n<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>\n</ol>\n<h1 id=\"8-线程有几种状态\"><a href=\"#8-线程有几种状态\" class=\"headerlink\" title=\"8. 线程有几种状态\"></a>8. 线程有几种状态</h1><p>在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：</p>\n<p><img src=\"http://static.zybuluo.com/Rico123/ot7o6218591iwj9py999hs1u/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg\" alt=\"线程的状态.jpg-59.9kB\"></p>\n<h1 id=\"9-虚拟内存\"><a href=\"#9-虚拟内存\" class=\"headerlink\" title=\"9. 虚拟内存\"></a>9. 虚拟内存</h1><p>虚拟内存的<strong>目的</strong>是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>\n<p>虚拟内存的<strong>基本思想</strong>是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。</p>\n<p>虚拟内存<strong>优点</strong>：</p>\n<ul>\n<li><p>在内存中可以保留多个进程，系统并发度提高</p>\n</li>\n<li><p>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</p>\n</li>\n</ul>\n<h1 id=\"10-页面置换算法\"><a href=\"#10-页面置换算法\" class=\"headerlink\" title=\"10. 页面置换算法\"></a>10. 页面置换算法</h1><ul>\n<li><p>FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p>\n</li>\n<li><p>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</p>\n</li>\n<li><p>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</p>\n</li>\n<li><p>OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p>\n</li>\n</ul>\n<h1 id=\"11-颠簸\"><a href=\"#11-颠簸\" class=\"headerlink\" title=\"11. 颠簸\"></a>11. 颠簸</h1><pre><code>     颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。\n</code></pre>\n<p>　　内存颠簸的解决策略包括：</p>\n<ul>\n<li><p>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；</p>\n</li>\n<li><p>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；</p>\n</li>\n<li><p>否则，还剩下两个办法：终止该进程或增加物理内存容量</p>\n</li>\n</ul>\n<h1 id=\"12-分页和分段有什么区别（内存管理）\"><a href=\"#12-分页和分段有什么区别（内存管理）\" class=\"headerlink\" title=\"12. 分页和分段有什么区别（内存管理）\"></a>12. 分页和分段有什么区别（内存管理）</h1><p>​        段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p>\n<p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p>\n<p>​        段页式：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>\n<p><strong>两者的不同点：</strong></p>\n<ul>\n<li><p>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</p>\n</li>\n<li><p>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</p>\n</li>\n<li><p>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</p>\n</li>\n<li><p>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</p>\n</li>\n<li><p>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</p>\n</li>\n<li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>\n</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://blog.csdn.net/justloveyou_/article/details/78304294\">https://blog.csdn.net/justloveyou_/article/details/78304294</a></p>\n<p>[2]<a href=\"http://www.cyc2018.xyz/\">http://www.cyc2018.xyz/</a></p>\n","categories":["操作系统"]}]