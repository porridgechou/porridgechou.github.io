[{"title":"Java基础","url":"/2021/03/24/210324Javabase/","content":"\n# **StringBuilder** **和** **StringBuffer**\n\n**StringBuffer** 是线程安全的 **StringBuilder** 是不安全的\n\n# Java实现连续空间的内存分配?\n\n基本数据类型的数组，存放在栈内存里，连续分配对象数组,在栈内存里的引用是连续分配的，实际数据分配在堆内存，不是连续分配的。\n\n# 创建对象的方式有哪几种？\n\n# 接口和抽象类有什么区别\n\n接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。\n\n抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。\n\n人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.\n\n所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。\n\n第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。\n第二点． 接口可以多继承，抽象类不行\n第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。\n第四点． 接口中基本数据类型为static 而抽类象不是的。\n\n当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。\n\n# 浅拷贝与深拷贝的区别\n\n**浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。**\n\n**深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。**\n\nps:Java中的拷贝需要实现java.lang.Cloneable接口，然后重写clone()方法，这个无论深、浅拷贝都需要这样做\n\n# 多态\n\n**编译时多态**\n方法重载 都是编译时多态。根据实际参数的数据类型、个数和次序，Java 在编译时能够确定执行重载方法中的哪一个。\n\n方法覆盖 表现出两种多态性，当对象引用本类实例时，为编译时多态，否则为运行时多态。\n\n**运行时多态**\n通过父类对象引用变量引用子类对象来实现。当父类对象引用子类实例时。通过接口类型变量引用实现接口的类的对象来实现 。运行时多态主要是通过继承和接口实现的。\n\n# Java注解的理解\n\nJava 语言中的类、方法、变量、参数和包等都可以注解标记，程序运行期间我们可以获取到相应的注解以及注解中定义的内容，这样可以帮助我们做一些事情。\n\n# Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？\n\n反射介绍：\n\nJava 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及 动态调用对象的方法的功能称为 Java 语言的反射机制。\n\n反射的优缺点如下：\n\n- 优点：运行期类型的判断，动态加载类，提高代码灵活度。\n\n- 缺点：\n\n1. 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。\n\n2. 安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。\n\n# 为什么框架需要反射技术\n\n在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机 制没有用，实际上有很多设计、开发都与反射机制有关。动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。\n\n我们在使用 JDBC 连接数据库时使用 Class.forName() 通过反射加载数据库的驱动程序；\nSpring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；\n动态配置实例的属性；\n\n# 获取Class对象的两种方式\n\n如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了两种方式获取 Class 对象:\n\n知道具体类的情况下可以使用：\n\n```Java\nClass alunbarClass = TargetObject.class;      \n```\n\n\n但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象\n\n通过 Class.forName() 传入类的路径获取：\n\n```Java\nClass alunbarClass1 = Class.forName(\"cn.javaguide.TargetObject\"); \n```\n\n# 内存泄露和内存溢出的场景\n\n内存泄漏：内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不 到及时释放，从而造成内存空间的浪费称为内存泄漏。\n\nJava 内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。\n\n内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生 于 OLD 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况。\n\n内存溢出场景：\n\n- JVM Heap（堆）溢出：OutOfMemoryError: Java heap space： 发生这种问题的原因是 java 虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已 经用满了。JVM 在启动的时候会自动设置 JVM Heap 的值， 可以利用 JVM 提供的-Xmn -Xms -Xmx 等选项可进行设置。Heap的大小是新生代和老年代之和。\n\n解决方法：\n\n1. 手动设置 JVM Heap（堆）的大小。\n\n2. 检查程序，看是否有死循环或不必要地重复创建大量对象。\n\n   \n\n- Metaspace溢出：java.lang.OutOfMemoryError: Metaspace 程序中使用了大量的 jar 或 class，使 java 虚拟机装载类的空间不够，与 metaspace 大小有关。方法区用于存放 Java 类型的相关信息。在类装载器加载 class 文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的 内存占用又已经达到 -XX:MaxMetaspaceSize 设置的最大值，将会抛出 OutOfMemoryError 异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。\n\n解决方法:\n\n1. 通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。\n- 栈溢出： java.lang.StackOverflowError : Thread Stack space：线程的方法嵌套调用层次太多(如递归调用)，以致于把栈区溢出了。\n\n解决方法：\n\n1. 修改程序。\n2. 通过 -Xss: 来设置每个线程的 Stack 大小即可。\n\n# 强引用，弱引用，软引用，虚引用\n\n## 强引用\n\n大部分引用实际上都是，最普遍。\n\n```java\nObject object = new Object();\nString str = \"StrongReference\";\n```\n\n如果一个对象具有强引用，那就类似于**必不可少的**物品，不会被垃圾回收器回收。**当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。**\n\n## 软引用\n\n软引用是用来描述一些**有用但并不是必需**的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。\n软引用在实际中有重要的应用，例如浏览器的后退按钮，这个后退时显示的网页内容可以重新进行请求或者从缓存中取出：\n\n（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建\n\n（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出这时候就可以使用软引用\n\n## 弱引用\n\n弱引用也是用来描述**非必需对象**的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。\n\n弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<u>所以被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</u>\n\n## 虚引用\n\n虚引用和前面的软引用、弱引用不同，它并**不影响对象的生命周期**。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，**在任何时候都可能被垃圾回收器回收**。虚引用主要用来跟踪对象被垃圾回收的活动。\n\n**虚引用必须和引用队列关联使用**，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n## 总结\n\n| 引用类型 | 被回收时间    | 用途           | 生存时间      |\n| -------- | ------------- | -------------- | ------------- |\n| 强引用   | 从来不会      | 对象的一般状态 | JVM停止运行时 |\n| 软引用   | 内存不足时    | 对象缓存       | 内存不足时    |\n| 弱引用   | jvm垃圾回收时 | 对象缓存       | gc运行后      |\n| 虚引用   | 未知          | 未知           | 未知          |\n\n# 讲一下 Java 的 BIO,NIO,AIO?\n\n## BIO (Blocking I/O)：\n\n同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。\n\n## NIO (Non-blocking/New I/O):\n\nNIO 是一种同步非阻塞的 I/O 模型，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。Java NIO使我们可以进行非阻塞IO操作。比如说， 单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后， 线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一 些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。JDK 的 NIO 底层由 epoll 实现。\n\n通常来说 NIO 中的所有 IO 都是从 Channel（通道） 开始的。\n\n从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。\n\n从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。\n\n## AIO (Asynchronous I/O)：\n\n异步非阻塞IO模型，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的 线程进行后续的操作。AIO 的应用还不是很广泛。\n\n# Java中finalize()方法的使用\n\nfinalize()是 Object的protected 方法，子类可以覆盖该方法以实现资源清理工作，GC 在回收对象之前调用该方法。\n\n**finalize()方法中一般用于释放非 Java 资源（如打开的文件资源、数据库连接等），或是调用非Java方法（native方法）时分配的内存（比如 C 语言的 malloc()系列函数）。**\n\n避免使用的原因：\n\n首先，由于 finalize()方法的调用时机具有不确定性，从一个对象变得不可到达开始，到 finalize()方法被执行，所花费的时间这段时间是任意长的。我们并不能依赖 finalize()方法能 及时的回收占用的资源，可能出现的情况是在我们耗尽资源之前，gc 却仍未触发，因而通常的做法是提供显示的 close()方法供客户端手动调用。另外，重写 finalize()方法意味着延长了回收对象时需要进行更多的操作，从而延长了对象回收的时间。\n\n# 什么是GC Root\n\n首先我们知道标记算法，JVM的标记算法我们可以了解为一个可达性算法，所以所有的可达性算法都会有起点，那么这个起点就是GC Root。也就是需要通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。\n\n## GC Root的对象\n\n- 方法区中的静态变量和常量引用的对象\n- 虚拟机栈中引用对象\n- 本地方法栈中引用对象\n\n# 单例模型\n\n下述内容来源于[菜鸟教程](https://www.runoob.com/design-pattern/singleton-pattern.html)\n\n```java\n/* \n1、懒汉式，线程不安全\n是否 Lazy 初始化：是\n是否多线程安全：否\n实现难度：易\n描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。\n这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。\n*/\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n  \n    public static Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n}\n\n//接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。\n\n/*\n2、懒汉式，线程安全\n是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：易\n描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。\n优点：第一次调用才初始化，避免内存浪费。\n缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。\ngetInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\n*/\npublic class Singleton {  \n    private static Singleton instance;  \n    private Singleton (){}  \n    public static synchronized Singleton getInstance() {  \n    if (instance == null) {  \n        instance = new Singleton();  \n    }  \n    return instance;  \n    }  \n}\n/*\n3、饿汉式\n是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种方式比较常用，但容易产生垃圾对象。\n优点：没有加锁，执行效率会提高。\n缺点：类加载时就初始化，浪费内存。\n它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。\n*/\npublic class Singleton {  \n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n    return instance;  \n    }  \n}\n/*\n4、双检锁/双重校验锁（DCL，即 double-checked locking）\nJDK 版本：JDK1.5 起\n是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：较复杂\n描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。\ngetInstance() 的性能对应用程序很关键。\n*/\npublic class Singleton {  \n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    public static Singleton getSingleton() {  \n    if (singleton == null) {  \n        synchronized (Singleton.class) {  \n        if (singleton == null) {  \n            singleton = new Singleton();  \n        }  \n        }  \n    }  \n    return singleton;  \n    }  \n}\n/*\n5、登记式/静态内部类\n是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：一般\n描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\n这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。\n*/\npublic class Singleton {  \n    private static class SingletonHolder {  \n    private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    public static final Singleton getInstance() {  \n    return SingletonHolder.INSTANCE;  \n    }  \n}\n/*\n6、枚举\nJDK 版本：JDK1.5 起\n是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。\n这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。\n不能通过 reflection attack 来调用私有构造方法。\n*/\npublic enum Singleton {  \n    INSTANCE;  \n    public void whateverMethod() {  \n    }  \n}       \n\n```\n\n# Java中>>和>>>的区别\n\nJava 中的位运算符：\n\n'>>'表示带符号右移，如：int i=15; i>>2 的结果是 3，移出的部分将被抛弃。\n转为二进制的形式可能更好理解，0000 1111(15)右移 2 位的结果是 0000 0011(3)，0001 1010(18)右移 3 位的结果是 0000 0011(3)。\n\n'>>>'无符号右移：\n按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补零。对于正数来说和带符号右移相同，对于负数来说不同。\n其他结构和>>相似。\n\n\n\n# 参考资料\n\n[1]https://blog.csdn.net/qq_39192827/article/details/85611873\n\n","tags":["面试"],"categories":["Java"]},{"title":"位运算","url":"/2021/03/24/210324weiyunsuan/","content":"\n# 基本原理\n\n0s 表示一串 0，1s 表示一串 1。\n```text\nx ^ 0s = x      x & 0s = 0      x | 0s = x\nx ^ 1s = ~x     x & 1s = x      x | 1s = 1s\nx ^ x = 0       x & x = x       x | x = x\n```\n\n利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。\n\n```text\n1^1^2 = 2\n```\n\n利用 x & 0s = 0 和 x & 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。\n\n```text\n01011011 &\n00111100\n--------\n00011000\n```\n\n利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。\n\n```text\n01011011 |\n00111100\n--------\n01111111\n```\n\n**位与运算技巧**\n\nn&(n-1) 去除 n 的位级表示中**最低**的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。\n\n```text\n01011011 &\n01011010\n--------\n01011010\n```\n\nn&(-n) 得到 n 的位级表示中**最低**的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。\n\n```text\n10110100 &\n01001100\n--------\n00000100\n```\n\nn-(n&(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&(n-1) 效果一样。\n\n**移位运算**\n\n\\>\\> n 为算术右移，相当于除以 2n，例如 -7 \\>\\> 2 = -2。\n\n```text\n11111111111111111111111111111001  >> 2\n--------\n11111111111111111111111111111110\n```\n\n\\>\\>\\> n 为无符号右移，左边会补上 0。例如 -7 \\>\\>\\> 2 = 1073741822。\n\n```text\n11111111111111111111111111111001  >>> 2\n--------\n00111111111111111111111111111111\n```\n\n<< n 为算术左移，相当于乘以 2n。-7 << 2 = -28。\n\n```text\n11111111111111111111111111111001  << 2\n--------\n11111111111111111111111111100100\n```\n\n**mask 计算**\n\n要获取 111111111，将 0 取反即可，~0。\n\n要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1<<(i-1) 。例如 1<<4 得到只有第 5 位为 1 的 mask ：00010000。\n\n要得到 1 到 i 位为 1 的 mask，(1<<i)-1 即可，例如将 (1<<4)-1 = 00010000-1 = 00001111。\n\n要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1<<i)-1)。\n\n**Java 中的位操作**\n\n```html\nstatic int Integer.bitCount();           // 统计 1 的数量\nstatic int Integer.highestOneBit();      // 获得最高位\nstatic String toBinaryString(int i);     // 转换为二进制表示的字符串\n```\n\n# 汉明距离\n\n[461.汉明距离](https://leetcode-cn.com/problems/hamming-distance/)\n\n两个整数之间的[汉明距离](https://baike.baidu.com/item/汉明距离)指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。\n\n```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        int z=x^y;\n        int count=0;\n        while(z!=0){\n            if((z&1)==1){\n                count++;\n            }\n            z=z >> 1;\n        }\n        return count;\n    }\n}\n```\n\nps:采取异或的方法看有哪几位是不同的\n\n```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        int z=x^y;\n        int count=0;\n        while(z!=0){\n            z&=(z-1);\n            count++;\n        }\n        return count;\n    }\n}\n```\n\n\n\nps：通过z&(z-1)来清除最低位的1。\n\n# 只出现一次的数字\n\n[136.只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int ret=0;\n         for(int num: nums){\n            ret=ret^num;\n         }\n         return ret;\n    }\n}\n```\n\n# 只出现一次的数字III\n\n[260.只出现一次的数字III](https://leetcode-cn.com/problems/single-number-iii/)\n\n给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。\n\n```java\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int div=0;\n        for(int num:nums){\n            div^=num;\n        }\n        div&=-div;\n        int[] ans={0,0};\n        for(int num:nums){\n            if((div&num)==0){\n                ans[0]=ans[0]^num;\n            }else{\n                ans[1]=ans[1]^num;\n            }\n        }\n        return ans;\n    }\n}\n```\n\nps：通过z&(-z)获得中**最低**的那一位\n\n# 丢失的数字\n\n[268.丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int target=0;\n        for (int i=1;i<=nums.length ;i++ ) {\n            target=target^i^nums[i-1];\n        }\n        return target;\n    }\n}\n```\n\nps:采用的就是x^x=0的思想\n\n# 颠倒二进制位\n\n [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)\n\n```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int ret=0;\n        for(int i=0;i<32;i++){\n            ret=ret<<1;\n            ret |=(n&1);\n            n=n >>> 1;\n        }\n        return ret;\n    }\n}\n```\n\nps:借助n&1是最后一位，然后进行操作。\n\n# 2的幂\n\n [231. 2的幂](https://leetcode-cn.com/problems/power-of-two/)\n\n```java\nclass Solution {\npublic boolean isPowerOfTwo(int n) {\n    return n>0 && (n&(n-1))==0;\n}\n}\n```\n\nps:使用n&(n-1)为去除最低的1。\n\n# 比特位计数\n\n [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)\n\n```java\nclass Solution {\n    public int[] countBits(int num) {\n        int[] ret=new int[num+1];\n        for(int i=1;i<=num;i++){\n            ret[i]=ret[i&(i-1)]+1;\n        }\n        return ret;\n    }\n}\n```\n\nps:还是采用了i&(i-1)为最低位的1思想。","tags":["位运算"],"categories":["算法"]},{"title":"链表","url":"/2021/03/24/210324javaList/","content":"\n# 两数相加\n\n[2.两数相加](https://leetcode-cn.com/problems/add-two-numbers/)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    \tListNode head=null;\n    \tListNode temp=null;\n    \tint flag=0;\n    \twhile(l1!=null||l2!=null){\n    \t\tint n1 = l1!=null ? l1.val: 0;\n            int n2 = l2!=null ? l2.val: 0;\n            int sum = n1 + n2 + flag;\n    \t\tif(head==null){\n    \t\t\thead=temp=new ListNode(sum%10);\n    \t\t}else{\n    \t\t\ttemp.next=new ListNode(sum%10);\n    \t\t\ttemp=temp.next;\n    \t\t}\n    \t\tflag=sum/10;\n    \t\t\n    \t\tif(l1!=null){\n    \t\t\tl1=l1.next;\n    \t\t}\n    \t\tif(l2!=null){\n    \t\t\tl2=l2.next;\n    \t\t}\n    \t}\n    \tif(flag>0){\n    \t\ttemp.next=new ListNode(flag);\n    \t}\n    \treturn head;\n    }\n}\n```\n\nps:注意空指针问题！\n\n# 找出两个链表的交点\n\n [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode l1=headA;\n        ListNode l2=headB;\n        while(l1!=l2){\n            if(l1==null){\n                l1=headB;\n            }else{\n                l1=l1.next;\n            }\n            if(l2==null){\n                l2=headA;\n            }else{\n                l2=l2.next;\n            }\n           \n        }\n        return l1;\n    }\n}\n```\n\n# 翻转链表\n\n[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n反转一个单链表。\n\n![img](https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre=head;\n        ListNode cur=null;\n        while(pre!=null){\n            ListNode temp=pre.next;\n            pre.next=cur;\n            cur=pre;\n            pre=temp;\n\n        }\n        return cur;\n    }\n}\n```\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head==null||head.next==null){\n            return head;\n        }\n        ListNode cur=reverseList(head.next);\n        head.next.next=head;\n        head.next=null;\n        return cur;\n    }\n}\n```\n\n# 合并两个有序链表\n\n [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode nhead =new ListNode(-1);\n        ListNode temp=nhead;\n        while(l1!=null&&l2!=null){\n            if(l1.val<=l2.val){\n                temp.next=l1;\n                l1=l1.next;\n                temp=temp.next;\n            }else{\n                temp.next=l2;\n                l2=l2.next;\n                temp=temp.next;\n            }\n        }\n        if(l1!=null){\n            while(l1!=null){\n                temp.next=l1;\n                l1=l1.next;\n                temp=temp.next;\n            }\n        }\n        if(l2!=null){\n            temp.next=l2;\n            l2=l2.next;\n            temp=temp.next;\n        }\n        return nhead.next;\n    }\n}\n```\n\n","categories":["算法"]},{"title":"数据库面试知识点记录","url":"/2021/03/24/210324Database/","content":"\n# 1.数据库范式\n\n- 第一范式：列不可分，eg:【联系人】（姓名，性别，电话），一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF；\n\n- 第二范式：有主键，保证完全依赖。eg:订单明细表【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName），Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID，不符合2NF；\n\n- 第三范式：无传递依赖(非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况)，eg:订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。\n\n# 2.数据库索引\n\n**索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。**索引的实现通常使用B_TREE及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。\n\n## 1). 索引的底层实现原理和优化 \n\n　　在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。\n(1). B-Tree(平衡多路查找树)\n\n　　B_TREE是一种平衡多路查找树，是一种动态查找效率很高的树形结构。B_TREE中所有结点的孩子结点的最大值称为B_TREE的阶，B_TREE的阶通常用m表示，简称为m叉树。一般来说，应该是m>=3。一颗m阶的B_TREE或是一颗空树，或者是满足下列条件的m叉树：\n\n树中每个结点最多有m个孩子结点；\n\n若根结点不是叶子节点，则根结点至少有2个孩子结点；\n\n除根结点外，其它结点至少有(m/2的上界)个孩子结点；\n\n结点的结构如下图所示，其中，n为结点中关键字个数，(m/2的上界)-1 <= n <= m-1；di(1<=i<=n)为该结点的n个关键字值的第i个，且di< d(i+1)；ci(0<=i<=n)为该结点孩子结点的指针，且ci所指向的节点的关键字均大于或等于di且小于d(i+1)；\n\n　　　　　　　　　　![B-Tree结点的结构.png-1.7kB](http://static.zybuluo.com/Rico123/4clzcd69i34ihxiddnsorkza/B-Tree%E7%BB%93%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84.png)\n\n所有的叶结点都在同一层上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）。\n\n　　下图是一棵4阶B_TREE，4叉树结点的孩子结点的个数范围[2,4]。其中，有2个结点有4个孩子结点，有1个结点有3个孩子结点，有5个结点有2个孩子结点。\n\n　　　![4阶B_TREE.jpg-24.1kB](http://static.zybuluo.com/Rico123/z66j4t1g8jknavzqweyikezd/4%E9%98%B6B_TREE.jpg)　　\n\n　　B_TREE的查找类似二叉排序树的查找，所不同的是B-树每个结点上是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，到按照对应的指针信息指向的子树中去查找，当到达叶子结点时，则说明树中没有对应的关键码。由于B_TREE的高检索效率，B-树主要应用在文件系统和数据库中，对于存储在硬盘上的大型数据库文件，可以极大程度减少访问硬盘次数，大幅度提高数据检索效率。\n\n(2). B+Tree ： **InnoDB存储引擎的索引实现**\n\n　　B+Tree是应文件系统所需而产生的一种B_TREE树的变形树。一棵m阶的B+树和m阶的B_TREE的差异在于以下三点：\n\n- n 棵子树的结点中含有n个关键码；\n\n- 所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；\n\n- 非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码。\n\n　　下图为一棵3阶的B+树。通常在B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。因此可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。\n在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。只是在查找时，若非终端结点上的关键码等于给定值，并不终止，而是继续向下直到叶子结点。因此，对于B+树，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。\n\n　　　　　　　　　　![一棵3阶的B+树.jpg-29.9kB](http://static.zybuluo.com/Rico123/ynugdx0avoy5blfq6gkb0tv2/3%E9%98%B6B+%E6%A0%91.jpg)\n\n(3). 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？\n\n- B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；\n\n- B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；\n\n- 数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。\n\n(4). 文件索引和数据库索引为什么使用B+树?\n\n　　文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。\n\n## 2). 索引的优点\n\n大大加快数据的检索速度，这也是创建索引的最主要的原因；\n\n加速表和表之间的连接；\n\n在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；\n\n通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；\n\n## 3). 什么情况下设置了索引但无法使用？\n\n以“%(表示任意0个或多个字符)”开头的LIKE语句，模糊匹配；\n\nOR语句前后没有同时使用索引；\n\n数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；\n\n对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。\n\n## 4). 什么样的字段适合创建索引？\n\n经常作查询选择的字段\n\n经常作表连接的字段\n\n经常出现在order by, group by, distinct 后面的字段\n\n## 5). 创建索引时需要注意什么？\n\n非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；\n\n取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；\n\n索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。\n\n## 6). 索引的缺点\n\n时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；\n\n空间方面：索引需要占物理空间。\n\n## 7). 索引的分类\n\n普通索引和唯一性索引：索引列的值的唯一性\n\n单个索引和复合索引：索引列所包含的列数\n\n聚簇索引与非聚簇索引：聚簇索引按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚簇索引必须是唯一的。聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了；而非聚集索引是把一个很大的范围，转换成一个小的地图，然后你需要在这个小地图中找你要寻找的信息的位置，最后通过这个位置，再去找你所需要的记录。\n\n## 8). 主键、自增主键、主键索引与唯一索引概念区别\n\n主键：指字段 唯一、不为空值 的列；\n\n主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；\n\n自增主键：字段类型为数字、自增、并且是主键；\n\n唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。\n\n## 9). 主键就是聚集索引吗？主键和索引有什么区别？\n\n　　主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。\n\n# 3.数据库事务\n\n事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。\n\n## 事务的特征\n\n- 原子性(Atomicity)：事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚；\n\n- 一致性(Consistency)：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态；\n\n- 隔离性(Isolation)：并发执行的事务之间不能相互影响；\n\n- 持久性(Durability)：事务一旦提交，对数据库中数据的改变是永久性的。\n\n## 事务并发带来的问题\n\n- 丢失修改：丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png)\n\n- 脏读：一个事务读取了另一个事务未提交的数据；\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png)\n\n- 不可重复读：不可重复读的重点是**修改**，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png)\n\n- 幻读：幻读的重点在于**新增或者删除**，同样条件下两次读出来的记录数不一样。\n\n\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png)\n\n## 隔离级别\n\n### 未提交读（READ UNCOMMITTED）\n\n事务中的修改，即使没有提交，对其它事务也是可见的。\n\n### 提交读（READ COMMITTED）\n\n一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n\n### 可重复读（REPEATABLE READ）\n\n保证在同一个事务中多次读取同一数据的结果是一样的。（在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务commit或rollback。但是，其他事务的insert/delete操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复select的结果一样，除非本事务中update数据库。）\n\n### 可串行化-serializable)可串行化（SERIALIZABLE）\n\n强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n\n------\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png)\n\nps：MySQL默认的隔离级别是可重复读REPEATABLE READ。\n\n## 4.MySQL的事务支持\n\nMySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关：\n\n- MyISAM：不支持事务，用于只读程序提高性能；\n- InnoDB：支持ACID事务、行级锁、并发；\n- Berkeley DB：支持事务。\n\n# 5.MySQL中的悲观锁与乐观锁的实现\n\n1. 悲观锁\n\n悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。   \n\n2. 乐观锁\n\n乐观锁的特点先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号或者时间戳，然后按照如下方式实现：\n\n3. 悲观锁与乐观锁的应用场景\n\n一般情况下，**读多写少更适合用乐观锁，读少写多更适合用悲观锁**。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。\n\n# 6.JDBC 对事务的支持\n\n对于JDBC而言，每条单独的语句都是一个事务，即每个语句后都隐含一个commit。实际上，Connection 提供了一个auto-commit的属性来指定事务何时结束。当auto-commit为true时，当每个独立SQL操作的执行完毕，事务立即自动提交，也就是说，每个SQL操作都是一个事务；当auto-commit为false时，每个事务都必须显式调用commit方法进行提交，或者显式调用rollback方法进行回滚。auto-commit默认为true。\n\n```java\ntry {  \n    conn.setAutoCommit(false);  //将自动提交设置为false        \n    ps.executeUpdate(\"修改SQL\"); //执行修改操作  \n    ps.executeQuery(\"查询SQL\");  //执行查询操作                 \n    conn.commit();      //当两个操作成功后手动提交     \n} catch (Exception e) {  \n    conn.rollback();    //一旦其中一个操作出错都将回滚，使两个操作都不成功  \n    e.printStackTrace();  \n} \n```\n\n　　为了能够将多条SQL当成一个事务执行，必须首先通过\n\n​          ","categories":["数据库"]},{"title":"计算机网络","url":"/2021/03/23/computer-networks-interview/","content":"\n# 1.Http和Https的区别\n\nHttp协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：\n\n- 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；\n\n- 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；\n\n- 开销：Https通信需要证书，而证书一般需要向认证机构购买；\n  　\n\nHttps的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。\n\n# 2.HTTP 是哪一层的协议？http常见的状态码\n\nHTTP 协议 属于应用层的协议。\n\n**HTTP 协议是基于 TCP 协议的**，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。\n\n另外， HTTP协议是无状态的协议，它**无法记录客户端用户的状态** 一般我们都是通过Session 来记录客户端用户的状态。\n\n| 状态码 |               类别               |            含义            |\n| :----: | :------------------------------: | :------------------------: |\n|  1XX   |  Informational（信息性状态码）   |     接收的请求正在处理     |\n|  2XX   |      Success（成功状态码）       |      请求正常处理完毕      |\n|  3XX   |   Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |\n|  4XX   | Client Error（客户端错误状态码） |     服务器无法处理请求     |\n|  5XX   | Server Error（服务器错误状态码） |     服务器处理请求出错     |\n\n## 1XX 信息\n\n- <u>**100 Continue**</u> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。\n\n## 2XX 成功\n\n- <u>**200 OK**</u>\n- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。\n- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。\n\n## 3XX 重定向\n\n- <u>**301 Moved Permanently**</u> ：永久性重定向\n- <u>**302 Found**</u> ：临时性重定向\n- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。\n- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。\n- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。\n- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。\n\n## 4XX 客户端错误\n\n- **400 Bad Request** ：请求报文中存在语法错误。\n- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。\n- <u>**403 Forbidden**</u> ：请求被拒绝。(可能没有权限)\n- <u>**404 Not Found**</u> :  没有对应资源\n\n## 5XX 服务器错误\n\n- <u>**500 Internal Server Error**</u>  ：服务器正在执行请求时发生错误。（有内部错误）\n- <u>**503 Service Unavailable**</u> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n#  3.对称式加密与非对称式加密\n\n对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称 加密算法有DES、AES等；\n\n非对称密钥加密，加密和解密使用不同的密钥。通信发送方获得接收方的公开密钥之后，就 可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。可以更安全地将公 开密钥传输给通信发送方；运算速度慢。典型的非对称加密算法有RSA、DSA等\n\nHTTPS 采用的加密方式: HTTPS 采用混合的加密机制。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。\n\n# 4.HTTP/2.0\n\n## HTTP/1.x 缺陷\n\nHTTP/1.x 实现简单是以牺牲性能为代价的：\n\n- 客户端需要使用多个连接才能实现并发和缩短延迟；\n- 不会压缩请求和响应首部，从而导致不必要的网络流量；\n- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。\n\n## HTTP/2.0\n\n### 二进制分帧层\n\n- HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。\n\n- 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。\n\n### 服务端推送\n\nHTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。\n\n### 首部压缩\n\nHTTP/1.1 的首部带有大量信息，而且每次都要重复发送。\n\nHTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。\n\n不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。\n\n# 5.HTTP报文详解\n\n## 请求和响应报文\n\n客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。\n\n请求报文结构：\n\n- 第一行是包含了请求方法、URL、协议版本；\n- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。\n- 一个空行用来分隔首部和内容主体 Body\n- 最后是请求的内容主体\n\n```text\nGET http://www.example.com/ HTTP/1.1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nCache-Control: max-age=0\nHost: www.example.com\nIf-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT\nIf-None-Match: \"3147526947+gzip\"\nProxy-Connection: keep-alive\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 xxx\n\nparam1=1&param2=2\n```\n\n响应报文结构：\n\n- 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了\n- 接下来多行也是首部内容\n- 一个空行分隔首部和内容主体\n- 最后是响应的内容主体\n\n```text\nHTTP/1.1 200 OK\nAge: 529651\nCache-Control: max-age=604800\nConnection: keep-alive\nContent-Encoding: gzip\nContent-Length: 648\nContent-Type: text/html; charset=UTF-8\nDate: Mon, 02 Nov 2020 17:53:39 GMT\nEtag: \"3147526947+ident+gzip\"\nExpires: Mon, 09 Nov 2020 17:53:39 GMT\nKeep-Alive: timeout=4\nLast-Modified: Thu, 17 Oct 2019 07:18:26 GMT\nProxy-Connection: keep-alive\nServer: ECS (sjc/16DF)\nVary: Accept-Encoding\nX-Cache: HIT\n\n<!doctype html>\n<html>\n<head>\n    <title>Example Domain</title>\n\t// 省略... \n</body>\n</html>\n```\n\n# 6.HTTP/1.1 新特点\n\n- 默认是长连接\n- 支持流水线\n- 支持同时打开多个 TCP 连接\n- 支持虚拟主机\n- 新增状态码 100\n- 支持分块传输编码\n- 新增缓存处理指令 max-age\n\n# 7.GET和POST的区别\n\n##  作用\n\nGET 用于获取资源，而 POST 用于传输实体主体。\n\n## 参数\n\nGET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 **请求头** 中。而POST请求会把提交的数据则放置在是HTTP请求报文的 **请求体 **中。\n\n## 安全\n\n安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。\n\nGET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。\n\n安全的方法除了 GET 之外还有：HEAD、OPTIONS。\n\n不安全的方法除了 POST 之外还有 PUT、DELETE。\n## 幂等性\n幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。\n\n所有的安全方法也都是幂等的。\n\n在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。\n\n## 请求的大小\n\nGET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。\n\n# 8.TCP/IP 4 层模型了解么\n\nTCP/IP 4 层模型:\n\n1. 应用层\n2. 传输层\n3. 网络层\n4. 网络接口层\n\n# 9.OSI网络体系结构与TCP/IP协议模型\n\n​\t我们知道TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对OSI七层模型的各层进行简要的介绍：\n\n　　　　　　　　　![OSI网络体系结构与TCPIP协议模型.png-51.3kB](http://static.zybuluo.com/Rico123/0qwq331jj8bzgmqst282f6lp/OSI%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8ETCPIP%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png)　\n\n1). 物理层\n\n　　参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。\n\n2). 数据链路层（data link layer）\n\n　　接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。\n\n3). 网络层\n\n　　将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。\n\n　　　　　　![数据链路层与网路层.png-58.4kB](http://static.zybuluo.com/Rico123/ed9145bf4nus32fr7umxxnk7/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E8%B7%AF%E5%B1%82.png)　　　　\n\n4). 传输层（transport layer）\n\n　　在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。\n\n　　　　　![网路层与传输层.png-52.8kB](http://static.zybuluo.com/Rico123/5td1y45fm09cbhgw07o6fgfc/%E7%BD%91%E8%B7%AF%E5%B1%82%E4%B8%8E%E4%BC%A0%E8%BE%93%E5%B1%82.png)　　　　　\n\n　　实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。\n\n5). 会话层（Session Layer）\n\n　　会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。\n\n6). 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密\n\n　　表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。\n\n7). 应用层（Application layer）：为用户的应用进程提供网络通信服务\n\n# 10.三次握手\n\n![](/images/pasted-210323threehandshake.jpg)\n\n![](/images/pasted-210323fourhandshake.jpg)\n\n![](/images/pasted-210323statechange.jpg)\n\n## 文字说明\n\n三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：\n\n- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。\n\n- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。\n\n- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。\n\n\n![三次握手.png-12.4kB](http://static.zybuluo.com/Rico123/c7m5fo6qdua0q7me88jm9w10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)\n\n## 三次握手的原因\n\n三次握手的目的是建立可靠的通信信道，三次握手最主要的目的就是双方确认自己与对方的 发送与接收是正常的。\n\n第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。\n\n## 为什么两次不行\n\n​\t\t为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。\n\n　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。\n\n\n# 11.四次挥手\n\n![](/images/pasted-210323groupchange.jpg)\n\n## 文字说明\n\n- 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。\n\n- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。\n\n- 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。\n\n- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。\n  ![四次挥手.png-12.6kB](http://static.zybuluo.com/Rico123/ardiuu1otopo9f1jd4df18iz/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)\n\n## CLOSE-WAIT 状态问题：\n\n客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN 连接释放报文。\n\n## TIME-WAIT 状态问题(这个问题问过很多次但总是答得不甚满意)：\n\n客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：\n\n确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。\n\n等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一 个新的连接不会出现旧的连接请求报文。\n\n通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。\n\n# 12.TCP滑动窗口是干什么的\n\n滑动窗口：窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接 收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。\n\n发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。接收窗口只会对窗口内 最后一个按序到达的字节进行确认。如果发送窗口内的字节已经发送并且收到了确认，那么 就将发送窗口向右滑动一定距离，直到第一个字节不是已发送并且已确认的状态；接收窗口 的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向滑动接收窗口。\n\n# 13.TCP的可靠性体现在哪里\n\n对于可靠性，TCP通过以下方式进行保证：\n\n- 数据包校验（校验和）：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；\n\n- 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；\n\n- 丢弃重复数据：对于重复数据，能够丢弃重复数据；\n\n- 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；\n\n- 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；\n\n- 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。\n\n- 拥塞控制：当网络拥塞时，减少数据的发送。\n\n# 14.TCP流量控制\n\n**流量控制如何实现**：流量控制是为了控制发送方发送速率，保证接收方来得及接收。\n\n接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送 速率。将窗口字段设置为 0，则发送方不能发送数据。\n\n# 15.拥塞控制如何实现\n\n如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞 程度更高。因此当出现拥塞时，应当控制发送方的速率。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。\n\n发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。\n\n1）**慢启动：**不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;\n\n2） **拥塞避免：**拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。如果出现了超时，则令慢开始门限 = 拥塞窗口大小 / 2，然后重新执行慢开始。\n\n![慢开始与拥塞避免.png-90.3kB](http://static.zybuluo.com/Rico123/whi0y5sbc3tx9qcdp0s532gw/%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png)\n\n3）**快重传：**快重传要求接收方在收到一个 **失序的报文段** 后就立即发出 **重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n\n![快重传.jpg-42.3kB](http://static.zybuluo.com/Rico123/wuktdms9jtg4s9m4pe5kcbiq/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg)\n\n4）**快恢复**：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。\n\n# 16.TCP和UDP有什么区别？及其适用的场景\n\nTCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：\n\n- TCP是面向连接的，UDP是无连接的；\n\n- TCP是可靠的，UDP是不可靠的；\n\n- TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；\n\n- TCP是面向字节流的，UDP是面向报文的；\n\n- TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；\n\n- TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；\n\n**TCP应用场景**：\n\n效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、 排序等操作，相比之下效率没有UDP高。举几个例子：文件传输、接受邮件、远程登录。\n\n**UDP应用场景**：\n\n效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话、广播通信（广播、多播）。\n\n\n\n1). TCP对应的应用层协议\n\n- FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。\n\n- Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。\n\n- SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。\n\n- POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。\n\n- HTTP：从Web服务器传输超文本到本地浏览器的传送协议。\n\n2). UDP对应的应用层协议\n\n- DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。\n\n- SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。\n\n- TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。\n  \n\n![TCP和UDP分别对应的常见应用层协议.png-41.5kB](http://static.zybuluo.com/Rico123/r3gm4e6y9hlgqllw8ba10676/TCP%E5%92%8CUDP%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.png)\n\n# 17.UDP为何快\n\n**UDP为何快？**\n\n1. 不需要建立连接\n2. 对于收到的数据，不用给出确认\n3. 没有超时重发机制\n4. 没有流量控制和拥塞控制\n\n# 18.Mac 地址和 ip 地址的区别？既然有了 Mac 地址，为什么还要 ip 地址呢？\n\nMAC地址是烧录在网卡或者接口上的**物理地址**，具有**全球唯一性**，一般不能被改变。IP地址是网络中的主机或接口在网络中的**逻辑地址**，在**同一个网络内具有唯一性**。\n\n# 19.当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。\n\n1. 浏览器查找域名的IP地址 （DNS：获取域名对应的IP）\n2.  浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；\n3. TCP/IP链接建立起来后，浏览器向web服务器发送HTTP请求（cookies会随着请求发送给服务器）\n4. 服务器处理请求 （请求 处理请求 参数、cookies、生成一个HTML响应）\n5. 服务器返回HTTP报文，发回一个HTML响应。\n6. 浏览器解析渲染页面，浏览器开始显示HTML。\n7. 连接结束\n\n使用的协议:\n\n**DNS**: 获取域名对应的IP TCP: 与服务器建立TCP连接\n\n**IP**: 建立TCP协议时，需要发送数据，发送数据在网络层上使用IP协议\n\n**OSPF**：IP数据包在路由器之间，路由选择使用OSPF协议\n\n**ARP**：路由器在与服务器进行通信的过程中，将IP地址装换成MAC地址\n\n**HTTP**：客户端浏览器与Web服务器之间的应用层通信协议，在TCP建立完成后，使用HTTP协议访问网页\n\n# 20.**网络层的ARP协议工作原理**\n\n​\t**网络层的ARP协议完成了IP地址与物理地址的映射**。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。\n\n# 21.电子邮件的发送过程?\n\n一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。\n\n邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。\n\n1. 用户A的邮箱是QQ邮箱，他要发往的邮箱是163邮箱，用户A写好一封邮件点击发送， 即提交到了QQ邮箱服务器，使用的是SMTP协议。\n2. QQ邮箱会对A发送邮件的收件地址进行解析，判断是否为内部邮箱的账号，如果也是QQ邮箱，会直接存储到自己的存储空间，如果不是则会发送到指定邮箱服务器，使用 的也是SMTP协议。\n3. 163的邮箱服务器收到邮件后会再次判断该邮件是否为自己的邮件，如果是则存到自己的存储空间，等待POP3服务去读取邮件。\n4. 用户B收到消息后，打开客户端访问163服务器，调用POP3服务。\n5. Pop3服务接到指令后，读取存储空间中发送给B的未读邮件服务。\n6. 将读取到的邮件返回给客户端软件。\n\n# 22.DNS解析过程，DNS劫持了解吗？\n\nDNS完成的工作是：域名到IP地址的解析。将域名和IP地址相互映射的一个分布式数据库。\n\n- 第一步：客户机提出域名解析请求，并将该请求发送给本地域名服务器。\n\n- 第二步：当本地域名服务器收到请求后，就先查询本地缓存，如果有该纪录项，则本地域名服务器就直接把查询结果返回。\n\n- 第三步：如果本地缓存中没该纪录，则本地域名服务器就直接把请求发给根域名服务器，然 后根域名服务器再返回给本地域名服务器一个所查询域(根子域)主域名服务器地址。\n\n- 第四步：本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自 己的缓存，如果没该纪录，则返回相关下级域名服务器地址。\n\n- 第五步：重复第四步，直到找到正确纪录。\n\n- 第六步：本地域名服务器把返回结果保存到缓存，以备下一次使用，同时还将结果返回给客 户机。\n\nDNS劫持：在DNS服务器中，将www..com的域名对应的IP地址进行了变化。你解析出来的 域名对应的IP，在劫持前后不一样。\n\nHTTP劫持：你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。\n\nDNS在区域传输的时候使用TCP协议,其他时候使用UDP协议。\n\n# 23.session和cookie的问题？\n\nCookie 和 Session都是用来跟踪浏览器用户身份的会话方式\n\nCookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录用户的状态\n\nCookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将Cookie 信息加密然后使用到的时候再去服务器端解密。\n\n# 24.HTTP是不保存状态的协议,如何保存用户状态?\n\nHTTP 是一种无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。主要通过session机制来进行解决，Session 的主要作用就是通过服务端记录用户的状态。\n\n在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下， 我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。\n\nps:**Cookie** 被禁用怎么办： 最常用的就是利用 URL 把 Session ID 直接附加在URL路径的后面。\n\n# 25.Session 与 Cookie 的对比\n\n- 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；\n\n- 大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；\n\n- 安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；\n\n- 服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。\n\n# 26.IP地址的划分\n\nIP 地址的编址方式经历了三个历史阶段：\n\n- 分类\n- 子网划分\n- 无分类\n\n## 1. 分类\n\n由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。\n\nIP 地址 ::= {< 网络号 >, < 主机号 >}\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png)\n\n- A类地址：以0开头，第一个字节范围：0~127；（地址范围1.0.0.0到127.255.255.255）\n- B类地址：以10开头，第一个字节范围：128~191；（地址范围128.0.0.0-191.255.255.255）\n- C类地址：以110开头，第一个字节范围：192~223；（地址范围192.0.0.0-223.255.255.255）\n- D类地址：以1110开头，第一个字节范围为224~239；（地址范围224.0.0.0到239.255.255.255。）\n- E类地址：以1111开头，保留地址\n\n## 2. 子网划分\n\n通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。\n\nIP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}\n\n要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。\n\n注意，外部网络看不到子网的存在。\n\n## 3. 无分类\n\n无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。\n\nIP 地址 ::= {< 网络前缀号 >, < 主机号 >}\n\nCIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。\n\nCIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。\n\n一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。\n\n在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。\n\n# 27.DDos攻击了解吗？\n\n分布式拒绝服务，一般来说是指攻击者利用一些被控制的设备对目标网站在较短的时间内发 起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。\n\n# 参考资料\n\n[1]https://leetcode-cn.com/circle/discuss/XXGdoF\n\n[2]https://blog.csdn.net/justloveyou_/article/details/78303617?spm=1001.2014.3001.5501\n\n[3]http://www.cyc2018.xyz/","tags":["面试"],"categories":["计算机网络"]},{"title":"操作系统面试知识点记录","url":"/2021/03/21/operating-system-interview/","content":"# 1.进程和线程的区别\n\n1）进程是资源分配的最小单位，线程是任务执行的最小单位。\n\n2）一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在。\n\n3）进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。\n\n4）线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。\n\n5）线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。\n\n6）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。\n\n速记：单位，依赖，内存，通信\n\n# 2.进程的调度算法\n\n不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。\n\n## 1. 批处理系统\n\n批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。\n\n**1.1 先来先服务 first-come first-serverd（FCFS）**\n\n非抢占式的调度算法，按照请求的顺序进行调度。\n\n有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。\n\n**1.2 短作业优先 shortest job first（SJF）**\n\n非抢占式的调度算法，按估计运行时间最短的顺序进行调度。\n\n长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。\n\n**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**\n\n最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。\n\n## 2. 交互式系统\n\n交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。\n\n**2.1 时间片轮转**\n\n将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。\n\n时间片轮转算法的效率和时间片的大小有很大关系：\n\n- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。\n- 而如果时间片过长，那么实时性就不能得到保证。\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png)\n\n\n\n**2.2 优先级调度**\n\n为每个进程分配一个优先级，按优先级进行调度。\n\n为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。\n\n**2.3 多级反馈队列**\n\n一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。\n\n多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。\n\n每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。\n\n可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png)\n\n\n\n## 3. 实时系统\n\n实时系统要求一个请求在一个确定时间内得到响应。\n\n分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。\n\n\n\n速记：先进先出，短作业优先，最短剩余时间优先，时间片轮转，优先级调度，多级反馈队列\n\n# 3.进程间通信的几种方式\n\n- 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；\n- 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n\n- 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；\n\n- 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；\n\n- 信号量：信号量是一个计数器，用于多进程对共享数据的访问。主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；\n\n- 套接字：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n# 4.线程通信的方式\n\n  a) 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。\n\n  b) 信号量(Semphares)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\n\n  c) 事件(Event):Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作\n\n# 5.什么是死锁？死锁产生的条件？\n\n  1)死锁的概念\n\n　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。\n\n2). 死锁产生的四个必要条件\n\n互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；\n\n占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；\n\n非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放\n\n循环等待：若干进程之间形成一种头尾相接的环形等待资源关系\n\n # 6.死锁处理策略\n\n1）死锁检测与死锁恢复\n\n1. 每种类型一个资源的死锁检测（找环）\n2. 每种类型多个资源的死锁检测（矩阵）\n3. 死锁恢复（利用抢占恢复，利用回滚恢复，通过杀死进程恢复）\n\n2）死锁预防\n\n死锁预防基本原理：破坏死锁发生的四个必要条件之一不成立。\n\n 1. 破坏互斥条件\n\n例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。\n\n2. 破坏占有和等待条件\n\n一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。\n\n3. 破坏不可抢占条件\n\n4. 破坏环路等待\n\n给资源统一编号，进程只能按编号顺序来请求资源。\n\n# 7.进程有哪几种状态\n\n- 就绪状态（ready）：等待被调度\n- 运行状态（running）\n- 阻塞状态（waiting）：等待资源\n\n应该注意以下内容：\n\n1. 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。\n2. 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。\n\n# 8.线程有几种状态\n\n在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：\n\n![线程的状态.jpg-59.9kB](http://static.zybuluo.com/Rico123/ot7o6218591iwj9py999hs1u/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg)\n\n# 9.虚拟内存\n\n**虚拟内存使得应用程序认为它拥有一个连续的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。**\n\n虚拟内存的**目的**是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。\n\n虚拟内存的**基本思想**是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。\n\n虚拟内存**优点**：\n\n- 在内存中可以保留多个进程，系统并发度提高\n\n- 解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大\n\n# 10.页面置换算法\n\n- FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；\n\n- LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；\n\n- LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；\n\n- OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。\n\n# 11.颠簸\n\n​\t\t颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。\n\n　　内存颠簸的解决策略包括：\n\n- 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；\n\n- 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；\n\n- 否则，还剩下两个办法：终止该进程或增加物理内存容量\n\n\n\n# 12.分页和分段有什么区别（内存管理）\n\n​\t\t段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）\n\n　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。\n\n​\t\t段页式：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。\n\n**两者的相同点：**\n\n分页机制和分段机制都是为了提高内存利用率，较少内存碎片。\n页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中 的内存是连续的。\n\n**两者的不同点：**\n\n- 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；\n- 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；\n- 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；\n- 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；\n- 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。\n- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。\n\n# 13.常用的IO模型\n\n- 阻塞式I/O：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n- 非阻塞式I/O：进程发起 IO 系统调用后，内核返回一个错误码而不会被阻塞；应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。如果内核缓冲区有数据，内核就会把数据返回进程。\n- I/O复用（select和poll)：使用 select 或者 poll 等待数据，可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后把数据从内核复制到进程中。\n- 信号驱动式I/O（SIGIO)：当进程发起一个 IO 操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用 IO 读取数据。\n- 异步I/O（aio_系列函数）：当进程发起一个 IO 操作，进程返回不阻塞，但也不能返回结果；内核把整个 IO 处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。\n\n# 14.select\n\nselect 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制，poll 中的描述符是 pollfd 类型的数组；\n\n# 15.fork函数的作用\n\n在 Linux 中 fork 函数是非常重要的函数，它的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程。\n\n**调用 fork(),当控制转移到内核中的 fork 代码后，内核开始做：**\n\n1. 分配新的内存块和内核数据结构给子进程。\n2. 将父进程部分数据结构内容拷贝至子进程。\n3. 将子进程添加到系统进程列表。\n4. fork返回开始调度器，调度。\n\n**特点：**\n\n1)调用一次，返回两次并发执行\n\n2)相同但是独立的地址空间\n\n3)fork 的返回值：fock 函数调用一次却返回两次；向父进程返回子进程的 ID，向子进程中返回 0，\n\n4)fork 的子进程返回为 0；\n\n5)父进程返回的是子进程的 pid。\n\n**fork 调用失败的原因**\n\n1)系统中有太多进程。\n\n2)实际用户的进程数超过限制。\n\n# 16.协程的概念\n\n**协程是一种用户态的轻量级线程，协程的调度完全由用户控制。**协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n\n对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。无论是进程还是线程，都是由操作系统所管理的。\n\n**协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行**。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。\n\n**协程既不是进程也不是线程，协程仅仅是一个特殊的函数**，协程它进程和进程不是一个维度的。\n\n一个进程可以包含多个线程，一个线程可以包含多个协程。\n\n一个线程内的多个协程虽然可以切换，但是**多个协程是串行执行的，只能在一个线程内运行，没法利用 CPU 多核能力。**\n\n协程与进程一样，切换是存在上下文切换问题的。\n\n# 17.linux 进程和线程？\n\n进程通过 fork()创建\n\n线程通过 pthread_create() 函数创建\n\n# 18. 通过进程id查看占用的端口，通过端口号查看占用的进程 id\n\n通过进程id查看占用的端口:\nnetstat -nap | grep 进程id\n通过端口号查看占用的进程id :\nnetstat -nap | grep 端口号\n\n# 19.僵尸进程产生的原因\n\n**僵尸进程是指它的父进程没有等待(调用 wait/waitpid)**。如果子进程先结束而父进程后结束，即子进程结束后，父进程还在继续运行但是并未调用 wait/waitpid 那子进程就会成为僵尸进程。但如果子进程后结束，即父进程先结束了，但没有调用 wait/waitpid 来等待子进程的结束， 此时子进程还在运行，父进程已经结束。那么并不会产生僵尸进程。应为每个进程结束时， 系统都会扫描当前系统中运行的所有进程，看看有没有哪个进程时刚刚结束的这个进程的子 进程，如果有就有 init 来接管它，成为它的父进程。\n\n**进程设置僵尸状态的目的是维护子进程的信息，以便父进程在以后某个时间获取**。要在当前 进程中生成一个子进程，一般需要调用 fork 这个系统调用，fork 这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，可以通过返回值来判断其 返回点。如果子进程先于父进程退出， 同时父进程又没有调用 wait/waitpid，则该子进程将成为僵尸进程。\n\n在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是 仍然保留了一些信息（如进程号 pid 退出状态 运行时间等）。这些保留的信息直到进程通过调用 wait/waitpid 时才会释放。这样就导致了一个问题，如果没有调用 wait/waitpid 的话，那 么保留的信息就不会释放。比如进程号就会被一直占用了。但系统所能使用的进程号的有限 的，如果产生大量的僵尸进程，将导致系统没有可用的进程号而导致系统不能创建进程。所 以我们应该避免僵尸进程。\n\n**如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用 的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。**\n\n# 20.孤儿进程产生的原因？\n\n孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤 儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，管理孤儿进程这个重任就落到了 init 进程身上，因此孤儿进程并 不会有什么危害。\n\n# 21.讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？\n\n操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序。根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：\n\n1. 用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。\n2. 内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。\n   运行的程序基本都是运行在用户态。如果我们调用操作系统提供的内核态级别的子功能那就需要系统调用了。\n\n系统调用：**与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都 必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。**\n\n系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。补充：\n\n用户态切换到内核态的几种方式\n\n**系统调用**: 系统调用是用户态主动要求切换到内核态的一种方式， 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。\n\n**异常**：当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。\n\n**硬件设备的中断**: 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核态的转换。\n\n# 22.平常用什么 linux 命令比较多\n\npwd:显示当前所在位置\n\nsudo + 其他命令：管理员身份运行\n\ngrep:需要搜索的字符串，要搜索的文件 --color： 搜索命令 --color表示高亮显示\n\nps -A：列出所有进程\n\nps -ef | grep 进程关键字\n\nkill 进程pid：杀死进程\n\nfind 目录 参数 ： 寻找目录（查）。在/home目录下查找以 .txt 结尾的文件名:find /home -name \"*.txt\" \n\nls ：查看目录信息\n\nfree：显示系统内存的使用情况\n\n# 23.中断的分类\n\n- 中断可以分为同步中断（synchronous）和异步中断(asynchronous)。\n\n- 中断可分为硬中断和软中断。\n\n- 中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。\n\n同步中断是在指令执行时由 CPU 主动产生的，受到 CPU 控制，其执行点是可控的。异步中断是 CPU 被动接收到的，由外设发出的电信号引起，其发生时间不可预测。\n\n# 24.软中断和硬中断\n\n从本质上讲，中断(硬)是一种电信号，当设备有某种事情发生的时候，他就会产生中断，通过 总线把电信号发送给中断控制器。如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，跳到中断处理程序的入口点， 进行中断处理。\n\n硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的 IRQ（中断请求）。\n\n软中断是由当前正在运行的进程所产生的。\n\n软中断比硬中断少了一个硬件发送信号的步骤。产生软中断的进程一定是当前正在运行的进 程，因此它们不会中断 CPU。但是它们会中断调用代码的流程。如果硬件需要 CPU 去做一些事情，那么这个硬件会使 CPU 中断当前正在运行的代码。\n\n# 参考资料\n\n[1]https://blog.csdn.net/justloveyou_/article/details/78304294\n\n[2]http://www.cyc2018.xyz/\n\n[3]https://leetcode-cn.com/circle/discuss/XXGdoF","categories":["操作系统"]},{"title":"算法复习","url":"/2021/03/20/java-suanfa/","content":"\n# 二分查找算法\n\n```java\npublic static int binarysearch(int []array,int a){\n    int low=0;\n    int mid;\n    int high=array.length-1;\n    while(low<=high){\n        mid=(low+high)/2;\n        if(array[mid]==a){\n            return mid;\n        }else if(a>array[mid]){\n            low=mid+1;\n        }else{\n            high=mid-1;\n        }\n    }\n    return -1;\n}\n```\n\n# 冒泡算法\n\n```java\npublic static int[] bubbleSort(int[] arr){\n\tfor(int i=0;i<arr.length-1;i++){\n\t\tfor(int j=0;j<arr.length-1-i;j++){\n\t\t\tif(arr[j]>arr[j+1]){\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j]=arr[j+1];\n\t\t\t\tarr[j+1]=temp;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n}\n```\n\n# 插入排序\n\n```java\npublic static int[] insertSort(int[] arr){\n\tfor(int i=1;i<arr.length;i++){\n\t\tint insertVal=arr[i];\n\t\tint index=i-1;\n\t\twhile(index>=0&&insertVal<arr[index]){\n\t\t\tarr[index+1]=arr[index];\n\t\t\tindex--;\n\t\t}\n\t\tarr[index+1]=insertVal;\n\t}\n    return arr;\n}\n```\n\n# 快速排序\n\n```java\npublic static int []quickSort(int []arr,int low,int high){\n\tint start=low;\n\tint end=high;\n\tint key=arr[start];\n\twhile(end>start){\n\t\twhile(end>start&&arr[end]>=key){\n\t\t\tend--;//找到比key小的值\n\t\t}\n\t\tif(arr[end]<=key){\n\t\t\tint temp=arr[end];\n\t\t\tarr[end]=arr[start];\n\t\t\tarr[start]=temp;\n\t\t}\n\t\twhile(end>start&&arr[start]<=key){\n\t\t\tstart++;\n\t\t}\n\t\tif(arr[start]>=key){\n\t\t\tint temp=arr[start];\n\t\t\tarr[start]=arr[end];\n\t\t\tarr[end]=temp;\n\t\t}\n\t}\n\t//递归左边序列\n\tif(start>low){\n\t\tquickSort(arr,low,start-1);\n\t}\n    //递归右边序列-+4\n\tif(end<high){\n\t\tquickSort(arr.end+1,high);\n\t}\n\treturn arr;\n}\n```\n\n","categories":["Java"]},{"title":"自己写输入输出问题","url":"/2021/03/20/javacode-io/","content":"# 1. 基本定义\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n    public static void main(String[] args){\n\t\tScanner cin1 = new Scanner(System.in);\n        Scanner cin2 = new Scanner(new BufferedInputStream(System.in));\n    }\n}\n```\n\n使用cin2进行输入的时候会比cin1快一些。\n\n# 2. 输入具体数据\n\n```java\nint n = cin.nextInt();//输入一个整数\nString s = cin.next();//输入一个字符串\ndouble f = cin.nextDouble();//输入一个浮点数\nString s = cin.nextLine();//输入一整行\n```\n\n可以使用cin.hasNext()来判断是否有下一个输入\n\n# 3. 基本输出\n\n```java\nSystem.out.print();  //类似于cout<<…….;\n\nSystem.out.println();  //类似于cout<<……<<endl;\n\nSystem.out.printf();  //类似于C中printf的功能\n```\n\n# 4. 要求具体精度输出\n\n（1）可以使用上面介绍的System.out.printf();\n\n（2）对于输出浮点数要保留几位小数的问题，可以使用DecimalFormat类解决\n\n```java\ndouble pi = 3.1415927;//圆周率\n//取一位整数\nSystem.out.println(new DecimalFormat(\"0\").format(pi));//3\n//取一位整数和两位小数\nSystem.out.println(new DecimalFormat(\"0.00\").format(pi));//3.14\n//取两位整数和三位小数，整数不足部分以0填补。\nSystem.out.println(new DecimalFormat(\"00.000\").format(pi));// 03.142\n//取所有整数部分\nSystem.out.println(new DecimalFormat(\"#\").format(pi));//3\n//以百分比方式计数，并取两位小数\nSystem.out.println(new DecimalFormat(\"#.##%\").format(pi));//314.16%\n```\n\n# 5. 字符串的处理\n\nString。Java中字符串String是不可以修改的，要修改只能转换为字符数组。\n\n```java\nString st = \"abcdefg\";\n\nchar[] ch;\n\nch = st.toCharArray(); // 字符串转换为字符数组.\n```\n# 6. 实例\n```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\npublic class Main {\npublic static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] params = br.readLine().trim().split(\" \");\n        int n = Integer.parseInt(params[0]);\n        int x = Integer.parseInt(params[1]);\n        int y = Integer.parseInt(params[2]);\n        String[] strArr = br.readLine().trim().split(\" \");\n        int[] scores = new int[n];\n        for(int i = 0; i < n; i++) scores[i] = Integer.parseInt(strArr[i]);\n }\n}\n```\n有输入输出写法：\n\n```java\nimport java.io.*;\nimport java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) throws IOException{\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n        int T = Integer.parseInt(reader.readLine());\n        for (int i = 0; i < T; i++) {\n            int N = Integer.parseInt(reader.readLine());\n            String tables = reader.readLine();\n            int M = Integer.parseInt(reader.readLine());\n            String enters = reader.readLine();\n \n            int[] res = solve(tables, enters);\n            for (int r : res) {\n                writer.write(Integer.toString(r));\n                writer.newLine();\n            }\n        }\n        writer.flush();\n    }\n}\n```\n\n","categories":["Java"]},{"title":"HTML学习","url":"/2021/03/18/html-learning/","content":"# HTML简介\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>html learning</title>\n</head>\n<body>\n \n<h1>标题一</h1>\n \n<p>段落一</p>\n \n</body>\n</html>\n```\n\n\n- !DOCTYPE html 声明为 HTML5 文档\n- html 元素是 HTML 页面的根元素\n- head元素包含了文档的元（meta）数据，如 meta charset=\"utf-8\"定义网页编码格式为 **utf-8**。\n  \n只有 body区域 (白色部分) 才会在浏览器中显示。\n\n# HTML 基础\n\nHTML 标题（Heading）是通过h1-h6标签来定义的。\n\n```html\n<h1>\n    标题一\n</h1>\n```\n\n\n\nHTML 段落是通过标签 p 来定义的。\n\n```html\n<p>\n    段落一\n</p>\n```\n\n\n\nHTML 链接是通过标签 a来定义的。\n\n```html\n<a href=\"https://\">\n   链接一\n</a>\n```\n\nHTML 图像是通过标签 img 来定义的。\n\n```html\n<img loading=\"porrige\" src=\"/images/logo.jpg\" width=\"258\" height=\"39\" />\n```\n\n\n\n# HTML元素\n\n如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 br标签：\n```html\n<br>\n```\n\n# HTML属性\n\n| 属性  | 描述                                                         |\n| ----- | ------------------------------------------------------------ |\n| class | 为html元素定义一个或多个类名（classname）(类名从样式文件引入) |\n| id    | 定义元素的唯一id                                             |\n| style | 规定元素的行内样式（inline style）                           |\n| title | 描述了元素的额外信息 (作为工具条使用)                        |\n\n# HTML标题\n\n标题（Heading）是通过 h1-h6标签进行定义的。\n\nh1定义最大的标题（主要）。 h6定义最小的标题（次要）。\n\n## HTML水平线\n\nhr标签在 HTML 页面中创建水平线。\n\nhr 元素可用于分隔内容。\n\n## HTML 注释\n\n```html\n<!-- 注释 -->\n```","categories":["HTML"]},{"title":"网络编程","url":"/2021/03/18/network-coding/","content":"\n# IP\n\nip地址：InetAddress\n\n- 127.0.0.1 ：本机localhost\n\n- ip地址的分类\n- - ipv4/ipv6\n  - - IPV4 4个字节组成\n    - IPV6 128位，8个无符号整数\n- \n\n\n\n"},{"title":"try to upload","url":"/2021/03/17/try-to-upload/","content":"![pjl](/images/pasted-210317pjl.jpg)\n![pjl](/images/pasted-210317whz.jpg)\n\n"},{"title":"兄弟们冲冲冲！","url":"/2021/03/16/first blog/","content":"# 欢迎来到我的blog\n然后懒人表示什么都没有更新！\n记得别咸鱼！"}]