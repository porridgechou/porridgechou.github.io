[{"title":"链表","url":"/2021/03/24/210324javaList/","content":"<h1 id=\"两数相加\"><a href=\"#两数相加\" class=\"headerlink\" title=\"两数相加\"></a>两数相加</h1><p><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">2.两数相加</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">    \tListNode head=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    \tListNode temp=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(l1!=<span class=\"keyword\">null</span>||l2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">int</span> n1 = l1!=<span class=\"keyword\">null</span> ? l1.val: <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n2 = l2!=<span class=\"keyword\">null</span> ? l2.val: <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = n1 + n2 + flag;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t\t\thead=temp=<span class=\"keyword\">new</span> ListNode(sum%<span class=\"number\">10</span>);</span><br><span class=\"line\">    \t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \t\t\ttemp.next=<span class=\"keyword\">new</span> ListNode(sum%<span class=\"number\">10</span>);</span><br><span class=\"line\">    \t\t\ttemp=temp.next;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\tflag=sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">    \t\t</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(l1!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t\t\tl1=l1.next;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(l2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t\t\tl2=l2.next;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(flag&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \t\ttemp.next=<span class=\"keyword\">new</span> ListNode(flag);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:注意空指针问题！</p>\n<h1 id=\"找出两个链表的交点\"><a href=\"#找出两个链表的交点\" class=\"headerlink\" title=\"找出两个链表的交点\"></a>找出两个链表的交点</h1><p> <a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">160. 相交链表</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">        ListNode l1=headA;</span><br><span class=\"line\">        ListNode l2=headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1!=l2)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                l1=headB;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                l1=l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l2==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                l2=headA;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                l2=l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"翻转链表\"><a href=\"#翻转链表\" class=\"headerlink\" title=\"翻转链表\"></a>翻转链表</h1><p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">206. 反转链表</a></p>\n<p>反转一个单链表。</p>\n<p><img src=\"https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode pre=head;</span><br><span class=\"line\">        ListNode cur=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pre!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            ListNode temp=pre.next;</span><br><span class=\"line\">            pre.next=cur;</span><br><span class=\"line\">            cur=pre;</span><br><span class=\"line\">            pre=temp;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span>||head.next==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode cur=reverseList(head.next);</span><br><span class=\"line\">        head.next.next=head;</span><br><span class=\"line\">        head.next=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"合并两个有序链表\"><a href=\"#合并两个有序链表\" class=\"headerlink\" title=\"合并两个有序链表\"></a>合并两个有序链表</h1><p> <a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\">21. 合并两个有序链表</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode nhead =<span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        ListNode temp=nhead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1!=<span class=\"keyword\">null</span>&amp;&amp;l2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class=\"line\">                temp.next=l1;</span><br><span class=\"line\">                l1=l1.next;</span><br><span class=\"line\">                temp=temp.next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                temp.next=l2;</span><br><span class=\"line\">                l2=l2.next;</span><br><span class=\"line\">                temp=temp.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l1!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                temp.next=l1;</span><br><span class=\"line\">                l1=l1.next;</span><br><span class=\"line\">                temp=temp.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            temp.next=l2;</span><br><span class=\"line\">            l2=l2.next;</span><br><span class=\"line\">            temp=temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nhead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["算法"]},{"title":"位运算","url":"/2021/03/24/210324weiyunsuan/","content":"<h1 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h1><p>0s 表示一串 0，1s 表示一串 1。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">x ^ 0s = x      x &amp; 0s = 0      x | 0s = x</span><br><span class=\"line\">x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s</span><br><span class=\"line\">x ^ x = 0       x &amp; x = x       x | x = x</span><br></pre></td></tr></table></figure>\n\n<p>利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">1^1^2 = 2</span><br></pre></td></tr></table></figure>\n\n<p>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 &amp;</span><br><span class=\"line\">00111100</span><br><span class=\"line\">--------</span><br><span class=\"line\">00011000</span><br></pre></td></tr></table></figure>\n\n<p>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 |</span><br><span class=\"line\">00111100</span><br><span class=\"line\">--------</span><br><span class=\"line\">01111111</span><br></pre></td></tr></table></figure>\n\n<p><strong>位与运算技巧</strong></p>\n<p>n&amp;(n-1) 去除 n 的位级表示中<strong>最低</strong>的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 &amp;</span><br><span class=\"line\">01011010</span><br><span class=\"line\">--------</span><br><span class=\"line\">01011010</span><br></pre></td></tr></table></figure>\n\n<p>n&amp;(-n) 得到 n 的位级表示中<strong>最低</strong>的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">10110100 &amp;</span><br><span class=\"line\">01001100</span><br><span class=\"line\">--------</span><br><span class=\"line\">00000100</span><br></pre></td></tr></table></figure>\n\n<p>n-(n&amp;(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&amp;(n-1) 效果一样。</p>\n<p><strong>移位运算</strong></p>\n<p>&gt;&gt; n 为算术右移，相当于除以 2n，例如 -7 &gt;&gt; 2 = -2。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &gt;&gt; 2</span><br><span class=\"line\">--------</span><br><span class=\"line\">11111111111111111111111111111110</span><br></pre></td></tr></table></figure>\n\n<p>&gt;&gt;&gt; n 为无符号右移，左边会补上 0。例如 -7 &gt;&gt;&gt; 2 = 1073741822。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &gt;&gt;&gt; 2</span><br><span class=\"line\">--------</span><br><span class=\"line\">00111111111111111111111111111111</span><br></pre></td></tr></table></figure>\n\n<p>&lt;&lt; n 为算术左移，相当于乘以 2n。-7 &lt;&lt; 2 = -28。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &lt;&lt; 2</span><br><span class=\"line\">--------</span><br><span class=\"line\">11111111111111111111111111100100</span><br></pre></td></tr></table></figure>\n\n<p><strong>mask 计算</strong></p>\n<p>要获取 111111111，将 0 取反即可，~0。</p>\n<p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p>\n<p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111。</p>\n<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p>\n<p><strong>Java 中的位操作</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">static int Integer.bitCount();           // 统计 1 的数量</span><br><span class=\"line\">static int Integer.highestOneBit();      // 获得最高位</span><br><span class=\"line\">static String toBinaryString(int i);     // 转换为二进制表示的字符串</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"汉明距离\"><a href=\"#汉明距离\" class=\"headerlink\" title=\"汉明距离\"></a>汉明距离</h1><p><a href=\"https://leetcode-cn.com/problems/hamming-distance/\">461.汉明距离</a></p>\n<p>两个整数之间的<a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> z=x^y;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(z!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((z&amp;<span class=\"number\">1</span>)==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            z=z &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:采取异或的方法看有哪几位是不同的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> z=x^y;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(z!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            z&amp;=(z-<span class=\"number\">1</span>);</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ps：通过z&amp;(z-1)来清除最低位的1。</p>\n<h1 id=\"只出现一次的数字\"><a href=\"#只出现一次的数字\" class=\"headerlink\" title=\"只出现一次的数字\"></a>只出现一次的数字</h1><p><a href=\"https://leetcode-cn.com/problems/single-number/\">136.只出现一次的数字</a></p>\n<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num: nums)&#123;</span><br><span class=\"line\">            ret=ret^num;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"只出现一次的数字III\"><a href=\"#只出现一次的数字III\" class=\"headerlink\" title=\"只出现一次的数字III\"></a>只出现一次的数字III</h1><p><a href=\"https://leetcode-cn.com/problems/single-number-iii/\">260.只出现一次的数字III</a></p>\n<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] singleNumber(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> div=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num:nums)&#123;</span><br><span class=\"line\">            div^=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        div&amp;=-div;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans=&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num:nums)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((div&amp;num)==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                ans[<span class=\"number\">0</span>]=ans[<span class=\"number\">0</span>]^num;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                ans[<span class=\"number\">1</span>]=ans[<span class=\"number\">1</span>]^num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps：通过z&amp;(-z)获得中<strong>最低</strong>的那一位</p>\n<h1 id=\"丢失的数字\"><a href=\"#丢失的数字\" class=\"headerlink\" title=\"丢失的数字\"></a>丢失的数字</h1><p><a href=\"https://leetcode-cn.com/problems/missing-number/\">268.丢失的数字</a></p>\n<p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> target=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=nums.length ;i++ ) &#123;</span><br><span class=\"line\">            target=target^i^nums[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:采用的就是x^x=0的思想</p>\n<h1 id=\"颠倒二进制位\"><a href=\"#颠倒二进制位\" class=\"headerlink\" title=\"颠倒二进制位\"></a>颠倒二进制位</h1><p> <a href=\"https://leetcode-cn.com/problems/reverse-bits/\">190. 颠倒二进制位</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">32</span>;i++)&#123;</span><br><span class=\"line\">            ret=ret&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">            ret |=(n&amp;<span class=\"number\">1</span>);</span><br><span class=\"line\">            n=n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:借助n&amp;1是最后一位，然后进行操作。</p>\n<h1 id=\"2的幂\"><a href=\"#2的幂\" class=\"headerlink\" title=\"2的幂\"></a>2的幂</h1><p> <a href=\"https://leetcode-cn.com/problems/power-of-two/\">231. 2的幂</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n&gt;<span class=\"number\">0</span> &amp;&amp; (n&amp;(n-<span class=\"number\">1</span>))==<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:使用n&amp;(n-1)为去除最低的1。</p>\n<h1 id=\"比特位计数\"><a href=\"#比特位计数\" class=\"headerlink\" title=\"比特位计数\"></a>比特位计数</h1><p> <a href=\"https://leetcode-cn.com/problems/counting-bits/\">338. 比特位计数</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countBits(<span class=\"keyword\">int</span> num) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ret=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[num+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=num;i++)&#123;</span><br><span class=\"line\">            ret[i]=ret[i&amp;(i-<span class=\"number\">1</span>)]+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ps:还是采用了i&amp;(i-1)为最低位的1思想。</p>\n","categories":["算法"],"tags":["位运算"]},{"title":"常见数据结构时间复杂度","url":"/2021/03/26/210326cjdatabase/","content":"<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ul>\n<li>添加：O(1)</li>\n<li>删除：O(n）</li>\n<li>修改：O(1)</li>\n<li>查询：O(n)</li>\n<li>尺寸：O(1)</li>\n</ul>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><ul>\n<li>插入：O(1)，如果需要查找再插入则O(n)</li>\n<li>删除：O(1)，如果需要查找再删除则O(n)</li>\n<li>搜索：O(n)</li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li>推：O（1）</li>\n<li>Pop：O（1）</li>\n<li>上：O（1）</li>\n<li>搜索（像查找，像一个特殊的操作）：O（n）</li>\n</ul>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li>插入：O（1）</li>\n<li>删除：O（1）</li>\n<li>尺寸：O（1）</li>\n</ul>\n<h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><ul>\n<li>查找：O（1）</li>\n<li>插入：O（1）</li>\n<li>删除：可根据链表输入长度决定，在最坏情况下，链表长度为n，时间复杂度就为O（n）</li>\n</ul>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>最佳</th>\n<th>平均</th>\n<th>最差</th>\n<th>最差情况下的空间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>快速排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n*n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(nlogn)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>冒泡排序</td>\n<td>O(n)</td>\n<td>O(n*n)</td>\n<td>O(n*n)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>O(n)</td>\n<td>O(n*n)</td>\n<td>O(n*n)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>O(n*n)</td>\n<td>O(n*n)</td>\n<td>O(n*n)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>桶排序</td>\n<td>O(n+k)</td>\n<td>O(n+k)</td>\n<td>O(n*n)</td>\n<td>O(nk)</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>O(nk)</td>\n<td>O(nk)</td>\n<td>O(nk)</td>\n<td>O(n+k)</td>\n</tr>\n</tbody></table>\n<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>平均</th>\n<th>最差</th>\n<th>最差空间复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>深度优先搜索(DFS)</td>\n<td>-</td>\n<td>O(E+V)</td>\n<td>O(V)</td>\n</tr>\n<tr>\n<td>广度优先搜索(BFS)</td>\n<td>-</td>\n<td>O(E+V)</td>\n<td>O(V)</td>\n</tr>\n<tr>\n<td>二分查找</td>\n<td>O(logn)</td>\n<td>O(logn)</td>\n<td>O(1)</td>\n</tr>\n</tbody></table>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://www.jianshu.com/p/99ae14b48c0f\">https://www.jianshu.com/p/99ae14b48c0f</a></p>\n"},{"title":"数据结构","url":"/2021/03/26/210326datastructure/","content":"<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h2 id=\"二叉树查找的时间复杂度\"><a href=\"#二叉树查找的时间复杂度\" class=\"headerlink\" title=\"二叉树查找的时间复杂度\"></a>二叉树查找的时间复杂度</h2><p>如果<strong>二叉排序树是平衡</strong>的，则n个节点的二叉排序树的高度为Log2(n+1),其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。</p>\n<h2 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">PreOrder</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.printIn(root);</span><br><span class=\"line\">    PreOrder(root.left);</span><br><span class=\"line\">    PreOrder(root.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">\tList&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\tStack&lt;TreeNode&gt; stack =<span class=\"keyword\">new</span> Stack &lt;&gt;();</span><br><span class=\"line\">\tstack.push(root);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">\t\tTreeNode node =stack.pop();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(node==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tret.add(node.val);</span><br><span class=\"line\">\t\tstack.push(node.right);<span class=\"comment\">//先右后左，保证左子树先出来</span></span><br><span class=\"line\">\t\tstack.push(node.left);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    dfs(root.left);</span><br><span class=\"line\">    dfs(root.right);</span><br><span class=\"line\">    visit(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode node = stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        ret.add(node.val);</span><br><span class=\"line\">        stack.push(node.left);</span><br><span class=\"line\">        stack.push(node.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Collections.reverse(ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一种写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        TreeNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right == <span class=\"keyword\">null</span> || root.right == prev) &#123;</span><br><span class=\"line\">                res.add(root.val);</span><br><span class=\"line\">                prev = root;</span><br><span class=\"line\">                root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    dfs(root.left);</span><br><span class=\"line\">    visit(root);</span><br><span class=\"line\">    dfs(root.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    TreeNode cur = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(cur);</span><br><span class=\"line\">            cur = cur.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode node = stack.pop();</span><br><span class=\"line\">        ret.add(node.val);</span><br><span class=\"line\">        cur = node.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h1>"},{"title":"竞技世界面试复盘","url":"/2021/03/29/210329jjworldfupan/","content":"<h1 id=\"RAM和ROM\"><a href=\"#RAM和ROM\" class=\"headerlink\" title=\"RAM和ROM\"></a>RAM和ROM</h1><p>RAM（random access memory）即随机存储内存，这种存储器在断电时将丢失其存储内容，故主要用于存储短时间使用的程序。ROM（Read-Only Memory）即只读内存，是一种只能读出事先所存数据的固态半导体存储器。</p>\n<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><p>虚拟内存是操作系统内核为了对进程地址空间进行管理（process address space management）而精心设计的一个逻辑意义上的内存空间概念。</p>\n<p>用户编制程序时使用的地址称为<strong>虚地址或逻辑地址</strong>，其对应的存储空间称为虚存空间或逻辑地址空间；而计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。</p>\n<p><strong>引入虚拟存储技术的好处</strong>：<br>可在较小的可用内存中执行较大的用户程序；<br>可在内存中容纳更多程序并发执行；<br>不必影响编程时的程序结构（与覆盖技术比较）；</p>\n<p>提供给用户可用的虚拟内存空间通常大于物理内存。</p>\n<h1 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h1><p>理论上<em>SMTP</em>可以通过TCP,UDP或某些第三方协议来处理</p>\n<p>DHCP 用的是UDP</p>\n<h1 id=\"数据库主键\"><a href=\"#数据库主键\" class=\"headerlink\" title=\"数据库主键\"></a>数据库主键</h1><p><em>主键</em>只有一个,但是可以设置为多个字段为<em>主键</em>,也即联合<em>主键</em>。</p>\n<h1 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] quicksort(<span class=\"keyword\">int</span> []arr,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = high;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> key = arr[start];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(end &gt; start)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(end &gt; start&amp;&amp;arr[end]&gt;=key)&#123;</span><br><span class=\"line\">            end--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[end]&lt;=key)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp=arr[end];</span><br><span class=\"line\">            arr[end]=arr[start];</span><br><span class=\"line\">            arr[start]=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(end&gt;start&amp;&amp;arr[start]&lt;=key)&#123;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[start]&gt;=key)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> temp=arr[start];</span><br><span class=\"line\">            arr[start]=arr[end];</span><br><span class=\"line\">            arr[end]=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h1><p>使用哈夫曼编码来编码字符串”aaaabbcd”时，得到的编码长度为多少?</p>\n<p><a href=\"https://blog.csdn.net/weixin_43247186/article/details/87855415\">https://blog.csdn.net/weixin_43247186/article/details/87855415</a></p>\n<h1 id=\"字节\"><a href=\"#字节\" class=\"headerlink\" title=\"字节\"></a>字节</h1><p><em>字节是</em>一个存储单位 1个二进制位等于1Bit 8个Bit等于<em>1Byte</em>(字节)</p>\n<p>C语言会自动在在双引号””括起来的内容的末尾补上”\\0”代表结束，ASCII中的0号位也占用一个字符。</p>\n<p>注意，了解了sizeof的真正含义后。类似如下的代码就很low了。</p>\n<h1 id=\"大小端\"><a href=\"#大小端\" class=\"headerlink\" title=\"大小端\"></a>大小端</h1><p><strong>（数据看成字符串）</strong>大端——高尾端，小端——低尾端</p>\n<p>我们的电脑通常是小端存储</p>\n<h2 id=\"大小端各自的优点\"><a href=\"#大小端各自的优点\" class=\"headerlink\" title=\"大小端各自的优点\"></a>大小端各自的优点</h2><p>大端：符号位在所表示的内存的低地址，用于快速判断数据的正负和大小<br>小端：CPU做数值运算的时候是从内存中依次从低位到高位取数据进行运算，这样运算效率更高。</p>\n<h1 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h1><p>并发是指一个处理器同时处理多个任务。<br>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。<br>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。<br>来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。</p>\n<p>当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。</p>\n<p>当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]并发并行的区别<a href=\"https://blog.csdn.net/java_zero2one/article/details/51477791\">https://blog.csdn.net/java_zero2one/article/details/51477791</a></p>\n"},{"title":"Java常用集合类","url":"/2021/04/04/210404Java-jihelei/","content":"<h1 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h1><p>inkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p>\n<h2 id=\"新建队列\"><a href=\"#新建队列\" class=\"headerlink\" title=\"新建队列\"></a><strong>新建队列</strong></h2><p>Queue<String> queue=new LinkedList<Steing>;</p>\n<h2 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a><strong>添加元素</strong></h2><p>queue.offer(“a”);</p>\n<h2 id=\"返回第一个元素，并在队列中删除\"><a href=\"#返回第一个元素，并在队列中删除\" class=\"headerlink\" title=\"返回第一个元素，并在队列中删除\"></a><strong>返回第一个元素，并在队列中删除</strong></h2><p>queue.poll();</p>\n<h2 id=\"返回第一个元素\"><a href=\"#返回第一个元素\" class=\"headerlink\" title=\"返回第一个元素\"></a><strong>返回第一个元素</strong></h2><p>queue.element();</p>\n<p>或者</p>\n<p>queue.peek();</p>\n<h1 id=\"Deque\"><a href=\"#Deque\" class=\"headerlink\" title=\"Deque\"></a><strong>Deque</strong></h1><p>双端队列（两端都可进出）</p>\n<h2 id=\"新建\"><a href=\"#新建\" class=\"headerlink\" title=\"新建\"></a><strong>新建</strong></h2><p>Deque<String>  deque= new LinkList&lt;&gt;();</p>\n<h2 id=\"相关函数\"><a href=\"#相关函数\" class=\"headerlink\" title=\"相关函数\"></a><strong>相关函数</strong></h2><p><img src=\"/images/pasted-210404.jpg\"></p>\n<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><h2 id=\"新建-1\"><a href=\"#新建-1\" class=\"headerlink\" title=\"新建\"></a><strong>新建</strong></h2><p>ArrayList<String> arraylist=new ArrayList<String>();</p>\n<h2 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a><strong>访问元素</strong></h2><p>arraylist.get(0);//访问第1个元素</p>\n<h2 id=\"修改元素\"><a href=\"#修改元素\" class=\"headerlink\" title=\"修改元素\"></a><strong>修改元素</strong></h2><p>arraylist.set(2,”wiki”);</p>\n<h2 id=\"计算大小\"><a href=\"#计算大小\" class=\"headerlink\" title=\"计算大小\"></a><strong>计算大小</strong></h2><p>arraylist.size();</p>\n<h2 id=\"ArrayList排序\"><a href=\"#ArrayList排序\" class=\"headerlink\" title=\"ArrayList排序\"></a><strong>ArrayList排序</strong></h2><p>Collections.sort(arraylist);</p>\n<h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a><strong>LinkedList</strong></h1><h2 id=\"与ArrayList的使用对比\"><a href=\"#与ArrayList的使用对比\" class=\"headerlink\" title=\"与ArrayList的使用对比\"></a><strong>与ArrayList的使用对比</strong></h2><p>以下情况使用 ArrayList :</p>\n<p>频繁访问列表中的某一个元素。</p>\n<p>只需要在列表末尾进行添加和删除元素操作。</p>\n<p>以下情况使用 LinkedList :</p>\n<p>你需要通过循环迭代来访问列表中的某些元素。</p>\n<p>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</p>\n<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a><strong>创建</strong></h2><p>LinkList<E> list=new LinkList<E>();</p>\n<h2 id=\"开头添加-移除-获取元素\"><a href=\"#开头添加-移除-获取元素\" class=\"headerlink\" title=\"开头添加/移除/获取元素\"></a><strong>开头添加/移除/获取元素</strong></h2><p>list.addFirst(“Wiki”);</p>\n<p>list.removeFirst();</p>\n<p>list.getFirst();</p>\n<h2 id=\"结尾添加元素\"><a href=\"#结尾添加元素\" class=\"headerlink\" title=\"结尾添加元素\"></a><strong>结尾添加元素</strong></h2><p>list.addLast(“hello”);</p>\n<p>list.removeLast();</p>\n<p>list.getLast();</p>\n<h1 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h1><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>\n<p>HashSet 允许有 null 值。</p>\n<p>HashSet 是无序的，即不会记录插入的顺序。</p>\n<p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p>\n<p>HashSet 实现了 Set 接口。</p>\n<h2 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a><strong>创建</strong></h2><p>HashSet<String> hashset=new HashSet<String>();</p>\n<h2 id=\"添加元素-1\"><a href=\"#添加元素-1\" class=\"headerlink\" title=\"添加元素\"></a><strong>添加元素</strong></h2><p>hashset.add(“Google”);</p>\n<p>注意，重复的元素不会被添加。</p>\n<h2 id=\"判断元素是否存在\"><a href=\"#判断元素是否存在\" class=\"headerlink\" title=\"判断元素是否存在\"></a><strong>判断元素是否存在</strong></h2><p>hashset.contains(“TaoBao”);</p>\n<h2 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a><strong>删除元素</strong></h2><p>hashset.remove(“TaoBao”);</p>\n<h2 id=\"计算大小-1\"><a href=\"#计算大小-1\" class=\"headerlink\" title=\"计算大小\"></a><strong>计算大小</strong></h2><p>hashset.size();</p>\n<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a><strong>HashMap</strong></h1><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>\n<p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p>\n<p>HashMap 是无序的，即不会记录插入的顺序。</p>\n<p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p>\n<h2 id=\"新建-2\"><a href=\"#新建-2\" class=\"headerlink\" title=\"新建\"></a><strong>新建</strong></h2><p>HashMap&lt;Integer,String&gt; Sites=new HashMap&lt;Integer,String&gt;();</p>\n<h2 id=\"添加元素-2\"><a href=\"#添加元素-2\" class=\"headerlink\" title=\"添加元素\"></a><strong>添加元素</strong></h2><p>Sites.put(1,”Google”);</p>\n<h2 id=\"访问元素-1\"><a href=\"#访问元素-1\" class=\"headerlink\" title=\"访问元素\"></a><strong>访问元素</strong></h2><p>Sites.get(1);</p>\n<p>使用get方法来获取key对应的value</p>\n<h2 id=\"删除元素-1\"><a href=\"#删除元素-1\" class=\"headerlink\" title=\"删除元素\"></a><strong>删除元素</strong></h2><p>Sites.remove(1);</p>\n<p>使用 remove(key) 方法来删除 key 对应的键值对(key-value)</p>\n<p>删除所有键值对可以使用clear方法</p>\n<p>Sites.clear();</p>\n<h2 id=\"计算大小-2\"><a href=\"#计算大小-2\" class=\"headerlink\" title=\"计算大小\"></a><strong>计算大小</strong></h2><p>Sites.size();</p>\n<h2 id=\"存在key-value\"><a href=\"#存在key-value\" class=\"headerlink\" title=\"存在key/value\"></a><strong>存在key/value</strong></h2><p>Sites.containsKey(1);</p>\n<p>Sites.containsValue(“Google”);</p>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>迭代HashMap:如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。</p>\n<h2 id=\"返回或者默认值\"><a href=\"#返回或者默认值\" class=\"headerlink\" title=\"返回或者默认值\"></a>返回或者默认值</h2><p>获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值：getOrDefault()</p>\n<h1 id=\"Java-Stack\"><a href=\"#Java-Stack\" class=\"headerlink\" title=\"Java Stack\"></a><strong>Java Stack</strong></h1><h2 id=\"新建-3\"><a href=\"#新建-3\" class=\"headerlink\" title=\"新建\"></a><strong>新建</strong></h2><p>Stack<Integer> st=new Stack<Integer>();</p>\n<h2 id=\"常见方法\"><a href=\"#常见方法\" class=\"headerlink\" title=\"常见方法\"></a>常见方法</h2><p><img src=\"/images/pasted-210404stack.jpg\"></p>\n<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><h2 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h2><p>length()</p>\n<h2 id=\"连接字符串\"><a href=\"#连接字符串\" class=\"headerlink\" title=\"连接字符串\"></a>连接字符串</h2><p>concat()</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><p>charAt(int index) ：返回指定索引处的 char 值。</p>\n<p>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引。</p>\n<p><a href=\"https://www.runoob.com/java/java-string-indexof.html\"> int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p>\n<h1 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h1><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">方法描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">public delete(int start, int end) 移除此序列的子字符串中的字符。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>\n</tr>\n</tbody></table>\n","categories":["Java"]},{"title":"阿里面经","url":"/2021/05/10/Alimianjing210510/","content":"<h2 id=\"阿里一面\"><a href=\"#阿里一面\" class=\"headerlink\" title=\"阿里一面\"></a>阿里一面</h2><h2 id=\"图的数据结构，讲一下遍历方式\"><a href=\"#图的数据结构，讲一下遍历方式\" class=\"headerlink\" title=\"图的数据结构，讲一下遍历方式\"></a>图的数据结构，讲一下遍历方式</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 无向简单图的节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> hoaven</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GraphNode</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">    List&lt;GraphNode&lt;T&gt;&gt; neighborList;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> visited;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GraphNode</span><span class=\"params\">(T data)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">        neighborList = <span class=\"keyword\">new</span> ArrayList&lt;GraphNode&lt;T&gt;&gt;();</span><br><span class=\"line\">        visited = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(GraphNode&lt;T&gt; node)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.equals(node.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 还原图中所有节点为未访问</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">restoreVisited</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        restoreVisited(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 还原node的图所有节点为未访问</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> node</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">restoreVisited</span><span class=\"params\">(GraphNode&lt;T&gt; node)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node.visited)&#123;</span><br><span class=\"line\">            node.visited = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;GraphNode&lt;T&gt;&gt; neighbors = node.neighborList;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; neighbors.size(); i++)&#123;</span><br><span class=\"line\">            restoreVisited(neighbors.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体见：</p>\n<p><a href=\"https://blog.csdn.net/hehuanchun0311/article/details/80168109\">数据结构–图(Java版)</a></p>\n<h2 id=\"常用的排序方式（稳定，时间复杂度，空间复杂度）\"><a href=\"#常用的排序方式（稳定，时间复杂度，空间复杂度）\" class=\"headerlink\" title=\"常用的排序方式（稳定，时间复杂度，空间复杂度）\"></a>常用的排序方式（稳定，时间复杂度，空间复杂度）</h2><p><img src=\"https://pic.leetcode-cn.com/1607322938-FExsoY-20201207142419.png\" alt=\"image-20201207142404505\"></p>\n<p>1）当 n 较大，则应采用时间复杂度为 O(nlog2n)的排序方法：快速排序、堆排序或归并排序。</p>\n<p>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分 布时，快速排序的平均时间最短；</p>\n<p>堆排序 ：堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，也就是排序效率稳定。</p>\n<p>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的 序列，然后再合并，在效率上将有所提高。</p>\n<p>2）当 n 较大，内存空间允许，且要求稳定性 =&gt; 归并排序</p>\n<p>3） 当 n 较小，可采用直接插入或直接选择排序。</p>\n<h2 id=\"什么时候用到堆排序，快排\"><a href=\"#什么时候用到堆排序，快排\" class=\"headerlink\" title=\"什么时候用到堆排序，快排\"></a>什么时候用到堆排序，快排</h2><pre><code> 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；\n</code></pre>\n<p>  　堆排序(优先队列)所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。</p>\n<h2 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h2><ol>\n<li><p>开放定址法：</p>\n<ul>\n<li>线性探测再散列 di = 1 , 2 , 3 , … , m-1</li>\n<li>平方探测再散列 di = 1 , -1 , 2, -2 , 3 , -3 , … , k , -k(取相应数的平方)</li>\n<li>随机探测再散列 di 是一组伪随机数列</li>\n</ul>\n</li>\n<li><p>链接法：</p>\n<p>将所有哈希地址相同的记录都链接在同一链表中。</p>\n</li>\n<li><p>再哈希法：</p>\n<p>再次进行另一个哈希函数计算，直到冲突不发生。</p>\n</li>\n<li><p>建立公共溢出区</p>\n<p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>\n</li>\n</ol>\n<h2 id=\"了解动态规划吗\"><a href=\"#了解动态规划吗\" class=\"headerlink\" title=\"了解动态规划吗\"></a>了解动态规划吗</h2><p>动态规划与分治方法类似，都是通过组合子问题的解来来求解原问题的。再来了解一下什么是分治方法，以及这两者之间的差别，分治方法将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。而动态规划与之相反，动态规划应用与子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治方法会做许多不必要的工作，他会反复求解那些公共子子问题。而动态规划对于每一个子子问题只求解一次，将其解保存在一个表格里面，从而无需每次求解一个子子问题时都重新计算，避免了不必要的计算工作。<br>  动态规划的应用场景：<br>动态规划方法一般用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望找到具有最优值的解，我们称这样的解为问题的一个最优解，而不是最优解，因为可能有多个解都达到最优值。<br>   我们解决动态规划问题一般分为四步：<br>1、定义一个状态，这是一个最优解的结构特征<br>2、进行状态递推，得到递推公式<br>3、进行初始化<br>4、返回结果</p>\n<h2 id=\"讲一下数据库索引，数据库索引用什么实现，为什么不用B树，不用hashmap\"><a href=\"#讲一下数据库索引，数据库索引用什么实现，为什么不用B树，不用hashmap\" class=\"headerlink\" title=\"讲一下数据库索引，数据库索引用什么实现，为什么不用B树，不用hashmap\"></a>讲一下数据库索引，数据库索引用什么实现，为什么不用B树，不用hashmap</h2><p>过</p>\n<h2 id=\"建立abc的联合索引，b-1能命中索引吗\"><a href=\"#建立abc的联合索引，b-1能命中索引吗\" class=\"headerlink\" title=\"建立abc的联合索引，b=1能命中索引吗\"></a>建立abc的联合索引，b=1能命中索引吗</h2><p>为什么要用联合索引？</p>\n<p>对于查询语句“SELECT T.* FROM T WHERE T.c1=1 AND T.c3=2”涉及到两列，这个时候我们一般采用一个联合索引(c1, c3)；而不用两个单列索引，这是因为一条查询语句往往应为mysql优化器的关系只用一个索引，就算你有两个索引，他也只用一个；在只用一个的基础之上，联合索引是会比单列索引要快的；</p>\n<p>下面讲讲联合索引的使用规则和哪些情况会命中不了联合索引</p>\n<p>示例如下。首先创建表： CREATE TABLE T (c1 INT, c2 VARCHAR(9), c3 INT, PRIMARY KEY(c1, c3)); 这样就建立了一个联合索引：c1,c3</p>\n<p>触发联合索引是有条件的： 1、使用联合索引的全部索引键，可触发索引的使用。 例如：SELECT T.* FROM T WHERE T.c1=1 AND T.c3=2</p>\n<p>2、使用联合索引的前缀部分索引键，如“key_part_1 常量”，可触发索引的使用。 例如：SELECT T.* FROM T WHERE T.c1=1</p>\n<p>3、使用部分索引键，但不是联合索引的前缀部分，如“key_part_2 常量”，不可触发索引的使用。 例如：SELECT T.* FROM T WHERE T.c3=1</p>\n<p>4、使用联合索引的全部索引键，但索引键不是AND操作，不可触发索引的使用。 例如：SELECT T.* FROM T WHERE T.c3=2 OR T.c1=1</p>\n<h2 id=\"索引的命中规则知道吗\"><a href=\"#索引的命中规则知道吗\" class=\"headerlink\" title=\"索引的命中规则知道吗\"></a>索引的命中规则知道吗</h2><p><strong>索引****命中规则</strong>详解：</p>\n<p>t这张表 a,b,c 三个字段组成组合<strong>索引</strong></p>\n<ol>\n<li> <strong>索引****命中规则</strong>详解：</li>\n<li> t这张表 a,b,c 三个字段组成组合<strong>索引</strong></li>\n<li> select * from t where a=? and b=? and c=? 全命中</li>\n<li> select * from t where c=? and b=? and a=? 全命中 解析MySQL<strong>的</strong>查询优化器会自动调整where子句<strong>的</strong>条件顺序以使用适合<strong>的****索引</strong></li>\n<li> select * from t where a=? 命中a 解析:最左前缀匹配</li>\n<li> select * from t where a=? and b=? 命中a和b 解析:最左前缀匹配</li>\n<li> select * from t where a=? or b=? 一个没命中 解析or无法命中</li>\n<li> select * from t where a=? and c=? 命中a 解析:最左前缀匹配，中间没有则无法使用<strong>索引</strong></li>\n<li> select * from t where a=? and b in ( x, y, z) and c=? 全部命中 in精确匹配可以使用<strong>索引</strong></li>\n<li> select * from t where b=? 一个没命中 解析:最左前缀匹配原则</li>\n<li> select * from t where b=? and c=? 一个没命中 解析:最左前缀匹配原则</li>\n<li> select * from t where a=? and b like ‘xxx%’ 命中a</li>\n<li> select * from t where a=? and b like ‘%xxx’ 命中a和b</li>\n<li> select * from t where a&lt;? and b=? 命中a 解析这个是范围查找</li>\n<li> select * from t where a between ? and ? and b=? 命中a和b 解析BETWEEN相当于in操作是精确匹配</li>\n<li> select * from t where a between ? and ? and b=? and c and between ? and ? 全部命解析中同上</li>\n<li> select * from where a-1=? 函数和表达式无法命中<strong>索引</strong></li>\n</ol>\n<h2 id=\"数据库的事务\"><a href=\"#数据库的事务\" class=\"headerlink\" title=\"数据库的事务\"></a>数据库的事务</h2><p>事务就是一个对数据库操作的序列，是一个不可分割的工作单位，要不这个序列里面的操作全部执行，要不全部不执行。<br><strong>特性：</strong>原子性 （Atomicity） 持久性（Durability） 一致性（Consistency） 隔离性（Isolation）</p>\n<h2 id=\"什么叫不可重复读\"><a href=\"#什么叫不可重复读\" class=\"headerlink\" title=\"什么叫不可重复读\"></a>什么叫不可重复读</h2><p>就是在一个事务范围内，两次相同的查询会返回两个不同的数据,是因为在此间隔内有其他事务对数据进行了修改。如下图：</p>\n<p><img src=\"https://img-blog.csdn.net/20180805160649484?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDQ3NDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><p>类加载的过程<br>我们编写的java文件都是保存着业务逻辑代码。java编译器将 .java 文件编译成扩展名为 .class 的文件。.class 文件中保存着java转换后，虚拟机将要执行的指令。当需要某个类的时候，java虚拟机会加载 .class 文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为类的加载。</p>\n<p>加载<br>类加载过程的一个阶段，ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象。</p>\n<p>验证<br>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。</p>\n<p>准备<br>为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。</p>\n<p>解析<br>这里主要的任务是把常量池中的符号引用替换成直接引用</p>\n<p>初始化<br>这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）<br>具体参考：<br><a href=\"https://blog.csdn.net/weixin_40236948/article/details/88072698\">Java类加载机制</a></p>\n<h2 id=\"为什么使用双亲委派机制\"><a href=\"#为什么使用双亲委派机制\" class=\"headerlink\" title=\"为什么使用双亲委派机制\"></a>为什么使用双亲委派机制</h2><p>过</p>\n<h2 id=\"forName和loaderClass区别\"><a href=\"#forName和loaderClass区别\" class=\"headerlink\" title=\"forName和loaderClass区别\"></a>forName和loaderClass区别</h2><ul>\n<li>Class.forName()得到的class是已经初始化完成的。</li>\n<li>Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。</li>\n</ul>\n<h2 id=\"如何破坏双亲委派机制\"><a href=\"#如何破坏双亲委派机制\" class=\"headerlink\" title=\"如何破坏双亲委派机制\"></a>如何破坏双亲委派机制</h2><ol>\n<li>自定义类加载器，重写ClassLoader类的loadClass()方法</li>\n<li>使用线程上下文类加载器；</li>\n</ol>\n<h2 id=\"写代码中出现的异常能都说一下吗\"><a href=\"#写代码中出现的异常能都说一下吗\" class=\"headerlink\" title=\"写代码中出现的异常能都说一下吗\"></a>写代码中出现的异常能都说一下吗</h2><p>过</p>\n<h2 id=\"有写过web项目\"><a href=\"#有写过web项目\" class=\"headerlink\" title=\"有写过web项目\"></a>有写过web项目</h2><p>过</p>\n<h2 id=\"对Java并发了解吗\"><a href=\"#对Java并发了解吗\" class=\"headerlink\" title=\"对Java并发了解吗\"></a>对Java并发了解吗</h2><p>了解</p>\n<h2 id=\"线程池有哪几种，分别在哪些场景能使用\"><a href=\"#线程池有哪几种，分别在哪些场景能使用\" class=\"headerlink\" title=\"线程池有哪几种，分别在哪些场景能使用\"></a>线程池有哪几种，分别在哪些场景能使用</h2><p>4种。</p>\n<p>newCachedThreadPool：</p>\n<ul>\n<li>底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</li>\n<li>通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</li>\n<li>适用：执行很多短期异步的小程序或者负载较轻的服务器</li>\n</ul>\n<p>newFixedThreadPool：</p>\n<ul>\n<li>底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列</li>\n<li>通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</li>\n<li>适用：执行长期的任务，性能好很多</li>\n</ul>\n<p>newSingleThreadExecutor:</p>\n<ul>\n<li>底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列</li>\n<li>通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</li>\n<li>适用：一个任务一个任务执行的场景</li>\n</ul>\n<p>NewScheduledThreadPool:</p>\n<ul>\n<li>底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列</li>\n<li>通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构</li>\n<li>适用：周期性执行任务的场景</li>\n</ul>\n<p>线程池任务执行流程：</p>\n<ol>\n<li>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li>\n<li>当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行</li>\n<li>当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务</li>\n<li>当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理</li>\n<li>当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程</li>\n<li>当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</li>\n</ol>\n<h2 id=\"为什么用线程池\"><a href=\"#为什么用线程池\" class=\"headerlink\" title=\"为什么用线程池\"></a>为什么用线程池</h2><p>为了减少创建和销毁线程的次数，让每个线程可以多次使用,可根据系统情况<strong>调整执行</strong>的线程数量，防止消耗过多内存,所以我们可以使用线程池.</p>\n<h2 id=\"线程建很多是不是就能解决一切问题\"><a href=\"#线程建很多是不是就能解决一切问题\" class=\"headerlink\" title=\"线程建很多是不是就能解决一切问题\"></a>线程建很多是不是就能解决一切问题</h2><p><a href=\"https://blog.csdn.net/pangzhaowen/article/details/106141365\">面试总被问，创建多少个线程合适？真的越多越好吗</a></p>\n<h2 id=\"volatile关键字\"><a href=\"#volatile关键字\" class=\"headerlink\" title=\"volatile关键字\"></a>volatile关键字</h2><p>过</p>\n<h2 id=\"讲一下BIO-AIO-NIO\"><a href=\"#讲一下BIO-AIO-NIO\" class=\"headerlink\" title=\"讲一下BIO,AIO,NIO\"></a>讲一下BIO,AIO,NIO</h2><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>\n<h2 id=\"什么情况用BIO，AIO-NIO\"><a href=\"#什么情况用BIO，AIO-NIO\" class=\"headerlink\" title=\"什么情况用BIO，AIO,NIO\"></a>什么情况用BIO，AIO,NIO</h2><h1 id=\"阿里二面\"><a href=\"#阿里二面\" class=\"headerlink\" title=\"阿里二面\"></a>阿里二面</h1><h2 id=\"讲一下对于socket的了解，瓶颈是什么\"><a href=\"#讲一下对于socket的了解，瓶颈是什么\" class=\"headerlink\" title=\"讲一下对于socket的了解，瓶颈是什么\"></a>讲一下对于socket的了解，瓶颈是什么</h2><p><a href=\"https://blog.csdn.net/weixin_41563161/article/details/104779605\">Socket详解</a></p>\n<h2 id=\"怎么设计数据库的表结构（数据库的反向设计）\"><a href=\"#怎么设计数据库的表结构（数据库的反向设计）\" class=\"headerlink\" title=\"怎么设计数据库的表结构（数据库的反向设计）\"></a>怎么设计数据库的表结构（数据库的反向设计）</h2><p>真就不清楚</p>\n<h2 id=\"客户端特别多连接服务端会发生什么，崩溃的原因是什么\"><a href=\"#客户端特别多连接服务端会发生什么，崩溃的原因是什么\" class=\"headerlink\" title=\"客户端特别多连接服务端会发生什么，崩溃的原因是什么\"></a>客户端特别多连接服务端会发生什么，崩溃的原因是什么</h2>","tags":["面经"]},{"title":"数据结构面经","url":"/2021/04/10/datastrcture210410/","content":"<h1 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h1><p>性质 1：节点非红即黑。</p>\n<p>性质 2：根节点永远是黑色的。</p>\n<p>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</p>\n<p>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p>\n<p>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>\n<p>红黑树最重要的性质：从根到叶子的最长的可能路径小于等于最短的可能路径的两倍长。 红黑树并不是真正意义上的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。(对于AVL树，任何一个节点的两个子树高度差不会超过 1；对于红黑树，则是不会相差两倍以上)对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。对于红黑树，插入，删除，查找的复杂度都是 O(log N)。任何不平衡都会在3次旋转之内解决。</p>\n<h2 id=\"红黑树插入问题\"><a href=\"#红黑树插入问题\" class=\"headerlink\" title=\"红黑树插入问题\"></a>红黑树插入问题</h2><p>假设我们插入的新节点为 X</p>\n<ol>\n<li>将新插入的节点标记为红色</li>\n<li>如果 X 是根结点(root)，则标记为黑色</li>\n<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>\n</ol>\n<ul>\n<li><p>3.1 如果 X 的 uncle (叔叔) 是红色</p>\n</li>\n<li><ul>\n<li>3.1.1 将 parent 和 uncle 标记为黑色</li>\n<li>3.1.2 将 grand parent (祖父) 标记为红色</li>\n<li>3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li>\n</ul>\n</li>\n</ul>\n<p>话不多说，看下图</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-1d35b926316397d82c267593042f8c3f_720w.jpg\" alt=\"img\"></p>\n<p>跟着上面的公式走:</p>\n<ol>\n<li>将新插入的 X 节点标记为红色</li>\n<li>发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」</li>\n<li>发现 X 的 uncle (U) 同样为红色</li>\n<li>将 P 和 U 标记为黑色</li>\n<li>将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3</li>\n<li>发现 G 是根结点，标记为黑色</li>\n<li>结束</li>\n</ol>\n<p>刚刚说了 X 的 uncle 是红色的情况，接下来要说是<strong>黑色</strong>的情况</p>\n<ol>\n<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>\n</ol>\n<ul>\n<li><p>3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理</p>\n</li>\n<li><ul>\n<li>3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)</li>\n<li>3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)</li>\n<li>3.2.3 右右 (和 3.2.1 镜像过来，恰好相反)</li>\n<li>3.2.4 右左 (和 3.2.2 镜像过来，恰好相 【】【反)</li>\n</ul>\n</li>\n</ul>\n<p>当出现 uncle 是黑色的时候我们第一步要考虑的是 <strong>旋转</strong> ，这里先请小伙伴<strong>不要关注红黑树的第 4 条规则</strong>，主要是为了演示如何旋转的，来一点点看，不要看图就慌，有解释的 :</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"左左\"><a href=\"#左左\" class=\"headerlink\" title=\"左左\"></a>左左</h3><p>这种情况很简单，想象这是一根绳子，手提起 P 节点，然后变色即可</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-9e139a0f8b4a5e00ca8e643e2130403c_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"左右\"><a href=\"#左右\" class=\"headerlink\" title=\"左右\"></a>左右</h3><p>左旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的左孩子，然后再应用 <strong>左左情况</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-3fb33fbb3a42e34ed8a058a047a44cc3_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"右右\"><a href=\"#右右\" class=\"headerlink\" title=\"右右\"></a>右右</h3><p>与左左情况一样，想象成一根绳子</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-62a42ada09cb4547191aa4b9051c7c23_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"右左\"><a href=\"#右左\" class=\"headerlink\" title=\"右左\"></a>右左</h3><p>右旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的右孩子，然后再应用 <strong>右右情况</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg\" alt=\"img\"></p>\n<h1 id=\"ArrayList的扩容机制\"><a href=\"#ArrayList的扩容机制\" class=\"headerlink\" title=\"ArrayList的扩容机制\"></a>ArrayList的扩容机制</h1><p>ArrayList扩容发生在add()方法调用的时候，下面是add()方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">//扩容</span></span><br><span class=\"line\"> ensureCapacityInternal(size + <span class=\"number\">1</span>); <span class=\"comment\">//Increments modCount!!</span></span><br><span class=\"line\"> elementData[size++] = e; </span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;   </span><br><span class=\"line\"> &#125;         </span><br></pre></td></tr></table></figure>\n\n<p>ArrayList扩容的关键方法grow():</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到ArrayList中elementData数组的内存空间长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容至原来的1.5倍</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//若预设值大于默认的最大值检查是否溢出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间</span></span><br><span class=\"line\">    <span class=\"comment\">// 并将elementData的数据复制到新的内存空间</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;          </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"HashMap-的底层实现、JDK-1-8-的时候为啥将链表转换成红黑树？HashMap-的负载因子\"><a href=\"#HashMap-的底层实现、JDK-1-8-的时候为啥将链表转换成红黑树？HashMap-的负载因子\" class=\"headerlink\" title=\"HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子\"></a>HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子</h1><p>HashMap是用<strong>数组+链表+红黑树</strong>进行实现的，当添加一个元素（key-value）时，就首先计 算元素key的hash值，并根据hash值来确定插入数组中的位置，但是可能存在其他元素已经 被放在数组同一位置了，这个时候便使用链表来解决哈希冲突，当链表长度太长的时候，便 将链表转换为红黑树来提高搜索的效率。</p>\n<p>HashMap是基于拉链法实现的一个散列表，内部由数组和链表和红黑树实现。</p>\n<ol>\n<li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。</li>\n<li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造传入。</li>\n<li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（&gt;=8）， 会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（&lt;=6），又会将红黑树转换回单向链表提高性能，这里是一个平衡点。</li>\n</ol>\n<h1 id=\"有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？-线程安全的集合类\"><a href=\"#有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？-线程安全的集合类\" class=\"headerlink\" title=\"有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？ 线程安全的集合类.\"></a>有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？ 线程安全的集合类.</h1><p>Vector Stack Hashtable</p>\n<p>java.util.concurrent包下所有的集合类（ConcurrentHashMap，CopyOnWriteArrayList和CopyOnWriteArraySet等）</p>\n<h1 id=\"HashMap-多线程操作导致死循环问题异常\"><a href=\"#HashMap-多线程操作导致死循环问题异常\" class=\"headerlink\" title=\"HashMap 多线程操作导致死循环问题异常\"></a>HashMap 多线程操作导致死循环问题异常</h1><p>主要原因在于并发下的 rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。</p>\n","categories":["数据结构"],"tags":["面试"]},{"title":"兄弟们冲冲冲！","url":"/2021/03/16/first%20blog/","content":"<h1 id=\"欢迎来到我的blog\"><a href=\"#欢迎来到我的blog\" class=\"headerlink\" title=\"欢迎来到我的blog\"></a>欢迎来到我的blog</h1><p>然后懒人表示什么都没有更新！<br>记得别咸鱼！</p>\n"},{"title":"HTML学习","url":"/2021/03/18/html-learning/","content":"<h1 id=\"HTML简介\"><a href=\"#HTML简介\" class=\"headerlink\" title=\"HTML简介\"></a>HTML简介</h1><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>html learning<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>标题一<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>段落一<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>!DOCTYPE html 声明为 HTML5 文档</li>\n<li>html 元素是 HTML 页面的根元素</li>\n<li>head元素包含了文档的元（meta）数据，如 meta charset=”utf-8”定义网页编码格式为 <strong>utf-8</strong>。</li>\n</ul>\n<p>只有 body区域 (白色部分) 才会在浏览器中显示。</p>\n<h1 id=\"HTML-基础\"><a href=\"#HTML-基础\" class=\"headerlink\" title=\"HTML 基础\"></a>HTML 基础</h1><p>HTML 标题（Heading）是通过h1-h6标签来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    标题一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>HTML 段落是通过标签 p 来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    段落一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>HTML 链接是通过标签 a来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://&quot;</span>&gt;</span></span><br><span class=\"line\">   链接一</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>HTML 图像是通过标签 img 来定义的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">loading</span>=<span class=\"string\">&quot;porrige&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;/images/logo.jpg&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;258&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;39&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"HTML元素\"><a href=\"#HTML元素\" class=\"headerlink\" title=\"HTML元素\"></a>HTML元素</h1><p>如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 br标签：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"HTML属性\"><a href=\"#HTML属性\" class=\"headerlink\" title=\"HTML属性\"></a>HTML属性</h1><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>class</td>\n<td>为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td>\n</tr>\n<tr>\n<td>id</td>\n<td>定义元素的唯一id</td>\n</tr>\n<tr>\n<td>style</td>\n<td>规定元素的行内样式（inline style）</td>\n</tr>\n<tr>\n<td>title</td>\n<td>描述了元素的额外信息 (作为工具条使用)</td>\n</tr>\n</tbody></table>\n<h1 id=\"HTML标题\"><a href=\"#HTML标题\" class=\"headerlink\" title=\"HTML标题\"></a>HTML标题</h1><p>标题（Heading）是通过 h1-h6标签进行定义的。</p>\n<p>h1定义最大的标题（主要）。 h6定义最小的标题（次要）。</p>\n<h2 id=\"HTML水平线\"><a href=\"#HTML水平线\" class=\"headerlink\" title=\"HTML水平线\"></a>HTML水平线</h2><p>hr标签在 HTML 页面中创建水平线。</p>\n<p>hr 元素可用于分隔内容。</p>\n<h2 id=\"HTML-注释\"><a href=\"#HTML-注释\" class=\"headerlink\" title=\"HTML 注释\"></a>HTML 注释</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure>","categories":["HTML"]},{"title":"算法复习","url":"/2021/03/20/java-suanfa/","content":"<h1 id=\"二分查找算法\"><a href=\"#二分查找算法\" class=\"headerlink\" title=\"二分查找算法\"></a>二分查找算法</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarysearch</span><span class=\"params\">(<span class=\"keyword\">int</span> []array,<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> low=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> high=array.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(low&lt;=high)&#123;</span><br><span class=\"line\">        mid=(low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array[mid]==a)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a&gt;array[mid])&#123;</span><br><span class=\"line\">            low=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            high=mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"冒泡算法\"><a href=\"#冒泡算法\" class=\"headerlink\" title=\"冒泡算法\"></a>冒泡算法</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] bubbleSort(<span class=\"keyword\">int</span>[] arr)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;arr.length-<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;arr.length-<span class=\"number\">1</span>-i;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(arr[j]&gt;arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> temp = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j]=arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tarr[j+<span class=\"number\">1</span>]=temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] insertSort(<span class=\"keyword\">int</span>[] arr)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> insertVal=arr[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> index=i-<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(index&gt;=<span class=\"number\">0</span>&amp;&amp;insertVal&lt;arr[index])&#123;</span><br><span class=\"line\">\t\t\tarr[index+<span class=\"number\">1</span>]=arr[index];</span><br><span class=\"line\">\t\t\tindex--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tarr[index+<span class=\"number\">1</span>]=insertVal;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> []quickSort(<span class=\"keyword\">int</span> []arr,<span class=\"keyword\">int</span> low,<span class=\"keyword\">int</span> high)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> start=low;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> end=high;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> key=arr[start];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(end&gt;start)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(end&gt;start&amp;&amp;arr[end]&gt;=key)&#123;</span><br><span class=\"line\">\t\t\tend--;<span class=\"comment\">//找到比key小的值</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr[end]&lt;=key)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> temp=arr[end];</span><br><span class=\"line\">\t\t\tarr[end]=arr[start];</span><br><span class=\"line\">\t\t\tarr[start]=temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(end&gt;start&amp;&amp;arr[start]&lt;=key)&#123;</span><br><span class=\"line\">\t\t\tstart++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(arr[start]&gt;=key)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> temp=arr[start];</span><br><span class=\"line\">\t\t\tarr[start]=arr[end];</span><br><span class=\"line\">\t\t\tarr[end]=temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//递归左边序列</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(start&gt;low)&#123;</span><br><span class=\"line\">\t\tquickSort(arr,low,start-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//递归右边序列-+4</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(end&lt;high)&#123;</span><br><span class=\"line\">\t\tquickSort(arr.end+<span class=\"number\">1</span>,high);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["Java"]},{"title":"自己写输入输出问题","url":"/2021/03/20/javacode-io/","content":"<h1 id=\"1-基本定义\"><a href=\"#1-基本定义\" class=\"headerlink\" title=\"1. 基本定义\"></a>1. 基本定义</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">\t\tScanner cin1 = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        Scanner cin2 = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> BufferedInputStream(System.in));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用cin2进行输入的时候会比cin1快一些。</p>\n<h1 id=\"2-输入具体数据\"><a href=\"#2-输入具体数据\" class=\"headerlink\" title=\"2. 输入具体数据\"></a>2. 输入具体数据</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = cin.nextInt();<span class=\"comment\">//输入一个整数</span></span><br><span class=\"line\">String s = cin.next();<span class=\"comment\">//输入一个字符串</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> f = cin.nextDouble();<span class=\"comment\">//输入一个浮点数</span></span><br><span class=\"line\">String s = cin.nextLine();<span class=\"comment\">//输入一整行</span></span><br></pre></td></tr></table></figure>\n\n<p>可以使用cin.hasNext()来判断是否有下一个输入</p>\n<h1 id=\"3-基本输出\"><a href=\"#3-基本输出\" class=\"headerlink\" title=\"3. 基本输出\"></a>3. 基本输出</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.out.print();  <span class=\"comment\">//类似于cout&lt;&lt;…….;</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println();  <span class=\"comment\">//类似于cout&lt;&lt;……&lt;&lt;endl;</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.printf();  <span class=\"comment\">//类似于C中printf的功能</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-要求具体精度输出\"><a href=\"#4-要求具体精度输出\" class=\"headerlink\" title=\"4. 要求具体精度输出\"></a>4. 要求具体精度输出</h1><p>（1）可以使用上面介绍的System.out.printf();</p>\n<p>（2）对于输出浮点数要保留几位小数的问题，可以使用DecimalFormat类解决</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> pi = <span class=\"number\">3.1415927</span>;<span class=\"comment\">//圆周率</span></span><br><span class=\"line\"><span class=\"comment\">//取一位整数</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;0&quot;</span>).format(pi));<span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"comment\">//取一位整数和两位小数</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;0.00&quot;</span>).format(pi));<span class=\"comment\">//3.14</span></span><br><span class=\"line\"><span class=\"comment\">//取两位整数和三位小数，整数不足部分以0填补。</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;00.000&quot;</span>).format(pi));<span class=\"comment\">// 03.142</span></span><br><span class=\"line\"><span class=\"comment\">//取所有整数部分</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;#&quot;</span>).format(pi));<span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"comment\">//以百分比方式计数，并取两位小数</span></span><br><span class=\"line\">System.out.println(<span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">&quot;#.##%&quot;</span>).format(pi));<span class=\"comment\">//314.16%</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-字符串的处理\"><a href=\"#5-字符串的处理\" class=\"headerlink\" title=\"5. 字符串的处理\"></a>5. 字符串的处理</h1><p>String。Java中字符串String是不可以修改的，要修改只能转换为字符数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String st = <span class=\"string\">&quot;abcdefg&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] ch;</span><br><span class=\"line\"></span><br><span class=\"line\">ch = st.toCharArray(); <span class=\"comment\">// 字符串转换为字符数组.</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"6-实例\"><a href=\"#6-实例\" class=\"headerlink\" title=\"6. 实例\"></a>6. 实例</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        String[] params = br.readLine().trim().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = Integer.parseInt(params[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = Integer.parseInt(params[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = Integer.parseInt(params[<span class=\"number\">2</span>]);</span><br><span class=\"line\">        String[] strArr = br.readLine().trim().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] scores = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) scores[i] = Integer.parseInt(strArr[i]);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有输入输出写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        BufferedWriter writer = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(System.out));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> T = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> N = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">            String tables = reader.readLine();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> M = Integer.parseInt(reader.readLine());</span><br><span class=\"line\">            String enters = reader.readLine();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] res = solve(tables, enters);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r : res) &#123;</span><br><span class=\"line\">                writer.write(Integer.toString(r));</span><br><span class=\"line\">                writer.newLine();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        writer.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["Java"]},{"title":"网络编程","url":"/2021/03/18/network-coding/","content":"<h1 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h1><p>ip地址：InetAddress</p>\n<ul>\n<li><p>127.0.0.1 ：本机localhost</p>\n</li>\n<li><p>ip地址的分类</p>\n</li>\n<li><ul>\n<li>ipv4/ipv6</li>\n<li><ul>\n<li>IPV4 4个字节组成</li>\n<li>IPV6 128位，8个无符号整数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>java.net的包就是用于Internet用的</p>\n<h1 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h1><ul>\n<li><p>不同的进程拥有不同的端口号，用来区分软件。</p>\n</li>\n<li><p>被规定0~65535</p>\n</li>\n<li><p>端口分类</p>\n</li>\n<li><ul>\n<li>公有端口</li>\n<li><ul>\n<li>HTTP：80</li>\n<li>HTTPS：443</li>\n<li>FTP：21</li>\n<li>Telent：23</li>\n</ul>\n</li>\n<li>程序注册端口</li>\n<li><ul>\n<li>Tomcat：8080</li>\n<li>MySQL：3306</li>\n<li>Oracle：1521</li>\n</ul>\n</li>\n<li>动态、私有：49152~65535</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -ano <span class=\"comment\">#查看所有的端口</span></span><br><span class=\"line\">netstat -ano |findstr <span class=\"string\">&quot;5900&quot;</span></span><br><span class=\"line\">tasklist | finder <span class=\"string\">&quot;8696&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"try to upload","url":"/2021/03/17/try-to-upload/","content":"<p><img src=\"/images/pasted-210317pjl.jpg\" alt=\"pjl\"><br><img src=\"/images/pasted-210317whz.jpg\" alt=\"pjl\"></p>\n"},{"title":"常用网站","url":"/2021/11/30/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99-1/","content":"<hr>\n<p><a href=\"http://c.biancheng.net/spring_mvc/\">Spring MVC框架入门教程</a></p>\n","tags":["网站"]},{"title":"数据库面试知识点记录","url":"/2021/03/24/210324Database/","content":"<h1 id=\"1-数据库范式\"><a href=\"#1-数据库范式\" class=\"headerlink\" title=\"1.数据库范式\"></a>1.数据库范式</h1><ul>\n<li><p>第一范式：列不可分，eg:【联系人】（姓名，性别，电话），一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF；</p>\n</li>\n<li><p>第二范式：有主键，保证完全依赖。eg:订单明细表【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName），Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID，不符合2NF；</p>\n</li>\n<li><p>第三范式：无传递依赖(非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况)，eg:订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID），CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。</p>\n</li>\n</ul>\n<h1 id=\"2-数据库索引\"><a href=\"#2-数据库索引\" class=\"headerlink\" title=\"2.数据库索引\"></a>2.数据库索引</h1><p><strong>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。</strong>索引的实现通常使用B_TREE及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。</p>\n<h2 id=\"1-索引的底层实现原理和优化\"><a href=\"#1-索引的底层实现原理和优化\" class=\"headerlink\" title=\"1). 索引的底层实现原理和优化\"></a>1). 索引的底层实现原理和优化</h2><p>　　在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。<br>(1). B-Tree(平衡多路查找树)</p>\n<p>　　B_TREE是一种平衡多路查找树，是一种动态查找效率很高的树形结构。B_TREE中所有结点的孩子结点的最大值称为B_TREE的阶，B_TREE的阶通常用m表示，简称为m叉树。一般来说，应该是m&gt;=3。一颗m阶的B_TREE或是一颗空树，或者是满足下列条件的m叉树：</p>\n<p>树中每个结点最多有m个孩子结点；</p>\n<p>若根结点不是叶子节点，则根结点至少有2个孩子结点；</p>\n<p>除根结点外，其它结点至少有(m/2的上界)个孩子结点；</p>\n<p>结点的结构如下图所示，其中，n为结点中关键字个数，(m/2的上界)-1 &lt;= n &lt;= m-1；di(1&lt;=i&lt;=n)为该结点的n个关键字值的第i个，且di&lt; d(i+1)；ci(0&lt;=i&lt;=n)为该结点孩子结点的指针，且ci所指向的节点的关键字均大于或等于di且小于d(i+1)；</p>\n<p>　　　　　　　　　　<img src=\"http://static.zybuluo.com/Rico123/4clzcd69i34ihxiddnsorkza/B-Tree%E7%BB%93%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"B-Tree结点的结构.png-1.7kB\"></p>\n<p>所有的叶结点都在同一层上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）。</p>\n<p>　　下图是一棵4阶B_TREE，4叉树结点的孩子结点的个数范围[2,4]。其中，有2个结点有4个孩子结点，有1个结点有3个孩子结点，有5个结点有2个孩子结点。</p>\n<p>　　　<img src=\"http://static.zybuluo.com/Rico123/z66j4t1g8jknavzqweyikezd/4%E9%98%B6B_TREE.jpg\" alt=\"4阶B_TREE.jpg-24.1kB\">　　</p>\n<p>　　B_TREE的查找类似二叉排序树的查找，所不同的是B-树每个结点上是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，到按照对应的指针信息指向的子树中去查找，当到达叶子结点时，则说明树中没有对应的关键码。由于B_TREE的高检索效率，B-树主要应用在文件系统和数据库中，对于存储在硬盘上的大型数据库文件，可以极大程度减少访问硬盘次数，大幅度提高数据检索效率。</p>\n<p>(2). B+Tree ： <strong>InnoDB存储引擎的索引实现</strong></p>\n<p>　　B+Tree是应文件系统所需而产生的一种B_TREE树的变形树。一棵m阶的B+树和m阶的B_TREE的差异在于以下三点：</p>\n<ul>\n<li><p>n 棵子树的结点中含有n个关键码；</p>\n</li>\n<li><p>所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；</p>\n</li>\n<li><p>非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码。</p>\n</li>\n</ul>\n<p>　　下图为一棵3阶的B+树。通常在B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。因此可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。<br>在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。只是在查找时，若非终端结点上的关键码等于给定值，并不终止，而是继续向下直到叶子结点。因此，对于B+树，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。</p>\n<p>　　　　　　　　　　<img src=\"http://static.zybuluo.com/Rico123/ynugdx0avoy5blfq6gkb0tv2/3%E9%98%B6B+%E6%A0%91.jpg\" alt=\"一棵3阶的B+树.jpg-29.9kB\"></p>\n<p>(3). 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？</p>\n<ul>\n<li><p>B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；</p>\n</li>\n<li><p>B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p>\n</li>\n<li><p>数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。</p>\n</li>\n</ul>\n<p>(4). 文件索引和数据库索引为什么使用B+树?</p>\n<p>　　文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。</p>\n<h2 id=\"2-索引的优点\"><a href=\"#2-索引的优点\" class=\"headerlink\" title=\"2). 索引的优点\"></a>2). 索引的优点</h2><p>大大加快数据的检索速度，这也是创建索引的最主要的原因；</p>\n<p>加速表和表之间的连接；</p>\n<p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</p>\n<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</p>\n<h2 id=\"3-什么情况下设置了索引但无法使用？\"><a href=\"#3-什么情况下设置了索引但无法使用？\" class=\"headerlink\" title=\"3). 什么情况下设置了索引但无法使用？\"></a>3). 什么情况下设置了索引但无法使用？</h2><p>以“%(表示任意0个或多个字符)”开头的LIKE语句，模糊匹配；</p>\n<p>OR语句前后没有同时使用索引；</p>\n<p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</p>\n<p>对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。</p>\n<h2 id=\"4-什么样的字段适合创建索引？\"><a href=\"#4-什么样的字段适合创建索引？\" class=\"headerlink\" title=\"4). 什么样的字段适合创建索引？\"></a>4). 什么样的字段适合创建索引？</h2><p>经常作查询选择的字段</p>\n<p>经常作表连接的字段</p>\n<p>经常出现在order by, group by, distinct 后面的字段</p>\n<h2 id=\"5-创建索引时需要注意什么？\"><a href=\"#5-创建索引时需要注意什么？\" class=\"headerlink\" title=\"5). 创建索引时需要注意什么？\"></a>5). 创建索引时需要注意什么？</h2><p>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>\n<p>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p>\n<p>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p>\n<h2 id=\"6-索引的缺点\"><a href=\"#6-索引的缺点\" class=\"headerlink\" title=\"6). 索引的缺点\"></a>6). 索引的缺点</h2><p>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</p>\n<p>空间方面：索引需要占物理空间。</p>\n<h2 id=\"7-索引的分类\"><a href=\"#7-索引的分类\" class=\"headerlink\" title=\"7). 索引的分类\"></a>7). 索引的分类</h2><p>普通索引和唯一性索引：索引列的值的唯一性</p>\n<p>单个索引和复合索引：索引列所包含的列数</p>\n<p>聚簇索引与非聚簇索引：聚簇索引按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚簇索引必须是唯一的。聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了；而非聚集索引是把一个很大的范围，转换成一个小的地图，然后你需要在这个小地图中找你要寻找的信息的位置，最后通过这个位置，再去找你所需要的记录。</p>\n<h2 id=\"8-主键、自增主键、主键索引与唯一索引概念区别\"><a href=\"#8-主键、自增主键、主键索引与唯一索引概念区别\" class=\"headerlink\" title=\"8). 主键、自增主键、主键索引与唯一索引概念区别\"></a>8). 主键、自增主键、主键索引与唯一索引概念区别</h2><p>主键：指字段 唯一、不为空值 的列；</p>\n<p>主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；</p>\n<p>自增主键：字段类型为数字、自增、并且是主键；</p>\n<p>唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。</p>\n<h2 id=\"9-主键就是聚集索引吗？主键和索引有什么区别？\"><a href=\"#9-主键就是聚集索引吗？主键和索引有什么区别？\" class=\"headerlink\" title=\"9). 主键就是聚集索引吗？主键和索引有什么区别？\"></a>9). 主键就是聚集索引吗？主键和索引有什么区别？</h2><p>　　主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。</p>\n<h1 id=\"3-数据库事务\"><a href=\"#3-数据库事务\" class=\"headerlink\" title=\"3.数据库事务\"></a>3.数据库事务</h1><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p>\n<h2 id=\"事务的特征\"><a href=\"#事务的特征\" class=\"headerlink\" title=\"事务的特征\"></a>事务的特征</h2><ul>\n<li><p>原子性(Atomicity)：事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚；</p>\n</li>\n<li><p>一致性(Consistency)：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态；</p>\n</li>\n<li><p>隔离性(Isolation)：并发执行的事务之间不能相互影响；</p>\n</li>\n<li><p>持久性(Durability)：事务一旦提交，对数据库中数据的改变是永久性的。</p>\n</li>\n</ul>\n<h2 id=\"事务并发带来的问题\"><a href=\"#事务并发带来的问题\" class=\"headerlink\" title=\"事务并发带来的问题\"></a>事务并发带来的问题</h2><ul>\n<li>丢失修改：丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png\" alt=\"img\"></p>\n<ul>\n<li>脏读：一个事务读取了另一个事务未提交的数据；</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png\" alt=\"img\"></p>\n<ul>\n<li>不可重复读：不可重复读的重点是<strong>修改</strong>，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png\" alt=\"img\"></p>\n<ul>\n<li>幻读：幻读的重点在于<strong>新增或者删除</strong>，同样条件下两次读出来的记录数不一样。</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png\" alt=\"img\"></p>\n<h2 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h2><h3 id=\"未提交读（READ-UNCOMMITTED）\"><a href=\"#未提交读（READ-UNCOMMITTED）\" class=\"headerlink\" title=\"未提交读（READ UNCOMMITTED）\"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>\n<h3 id=\"提交读（READ-COMMITTED）\"><a href=\"#提交读（READ-COMMITTED）\" class=\"headerlink\" title=\"提交读（READ COMMITTED）\"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>\n<h3 id=\"可重复读（REPEATABLE-READ）\"><a href=\"#可重复读（REPEATABLE-READ）\" class=\"headerlink\" title=\"可重复读（REPEATABLE READ）\"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。（在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务commit或rollback。但是，其他事务的insert/delete操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复select的结果一样，除非本事务中update数据库。）</p>\n<h3 id=\"可串行化-serializable-可串行化（SERIALIZABLE）\"><a href=\"#可串行化-serializable-可串行化（SERIALIZABLE）\" class=\"headerlink\" title=\"可串行化-serializable)可串行化（SERIALIZABLE）\"></a>可串行化-serializable)可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>\n<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>\n<hr>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png\" alt=\"img\"></p>\n<p>ps：MySQL默认的隔离级别是可重复读REPEATABLE READ。</p>\n<h2 id=\"4-MySQL的事务支持\"><a href=\"#4-MySQL的事务支持\" class=\"headerlink\" title=\"4.MySQL的事务支持\"></a>4.MySQL的事务支持</h2><p>MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关：</p>\n<ul>\n<li>MyISAM：不支持事务，用于只读程序提高性能；</li>\n<li>InnoDB：支持ACID事务、行级锁、并发；</li>\n<li>Berkeley DB：支持事务。</li>\n</ul>\n<h1 id=\"5-MySQL中的悲观锁与乐观锁的实现\"><a href=\"#5-MySQL中的悲观锁与乐观锁的实现\" class=\"headerlink\" title=\"5.MySQL中的悲观锁与乐观锁的实现\"></a>5.MySQL中的悲观锁与乐观锁的实现</h1><ol>\n<li>悲观锁</li>\n</ol>\n<p>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。   </p>\n<ol start=\"2\">\n<li>乐观锁</li>\n</ol>\n<p>乐观锁的特点先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号或者时间戳，然后按照如下方式实现：</p>\n<ol start=\"3\">\n<li>悲观锁与乐观锁的应用场景</li>\n</ol>\n<p>一般情况下，<strong>读多写少更适合用乐观锁，读少写多更适合用悲观锁</strong>。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。</p>\n<h1 id=\"6-JDBC-对事务的支持\"><a href=\"#6-JDBC-对事务的支持\" class=\"headerlink\" title=\"6.JDBC 对事务的支持\"></a>6.JDBC 对事务的支持</h1><p>对于JDBC而言，每条单独的语句都是一个事务，即每个语句后都隐含一个commit。实际上，Connection 提供了一个auto-commit的属性来指定事务何时结束。当auto-commit为true时，当每个独立SQL操作的执行完毕，事务立即自动提交，也就是说，每个SQL操作都是一个事务；当auto-commit为false时，每个事务都必须显式调用commit方法进行提交，或者显式调用rollback方法进行回滚。auto-commit默认为true。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">    conn.setAutoCommit(<span class=\"keyword\">false</span>);  <span class=\"comment\">//将自动提交设置为false        </span></span><br><span class=\"line\">    ps.executeUpdate(<span class=\"string\">&quot;修改SQL&quot;</span>); <span class=\"comment\">//执行修改操作  </span></span><br><span class=\"line\">    ps.executeQuery(<span class=\"string\">&quot;查询SQL&quot;</span>);  <span class=\"comment\">//执行查询操作                 </span></span><br><span class=\"line\">    conn.commit();      <span class=\"comment\">//当两个操作成功后手动提交     </span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">    conn.rollback();    <span class=\"comment\">//一旦其中一个操作出错都将回滚，使两个操作都不成功  </span></span><br><span class=\"line\">    e.printStackTrace();  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>　　为了能够将多条SQL当成一个事务执行，必须首先通过</p>\n<p>​          </p>\n","categories":["数据库"]},{"title":"Java基础","url":"/2021/03/24/210324Javabase/","content":"<h1 id=\"StringBuilder-和-StringBuffer\"><a href=\"#StringBuilder-和-StringBuffer\" class=\"headerlink\" title=\"StringBuilder 和 StringBuffer\"></a><strong>StringBuilder</strong> <strong>和</strong> <strong>StringBuffer</strong></h1><p><strong>StringBuffer</strong> 是线程安全的 <strong>StringBuilder</strong> 是不安全的</p>\n<h1 id=\"Java实现连续空间的内存分配\"><a href=\"#Java实现连续空间的内存分配\" class=\"headerlink\" title=\"Java实现连续空间的内存分配?\"></a>Java实现连续空间的内存分配?</h1><p>基本数据类型的数组，存放在栈内存里，连续分配对象数组,在栈内存里的引用是连续分配的，实际数据分配在堆内存，不是连续分配的。</p>\n<h1 id=\"创建对象的方式有哪几种？\"><a href=\"#创建对象的方式有哪几种？\" class=\"headerlink\" title=\"创建对象的方式有哪几种？\"></a>创建对象的方式有哪几种？</h1><h1 id=\"接口和抽象类有什么区别\"><a href=\"#接口和抽象类有什么区别\" class=\"headerlink\" title=\"接口和抽象类有什么区别\"></a>接口和抽象类有什么区别</h1><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。</p>\n<p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。</p>\n<p>人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.</p>\n<p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p>\n<p>第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。<br>第二点． 接口可以多继承，抽象类不行<br>第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。<br>第四点． 接口中基本数据类型为static 而抽类象不是的。</p>\n<p>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>\n<h1 id=\"浅拷贝与深拷贝的区别\"><a href=\"#浅拷贝与深拷贝的区别\" class=\"headerlink\" title=\"浅拷贝与深拷贝的区别\"></a>浅拷贝与深拷贝的区别</h1><p><strong>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</strong></p>\n<p><strong>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</strong></p>\n<p>ps:Java中的拷贝需要实现java.lang.Cloneable接口，然后重写clone()方法，这个无论深、浅拷贝都需要这样做</p>\n<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p><strong>编译时多态</strong><br>方法重载 都是编译时多态。根据实际参数的数据类型、个数和次序，Java 在编译时能够确定执行重载方法中的哪一个。</p>\n<p>方法覆盖 表现出两种多态性，当对象引用本类实例时，为编译时多态，否则为运行时多态。</p>\n<p><strong>运行时多态</strong><br>通过父类对象引用变量引用子类对象来实现。当父类对象引用子类实例时。通过接口类型变量引用实现接口的类的对象来实现 。运行时多态主要是通过继承和接口实现的。</p>\n<h1 id=\"Java注解的理解\"><a href=\"#Java注解的理解\" class=\"headerlink\" title=\"Java注解的理解\"></a>Java注解的理解</h1><p>Java 语言中的类、方法、变量、参数和包等都可以注解标记，程序运行期间我们可以获取到相应的注解以及注解中定义的内容，这样可以帮助我们做一些事情。</p>\n<h1 id=\"Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？\"><a href=\"#Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？\" class=\"headerlink\" title=\"Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？\"></a>Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</h1><p>反射介绍：</p>\n<p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及 动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n<p>反射的优缺点如下：</p>\n<ul>\n<li><p>优点：运行期类型的判断，动态加载类，提高代码灵活度。</p>\n</li>\n<li><p>缺点：</p>\n</li>\n</ul>\n<ol>\n<li><p>性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。</p>\n</li>\n<li><p>安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</p>\n</li>\n</ol>\n<h1 id=\"为什么框架需要反射技术\"><a href=\"#为什么框架需要反射技术\" class=\"headerlink\" title=\"为什么框架需要反射技术\"></a>为什么框架需要反射技术</h1><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机 制没有用，实际上有很多设计、开发都与反射机制有关。动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>\n<p>我们在使用 JDBC 连接数据库时使用 Class.forName() 通过反射加载数据库的驱动程序；<br>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；<br>动态配置实例的属性；</p>\n<h1 id=\"获取Class对象的两种方式\"><a href=\"#获取Class对象的两种方式\" class=\"headerlink\" title=\"获取Class对象的两种方式\"></a>获取Class对象的两种方式</h1><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了两种方式获取 Class 对象:</p>\n<p>知道具体类的情况下可以使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class alunbarClass = TargetObject.class;      </span><br></pre></td></tr></table></figure>\n\n\n<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象</p>\n<p>通过 Class.forName() 传入类的路径获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class alunbarClass1 = Class.forName(<span class=\"string\">&quot;cn.javaguide.TargetObject&quot;</span>); </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"内存泄露和内存溢出的场景\"><a href=\"#内存泄露和内存溢出的场景\" class=\"headerlink\" title=\"内存泄露和内存溢出的场景\"></a>内存泄露和内存溢出的场景</h1><p>内存泄漏：内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不 到及时释放，从而造成内存空间的浪费称为内存泄漏。</p>\n<p>Java 内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。</p>\n<p>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生 于 OLD 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况。</p>\n<p>内存溢出场景：</p>\n<ul>\n<li>JVM Heap（堆）溢出：OutOfMemoryError: Java heap space： 发生这种问题的原因是 java 虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已 经用满了。JVM 在启动的时候会自动设置 JVM Heap 的值， 可以利用 JVM 提供的-Xmn -Xms -Xmx 等选项可进行设置。Heap的大小是新生代和老年代之和。</li>\n</ul>\n<p>解决方法：</p>\n<ol>\n<li><p>手动设置 JVM Heap（堆）的大小。</p>\n</li>\n<li><p>检查程序，看是否有死循环或不必要地重复创建大量对象。</p>\n</li>\n</ol>\n<ul>\n<li>Metaspace溢出：java.lang.OutOfMemoryError: Metaspace 程序中使用了大量的 jar 或 class，使 java 虚拟机装载类的空间不够，与 metaspace 大小有关。方法区用于存放 Java 类型的相关信息。在类装载器加载 class 文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的 内存占用又已经达到 -XX:MaxMetaspaceSize 设置的最大值，将会抛出 OutOfMemoryError 异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</li>\n</ul>\n<p>解决方法:</p>\n<ol>\n<li>通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。</li>\n</ol>\n<ul>\n<li>栈溢出： java.lang.StackOverflowError : Thread Stack space：线程的方法嵌套调用层次太多(如递归调用)，以致于把栈区溢出了。</li>\n</ul>\n<p>解决方法：</p>\n<ol>\n<li>修改程序。</li>\n<li>通过 -Xss: 来设置每个线程的 Stack 大小即可。</li>\n</ol>\n<h1 id=\"强引用，弱引用，软引用，虚引用\"><a href=\"#强引用，弱引用，软引用，虚引用\" class=\"headerlink\" title=\"强引用，弱引用，软引用，虚引用\"></a>强引用，弱引用，软引用，虚引用</h1><h2 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h2><p>大部分引用实际上都是，最普遍。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object object = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">String str = <span class=\"string\">&quot;StrongReference&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个对象具有强引用，那就类似于<strong>必不可少的</strong>物品，不会被垃圾回收器回收。<strong>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</strong></p>\n<h2 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h2><p>软引用是用来描述一些<strong>有用但并不是必需</strong>的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。<br>软引用在实际中有重要的应用，例如浏览器的后退按钮，这个后退时显示的网页内容可以重新进行请求或者从缓存中取出：</p>\n<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p>\n<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出这时候就可以使用软引用</p>\n<h2 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h2><p>弱引用也是用来描述<strong>非必需对象</strong>的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p>\n<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<u>所以被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</u></p>\n<h2 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h2><p>虚引用和前面的软引用、弱引用不同，它并<strong>不影响对象的生命周期</strong>。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，<strong>在任何时候都可能被垃圾回收器回收</strong>。虚引用主要用来跟踪对象被垃圾回收的活动。</p>\n<p><strong>虚引用必须和引用队列关联使用</strong>，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>被回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>强引用</td>\n<td>从来不会</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>jvm垃圾回收时</td>\n<td>对象缓存</td>\n<td>gc运行后</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>未知</td>\n<td>未知</td>\n<td>未知</td>\n</tr>\n</tbody></table>\n<h1 id=\"讲一下-Java-的-BIO-NIO-AIO\"><a href=\"#讲一下-Java-的-BIO-NIO-AIO\" class=\"headerlink\" title=\"讲一下 Java 的 BIO,NIO,AIO?\"></a>讲一下 Java 的 BIO,NIO,AIO?</h1><h2 id=\"BIO-Blocking-I-O-：\"><a href=\"#BIO-Blocking-I-O-：\" class=\"headerlink\" title=\"BIO (Blocking I/O)：\"></a>BIO (Blocking I/O)：</h2><p>同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>\n<h2 id=\"NIO-Non-blocking-New-I-O\"><a href=\"#NIO-Non-blocking-New-I-O\" class=\"headerlink\" title=\"NIO (Non-blocking/New I/O):\"></a>NIO (Non-blocking/New I/O):</h2><p>NIO 是一种同步非阻塞的 I/O 模型，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。Java NIO使我们可以进行非阻塞IO操作。比如说， 单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后， 线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一 些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。JDK 的 NIO 底层由 epoll 实现。</p>\n<p>通常来说 NIO 中的所有 IO 都是从 Channel（通道） 开始的。</p>\n<p>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</p>\n<p>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</p>\n<h2 id=\"AIO-Asynchronous-I-O-：\"><a href=\"#AIO-Asynchronous-I-O-：\" class=\"headerlink\" title=\"AIO (Asynchronous I/O)：\"></a>AIO (Asynchronous I/O)：</h2><p>异步非阻塞IO模型，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的 线程进行后续的操作。AIO 的应用还不是很广泛。</p>\n<h1 id=\"Java中finalize-方法的使用\"><a href=\"#Java中finalize-方法的使用\" class=\"headerlink\" title=\"Java中finalize()方法的使用\"></a>Java中finalize()方法的使用</h1><p>finalize()是 Object的protected 方法，子类可以覆盖该方法以实现资源清理工作，GC 在回收对象之前调用该方法。</p>\n<p><strong>finalize()方法中一般用于释放非 Java 资源（如打开的文件资源、数据库连接等），或是调用非Java方法（native方法）时分配的内存（比如 C 语言的 malloc()系列函数）。</strong></p>\n<p>避免使用的原因：</p>\n<p>首先，由于 finalize()方法的调用时机具有不确定性，从一个对象变得不可到达开始，到 finalize()方法被执行，所花费的时间这段时间是任意长的。我们并不能依赖 finalize()方法能 及时的回收占用的资源，可能出现的情况是在我们耗尽资源之前，gc 却仍未触发，因而通常的做法是提供显示的 close()方法供客户端手动调用。另外，重写 finalize()方法意味着延长了回收对象时需要进行更多的操作，从而延长了对象回收的时间。</p>\n<h1 id=\"什么是GC-Root\"><a href=\"#什么是GC-Root\" class=\"headerlink\" title=\"什么是GC Root\"></a>什么是GC Root</h1><p>首先我们知道标记算法，JVM的标记算法我们可以了解为一个可达性算法，所以所有的可达性算法都会有起点，那么这个起点就是GC Root。也就是需要通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。</p>\n<h2 id=\"GC-Root的对象\"><a href=\"#GC-Root的对象\" class=\"headerlink\" title=\"GC Root的对象\"></a>GC Root的对象</h2><ul>\n<li>方法区中的静态变量和常量引用的对象</li>\n<li>虚拟机栈中引用对象</li>\n<li>本地方法栈中引用对象</li>\n</ul>\n<h1 id=\"单例模型\"><a href=\"#单例模型\" class=\"headerlink\" title=\"单例模型\"></a>单例模型</h1><p>下述内容来源于<a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\">菜鸟教程</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">1、懒汉式，线程不安全</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：是</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：否</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：易</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span></span><br><span class=\"line\"><span class=\"comment\">这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2、懒汉式，线程安全</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：是</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：易</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</span></span><br><span class=\"line\"><span class=\"comment\">优点：第一次调用才初始化，避免内存浪费。</span></span><br><span class=\"line\"><span class=\"comment\">缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</span></span><br><span class=\"line\"><span class=\"comment\">getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">3、饿汉式</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：否</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：易</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式比较常用，但容易产生垃圾对象。</span></span><br><span class=\"line\"><span class=\"comment\">优点：没有加锁，执行效率会提高。</span></span><br><span class=\"line\"><span class=\"comment\">缺点：类加载时就初始化，浪费内存。</span></span><br><span class=\"line\"><span class=\"comment\">它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">4、双检锁/双重校验锁（DCL，即 double-checked locking）</span></span><br><span class=\"line\"><span class=\"comment\">JDK 版本：JDK1.5 起</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：是</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：较复杂</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</span></span><br><span class=\"line\"><span class=\"comment\">getInstance() 的性能对应用程序很关键。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">5、登记式/静态内部类</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：是</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：一般</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</span></span><br><span class=\"line\"><span class=\"comment\">这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">6、枚举</span></span><br><span class=\"line\"><span class=\"comment\">JDK 版本：JDK1.5 起</span></span><br><span class=\"line\"><span class=\"comment\">是否 Lazy 初始化：否</span></span><br><span class=\"line\"><span class=\"comment\">是否多线程安全：是</span></span><br><span class=\"line\"><span class=\"comment\">实现难度：易</span></span><br><span class=\"line\"><span class=\"comment\">描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</span></span><br><span class=\"line\"><span class=\"comment\">这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</span></span><br><span class=\"line\"><span class=\"comment\">不能通过 reflection attack 来调用私有构造方法。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    INSTANCE;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whateverMethod</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;       </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java中-gt-gt-和-gt-gt-gt-的区别\"><a href=\"#Java中-gt-gt-和-gt-gt-gt-的区别\" class=\"headerlink\" title=\"Java中&gt;&gt;和&gt;&gt;&gt;的区别\"></a>Java中&gt;&gt;和&gt;&gt;&gt;的区别</h1><p>Java 中的位运算符：</p>\n<p>‘&gt;&gt;’表示带符号右移，如：int i=15; i&gt;&gt;2 的结果是 3，移出的部分将被抛弃。<br>转为二进制的形式可能更好理解，0000 1111(15)右移 2 位的结果是 0000 0011(3)，0001 1010(18)右移 3 位的结果是 0000 0011(3)。</p>\n<p>‘&gt;&gt;&gt;’无符号右移：<br>按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补零。对于正数来说和带符号右移相同，对于负数来说不同。<br>其他结构和&gt;&gt;相似。</p>\n<h1 id=\"讲一下volatile关键字的作用\"><a href=\"#讲一下volatile关键字的作用\" class=\"headerlink\" title=\"讲一下volatile关键字的作用\"></a>讲一下volatile关键字的作用</h1><p>volatile可以保证可见性，有序性，但不能保证原子性.</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a><strong>可见性</strong></h2><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong></p>\n<h2 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a><strong>有序性</strong></h2><p>有序性即程序执行的顺序按照代码的先后顺序执行</p>\n<h1 id=\"synchronized-作用，讲一讲底层实现\"><a href=\"#synchronized-作用，讲一讲底层实现\" class=\"headerlink\" title=\"synchronized 作用，讲一讲底层实现\"></a>synchronized 作用，讲一讲底层实现</h1><h2 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a><strong>原子性</strong></h2><p><strong>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong></p>\n<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。但是像i++、i+=1等操作字符就不是原子性的，它们是分成<strong>读取、计算、赋值</strong>几步操作，原值在这些步骤还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。</p>\n<p>被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。</p>\n<p><strong>注意！面试时经常会问比较synchronized和volatile，它们俩特性上最大的区别就在于原子性，volatile不具备原子性。</strong></p>\n<h2 id=\"可见性-1\"><a href=\"#可见性-1\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p><strong>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</strong></p>\n<p>synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</p>\n<p>而volatile的实现类似，被volatile修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性。</p>\n<h2 id=\"有序性-1\"><a href=\"#有序性-1\" class=\"headerlink\" title=\"有序性\"></a>有序性</h2><p><strong>有序性值程序执行的顺序按照代码先后执行。</strong></p>\n<p>synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</p>\n<h2 id=\"可重入性\"><a href=\"#可重入性\" class=\"headerlink\" title=\"可重入性\"></a>可重入性</h2><p>synchronized和ReentrantLock都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</p>\n<h1 id=\"说说-synchronized关键字和-volatile关键字的区别\"><a href=\"#说说-synchronized关键字和-volatile关键字的区别\" class=\"headerlink\" title=\"说说 synchronized关键字和 volatile关键字的区别\"></a>说说 synchronized关键字和 volatile关键字的区别</h1><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键 字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代 码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁 带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提 升，实际开发中使用 synchronized 关键字的场景还是更多一些。</p>\n<p>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字 两者都能保证。</p>\n<p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://blog.csdn.net/qq_39192827/article/details/85611873\">https://blog.csdn.net/qq_39192827/article/details/85611873</a></p>\n<p>[2] <a href=\"https://www.jianshu.com/p/9d573539022c\">深入理解synchronized底层原理，一篇文章就够了！</a></p>\n","categories":["Java"],"tags":["面试"]},{"title":"Git","url":"/2021/03/28/Git/","content":"<h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><p>学习git之前，我们需要先明白一个概念</p>\n<p><strong>版本控制！</strong></p>\n<h2 id=\"什么是版本控制\"><a href=\"#什么是版本控制\" class=\"headerlink\" title=\"什么是版本控制\"></a>什么是版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>\n<ul>\n<li>实现跨区域多人协同开发</li>\n<li>追踪和记载一个或者多个文件的历史记录</li>\n<li>组织和保护你的源代码和文档</li>\n<li>统计工作量</li>\n<li>并行开发、提高开发效率</li>\n<li>跟踪记录整个软件的开发过程</li>\n<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>\n</ul>\n<p>简单说就是用于管理多人协同开发项目的技术。</p>\n<p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p>\n<p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0C4qeLxMgoTg9B154ibahsUaibiaV7DgH9GTFQZj3Kyhf5fxrj6G2U5HFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>多人开发就必须要使用版本控制！</p>\n<h2 id=\"常见的版本控制工具\"><a href=\"#常见的版本控制工具\" class=\"headerlink\" title=\"常见的版本控制工具\"></a>常见的版本控制工具</h2><p>我们学习的东西，一定是当下最流行的！</p>\n<p>主流的版本控制器有如下这些：</p>\n<ul>\n<li><strong>Git</strong></li>\n<li><strong>SVN</strong>（Subversion）</li>\n<li><strong>CVS</strong>（Concurrent Versions System）</li>\n<li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li>\n<li><strong>TFS</strong>（Team Foundation Server）</li>\n<li>Visual Studio Online</li>\n</ul>\n<p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p>\n<h2 id=\"版本控制分类\"><a href=\"#版本控制分类\" class=\"headerlink\" title=\"版本控制分类\"></a>版本控制分类</h2><h3 id=\"1、本地版本控制\"><a href=\"#1、本地版本控制\" class=\"headerlink\" title=\"1、本地版本控制\"></a><strong>1、本地版本控制</strong></h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Dg3fHrbPqbNEOMO9GTjFhVaukMZWx54icS7eS2x8A7BEu0VB9ibwEhzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h3 id=\"2、集中版本控制-SVN\"><a href=\"#2、集中版本控制-SVN\" class=\"headerlink\" title=\"2、集中版本控制  SVN\"></a><strong>2、集中版本控制  SVN</strong></h3><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p>\n<h3 id=\"3、分布式版本控制-Git\"><a href=\"#3、分布式版本控制-Git\" class=\"headerlink\" title=\"3、分布式版本控制     Git\"></a><strong>3、分布式版本控制     Git</strong></h3><p>每个人都拥有全部的代码！安全隐患！</p>\n<p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>\n<p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h2 id=\"Git与SVN的主要区别\"><a href=\"#Git与SVN的主要区别\" class=\"headerlink\" title=\"Git与SVN的主要区别\"></a>Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p>\n<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>\n<h1 id=\"聊一聊Git的历史\"><a href=\"#聊一聊Git的历史\" class=\"headerlink\" title=\"聊一聊Git的历史\"></a>聊一聊Git的历史</h1><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>\n<p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>\n<p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p>\n<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p>\n<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>\n<p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p>\n<h1 id=\"Git环境配置\"><a href=\"#Git环境配置\" class=\"headerlink\" title=\"Git环境配置\"></a>Git环境配置</h1><h2 id=\"软件下载\"><a href=\"#软件下载\" class=\"headerlink\" title=\"软件下载\"></a>软件下载</h2><p>打开 [git官网] <a href=\"https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82\">https://git-scm.com/，下载git对应操作系统的版本。</a></p>\n<p>所有东西下载慢的话就可以去找镜像！</p>\n<p>官网下载太慢，我们可以使用淘宝镜像下载：<a href=\"http://npm.taobao.org/mirrors/git-for-windows/\">http://npm.taobao.org/mirrors/git-for-windows/</a></p>\n<p><img src=\"C:\\Users\\dell\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210328143055320.png\" alt=\"image-20210328143055320\"></p>\n<p>下载对应的版本即可安装！</p>\n<p>安装：无脑下一步即可！安装完毕就可以使用了！</p>\n<h2 id=\"启动Git\"><a href=\"#启动Git\" class=\"headerlink\" title=\"启动Git\"></a>启动Git</h2><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p>\n<p><strong>Git CMD：</strong>Windows风格的命令行</p>\n<p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p>\n<h2 id=\"常用的Linux命令\"><a href=\"#常用的Linux命令\" class=\"headerlink\" title=\"常用的Linux命令\"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p>\n<p>1）、cd : (Change Directory)改变目录。</p>\n<p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p>\n<p>3）、pwd : (print work directory)显示当前所在的目录路径。</p>\n<p>4）、ls(ll):  (list)都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p>\n<p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p>\n<p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p>\n<p>7）、mkdir: (Make Directory) 新建一个目录,就是新建一个文件夹。</p>\n<p>8）、rm -r : (Remove Directory) 删除一个文件夹, rm -r src 删除src目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！</span><br></pre></td></tr></table></figure>\n\n<p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p>\n<p>10）、reset 重新初始化终端/清屏。</p>\n<p>11）、clear 清屏。</p>\n<p>12）、history 查看命令历史。</p>\n<p>13）、help 帮助。</p>\n<p>14）、exit 退出。</p>\n<p>15）、#表示注释</p>\n<h2 id=\"Git-配置\"><a href=\"#Git-配置\" class=\"headerlink\" title=\"Git 配置\"></a>Git 配置</h2><p>所有的配置文件，其实都保存在本地！</p>\n<p>查看配置 git config -l</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>查看不同级别的配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#查看系统config</span><br><span class=\"line\">git config --system --list　　</span><br><span class=\"line\">#查看当前用户（global）配置</span><br><span class=\"line\">git config --global  --list</span><br></pre></td></tr></table></figure>\n\n<p><strong>Git相关的配置文件：</strong></p>\n<p>1）、Git\\etc\\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p>\n<p>2）、C:\\Users\\Administrator\\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p>\n<h2 id=\"设置用户名与邮箱（用户标识，必要）\"><a href=\"#设置用户名与邮箱（用户标识，必要）\" class=\"headerlink\" title=\"设置用户名与邮箱（用户标识，必要）\"></a>设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;名称&quot;  #名称</span><br><span class=\"line\">git config --global user.email 邮箱   #邮箱</span><br></pre></td></tr></table></figure>\n\n<p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p>\n<p>可以查看当前用户（global）配置<br>git config –global  –list</p>\n<h1 id=\"Git基本原理\"><a href=\"#Git基本原理\" class=\"headerlink\" title=\"Git基本原理\"></a>Git基本原理</h1><h2 id=\"三个区域\"><a href=\"#三个区域\" class=\"headerlink\" title=\"三个区域\"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<ul>\n<li>Workspace：工作区，就是你平时存放项目代码的地方</li>\n<li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>\n<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>\n<li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>\n</ul>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p>git的工作流程一般是这样的：</p>\n<p>１、在工作目录中添加、修改文件；</p>\n<p>２、将需要进行版本管理的文件放入暂存区域；</p>\n<p>３、将暂存区域的文件提交到git仓库。</p>\n<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h1 id=\"Git项目搭建\"><a href=\"#Git项目搭建\" class=\"headerlink\" title=\"Git项目搭建\"></a>Git项目搭建</h1><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>\n<p>日常使用只要记住下图6个命令：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<h2 id=\"本地仓库搭建\"><a href=\"#本地仓库搭建\" class=\"headerlink\" title=\"本地仓库搭建\"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>\n<p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 在当前目录新建一个Git代码库</span><br><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure>\n\n<p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p>\n<h2 id=\"克隆远程仓库\"><a href=\"#克隆远程仓库\" class=\"headerlink\" title=\"克隆远程仓库\"></a>克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class=\"line\">$ git clone [url]  </span><br></pre></td></tr></table></figure>\n\n<p>2、去 gitee 或者 github 上克隆一个测试！</p>\n<h1 id=\"Git文件操作\"><a href=\"#Git文件操作\" class=\"headerlink\" title=\"Git文件操作\"></a>Git文件操作</h1><h2 id=\"文件的四种状态\"><a href=\"#文件的四种状态\" class=\"headerlink\" title=\"文件的四种状态\"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>\n<ul>\n<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li>\n<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li>\n<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li>\n<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>\n</ul>\n<h2 id=\"查看文件状态\"><a href=\"#查看文件状态\" class=\"headerlink\" title=\"查看文件状态\"></a>查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#查看指定文件状态</span><br><span class=\"line\">git status [filename]</span><br><span class=\"line\">#查看所有文件状态</span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"># git add .                  添加所有文件到暂存区# git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git commit -a</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"忽略文件\"><a href=\"#忽略文件\" class=\"headerlink\" title=\"忽略文件\"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>\n<p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p>\n<ol>\n<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>\n<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li>\n<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>\n<li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>\n<li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li>\n</ol>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#为注释</span><br><span class=\"line\">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class=\"line\">!lib.txt     #但lib.txt除外</span><br><span class=\"line\">&#x2F;temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class=\"line\">build&#x2F;       #忽略build&#x2F;目录下的所有文件</span><br><span class=\"line\">doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"码云的使用\"><a href=\"#码云的使用\" class=\"headerlink\" title=\"码云的使用\"></a>码云的使用</h2><p>这个其实可以作为大家未来找工作的一个重要信息！</p>\n<p>1、注册登录码云，完善个人信息</p>\n<p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 进入 C:\\Users\\Administrator\\.ssh 目录</span><br><span class=\"line\"># 生成公钥</span><br><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>3、将公钥信息public key 添加到码云账户中即可！</p>\n<p>4、使用码云创建一个自己的仓库！</p>\n<h1 id=\"GIT分支\"><a href=\"#GIT分支\" class=\"headerlink\" title=\"GIT分支\"></a>GIT分支</h1><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p>\n<p>git分支中常用指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，并切换到该分支</span><br><span class=\"line\">git checkout -b [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\">#远程提交</span><br><span class=\"line\">git push -u origin &lt;你要推送的分支名&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\">$ git push origin --delete [branch-name]</span><br><span class=\"line\">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>\n\n<p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p>\n<p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ\">https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ</a></p>\n"},{"title":"操作系统面试知识点记录","url":"/2021/03/21/operating-system-interview/","content":"<h1 id=\"1-进程和线程的区别\"><a href=\"#1-进程和线程的区别\" class=\"headerlink\" title=\"1.进程和线程的区别\"></a>1.进程和线程的区别</h1><p>1）进程是资源分配的最小单位，线程是任务执行的最小单位。</p>\n<p>2）一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在。</p>\n<p>3）进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</p>\n<p>4）线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。</p>\n<p>5）线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p>\n<p>6）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p>\n<p>速记：单位，依赖，内存，通信</p>\n<h1 id=\"2-进程的调度算法\"><a href=\"#2-进程的调度算法\" class=\"headerlink\" title=\"2.进程的调度算法\"></a>2.进程的调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>\n<h2 id=\"1-批处理系统\"><a href=\"#1-批处理系统\" class=\"headerlink\" title=\"1. 批处理系统\"></a>1. 批处理系统</h2><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>\n<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>\n<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>\n<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>\n<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>\n<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>\n<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>\n<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>\n<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>\n<h2 id=\"2-交互式系统\"><a href=\"#2-交互式系统\" class=\"headerlink\" title=\"2. 交互式系统\"></a>2. 交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>\n<p><strong>2.1 时间片轮转</strong></p>\n<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>\n<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>\n<ul>\n<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>\n<li>而如果时间片过长，那么实时性就不能得到保证。</li>\n</ul>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png\" alt=\"img\"></p>\n<p><strong>2.2 优先级调度</strong></p>\n<p>为每个进程分配一个优先级，按优先级进行调度。</p>\n<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>\n<p><strong>2.3 多级反馈队列</strong></p>\n<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>\n<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>\n<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>\n<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png\" alt=\"img\"></p>\n<h2 id=\"3-实时系统\"><a href=\"#3-实时系统\" class=\"headerlink\" title=\"3. 实时系统\"></a>3. 实时系统</h2><p>实时系统要求一个请求在一个确定时间内得到响应。</p>\n<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>\n<p>速记：先进先出，短作业优先，最短剩余时间优先，时间片轮转，优先级调度，多级反馈队列</p>\n<h1 id=\"3-进程间通信的几种方式\"><a href=\"#3-进程间通信的几种方式\" class=\"headerlink\" title=\"3.进程间通信的几种方式\"></a>3.进程间通信的几种方式</h1><ul>\n<li><p>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>\n</li>\n<li><p>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>\n</li>\n<li><p>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>\n</li>\n<li><p>共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p>\n</li>\n<li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问。主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p>\n</li>\n<li><p>套接字：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>\n</li>\n</ul>\n<h1 id=\"4-线程通信的方式\"><a href=\"#4-线程通信的方式\" class=\"headerlink\" title=\"4.线程通信的方式\"></a>4.线程通信的方式</h1><p>  a) 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</p>\n<p>  b) 信号量(Semphares)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>\n<p>  c) 事件(Event):Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>\n<h1 id=\"5-什么是死锁？死锁产生的条件？\"><a href=\"#5-什么是死锁？死锁产生的条件？\" class=\"headerlink\" title=\"5.什么是死锁？死锁产生的条件？\"></a>5.什么是死锁？死锁产生的条件？</h1><p>  1)死锁的概念</p>\n<p>　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>\n<p>2). 死锁产生的四个必要条件</p>\n<p>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</p>\n<p>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</p>\n<p>非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放</p>\n<p>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系</p>\n<h1 id=\"6-死锁处理策略\"><a href=\"#6-死锁处理策略\" class=\"headerlink\" title=\"6.死锁处理策略\"></a>6.死锁处理策略</h1><p>1）死锁检测与死锁恢复</p>\n<ol>\n<li>每种类型一个资源的死锁检测（找环）</li>\n<li>每种类型多个资源的死锁检测（矩阵）</li>\n<li>死锁恢复（利用抢占恢复，利用回滚恢复，通过杀死进程恢复）</li>\n</ol>\n<p>2）死锁预防</p>\n<p>死锁预防基本原理：破坏死锁发生的四个必要条件之一不成立。</p>\n<ol>\n<li>破坏互斥条件</li>\n</ol>\n<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>\n<ol start=\"2\">\n<li>破坏占有和等待条件</li>\n</ol>\n<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>\n<ol start=\"3\">\n<li><p>破坏不可抢占条件</p>\n</li>\n<li><p>破坏环路等待</p>\n</li>\n</ol>\n<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>\n<h1 id=\"7-进程有哪几种状态\"><a href=\"#7-进程有哪几种状态\" class=\"headerlink\" title=\"7.进程有哪几种状态\"></a>7.进程有哪几种状态</h1><ul>\n<li>就绪状态（ready）：等待被调度</li>\n<li>运行状态（running）</li>\n<li>阻塞状态（waiting）：等待资源</li>\n</ul>\n<p>应该注意以下内容：</p>\n<ol>\n<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>\n<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>\n</ol>\n<h1 id=\"8-线程有几种状态\"><a href=\"#8-线程有几种状态\" class=\"headerlink\" title=\"8.线程有几种状态\"></a>8.线程有几种状态</h1><p>在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态，各状态的含义如下图所示：</p>\n<p><img src=\"http://static.zybuluo.com/Rico123/ot7o6218591iwj9py999hs1u/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg\" alt=\"线程的状态.jpg-59.9kB\"></p>\n<h1 id=\"9-虚拟内存\"><a href=\"#9-虚拟内存\" class=\"headerlink\" title=\"9.虚拟内存\"></a>9.虚拟内存</h1><p><strong>虚拟内存使得应用程序认为它拥有一个连续的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。</strong></p>\n<p>虚拟内存的<strong>目的</strong>是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>\n<p>虚拟内存的<strong>基本思想</strong>是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。</p>\n<p>虚拟内存<strong>优点</strong>：</p>\n<ul>\n<li><p>在内存中可以保留多个进程，系统并发度提高</p>\n</li>\n<li><p>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</p>\n</li>\n</ul>\n<h1 id=\"10-页面置换算法\"><a href=\"#10-页面置换算法\" class=\"headerlink\" title=\"10.页面置换算法\"></a>10.页面置换算法</h1><ul>\n<li><p>FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p>\n</li>\n<li><p>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</p>\n</li>\n<li><p>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</p>\n</li>\n<li><p>OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p>\n</li>\n</ul>\n<h1 id=\"11-颠簸\"><a href=\"#11-颠簸\" class=\"headerlink\" title=\"11.颠簸\"></a>11.颠簸</h1><p>​        颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。</p>\n<p>　　内存颠簸的解决策略包括：</p>\n<ul>\n<li><p>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；</p>\n</li>\n<li><p>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；</p>\n</li>\n<li><p>否则，还剩下两个办法：终止该进程或增加物理内存容量</p>\n</li>\n</ul>\n<h1 id=\"12-分页和分段有什么区别（内存管理）\"><a href=\"#12-分页和分段有什么区别（内存管理）\" class=\"headerlink\" title=\"12.分页和分段有什么区别（内存管理）\"></a>12.分页和分段有什么区别（内存管理）</h1><p>​        段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p>\n<p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p>\n<p>​        段页式：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>\n<p><strong>两者的相同点：</strong></p>\n<p>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。<br>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中 的内存是连续的。</p>\n<p><strong>两者的不同点：</strong></p>\n<ul>\n<li>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li>\n<li>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</li>\n<li>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li>\n<li>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</li>\n<li>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li>\n<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>\n</ul>\n<h1 id=\"13-常用的IO模型\"><a href=\"#13-常用的IO模型\" class=\"headerlink\" title=\"13.常用的IO模型\"></a>13.常用的IO模型</h1><ul>\n<li>阻塞式I/O：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</li>\n<li>非阻塞式I/O：进程发起 IO 系统调用后，内核返回一个错误码而不会被阻塞；应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。如果内核缓冲区有数据，内核就会把数据返回进程。</li>\n<li>I/O复用（select和poll)：使用 select 或者 poll 等待数据，可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后把数据从内核复制到进程中。</li>\n<li>信号驱动式I/O（SIGIO)：当进程发起一个 IO 操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用 IO 读取数据。</li>\n<li>异步I/O（aio_系列函数）：当进程发起一个 IO 操作，进程返回不阻塞，但也不能返回结果；内核把整个 IO 处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</li>\n</ul>\n<h1 id=\"14-select\"><a href=\"#14-select\" class=\"headerlink\" title=\"14.select\"></a>14.select</h1><p>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制，poll 中的描述符是 pollfd 类型的数组；</p>\n<h1 id=\"15-fork函数的作用\"><a href=\"#15-fork函数的作用\" class=\"headerlink\" title=\"15.fork函数的作用\"></a>15.fork函数的作用</h1><p>在 Linux 中 fork 函数是非常重要的函数，它的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程。</p>\n<p><strong>调用 fork(),当控制转移到内核中的 fork 代码后，内核开始做：</strong></p>\n<ol>\n<li>分配新的内存块和内核数据结构给子进程。</li>\n<li>将父进程部分数据结构内容拷贝至子进程。</li>\n<li>将子进程添加到系统进程列表。</li>\n<li>fork返回开始调度器，调度。</li>\n</ol>\n<p><strong>特点：</strong></p>\n<p>1)调用一次，返回两次并发执行</p>\n<p>2)相同但是独立的地址空间</p>\n<p>3)fork 的返回值：fock 函数调用一次却返回两次；向父进程返回子进程的 ID，向子进程中返回 0，</p>\n<p>4)fork 的子进程返回为 0；</p>\n<p>5)父进程返回的是子进程的 pid。</p>\n<p><strong>fork 调用失败的原因</strong></p>\n<p>1)系统中有太多进程。</p>\n<p>2)实际用户的进程数超过限制。</p>\n<h1 id=\"16-协程的概念\"><a href=\"#16-协程的概念\" class=\"headerlink\" title=\"16.协程的概念\"></a>16.协程的概念</h1><p><strong>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</strong>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>\n<p>对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。无论是进程还是线程，都是由操作系统所管理的。</p>\n<p><strong>协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行</strong>。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>\n<p><strong>协程既不是进程也不是线程，协程仅仅是一个特殊的函数</strong>，协程它进程和进程不是一个维度的。</p>\n<p>一个进程可以包含多个线程，一个线程可以包含多个协程。</p>\n<p>一个线程内的多个协程虽然可以切换，但是<strong>多个协程是串行执行的，只能在一个线程内运行，没法利用 CPU 多核能力。</strong></p>\n<p>协程与进程一样，切换是存在上下文切换问题的。</p>\n<h1 id=\"17-linux-进程和线程？\"><a href=\"#17-linux-进程和线程？\" class=\"headerlink\" title=\"17.linux 进程和线程？\"></a>17.linux 进程和线程？</h1><p>进程通过 fork()创建</p>\n<p>线程通过 pthread_create() 函数创建</p>\n<h1 id=\"18-通过进程id查看占用的端口，通过端口号查看占用的进程-id\"><a href=\"#18-通过进程id查看占用的端口，通过端口号查看占用的进程-id\" class=\"headerlink\" title=\"18. 通过进程id查看占用的端口，通过端口号查看占用的进程 id\"></a>18. 通过进程id查看占用的端口，通过端口号查看占用的进程 id</h1><p>通过进程id查看占用的端口:<br>netstat -nap | grep 进程id<br>通过端口号查看占用的进程id :<br>netstat -nap | grep 端口号</p>\n<h1 id=\"19-僵尸进程产生的原因\"><a href=\"#19-僵尸进程产生的原因\" class=\"headerlink\" title=\"19.僵尸进程产生的原因\"></a>19.僵尸进程产生的原因</h1><p>**僵尸进程是指它的父进程没有等待(调用 wait/waitpid)**。如果子进程先结束而父进程后结束，即子进程结束后，父进程还在继续运行但是并未调用 wait/waitpid 那子进程就会成为僵尸进程。但如果子进程后结束，即父进程先结束了，但没有调用 wait/waitpid 来等待子进程的结束， 此时子进程还在运行，父进程已经结束。那么并不会产生僵尸进程。应为每个进程结束时， 系统都会扫描当前系统中运行的所有进程，看看有没有哪个进程时刚刚结束的这个进程的子 进程，如果有就有 init 来接管它，成为它的父进程。</p>\n<p><strong>进程设置僵尸状态的目的是维护子进程的信息，以便父进程在以后某个时间获取</strong>。要在当前 进程中生成一个子进程，一般需要调用 fork 这个系统调用，fork 这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，可以通过返回值来判断其 返回点。如果子进程先于父进程退出， 同时父进程又没有调用 wait/waitpid，则该子进程将成为僵尸进程。</p>\n<p>在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是 仍然保留了一些信息（如进程号 pid 退出状态 运行时间等）。这些保留的信息直到进程通过调用 wait/waitpid 时才会释放。这样就导致了一个问题，如果没有调用 wait/waitpid 的话，那 么保留的信息就不会释放。比如进程号就会被一直占用了。但系统所能使用的进程号的有限 的，如果产生大量的僵尸进程，将导致系统没有可用的进程号而导致系统不能创建进程。所 以我们应该避免僵尸进程。</p>\n<p><strong>如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用 的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p>\n<h1 id=\"20-孤儿进程产生的原因？\"><a href=\"#20-孤儿进程产生的原因？\" class=\"headerlink\" title=\"20.孤儿进程产生的原因？\"></a>20.孤儿进程产生的原因？</h1><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤 儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，管理孤儿进程这个重任就落到了 init 进程身上，因此孤儿进程并 不会有什么危害。</p>\n<h1 id=\"21-讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？\"><a href=\"#21-讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？\" class=\"headerlink\" title=\"21.讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？\"></a>21.讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？</h1><p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序。根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>\n<ol>\n<li>用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。</li>\n<li>内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。<br>运行的程序基本都是运行在用户态。如果我们调用操作系统提供的内核态级别的子功能那就需要系统调用了。</li>\n</ol>\n<p>系统调用：<strong>与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都 必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</strong></p>\n<p>系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。补充：</p>\n<p>用户态切换到内核态的几种方式</p>\n<p><strong>系统调用</strong>: 系统调用是用户态主动要求切换到内核态的一种方式， 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</p>\n<p><strong>异常</strong>：当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</p>\n<p><strong>硬件设备的中断</strong>: 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核态的转换。</p>\n<h1 id=\"22-平常用什么-linux-命令比较多\"><a href=\"#22-平常用什么-linux-命令比较多\" class=\"headerlink\" title=\"22.平常用什么 linux 命令比较多\"></a>22.平常用什么 linux 命令比较多</h1><p>pwd:显示当前所在位置</p>\n<p>sudo + 其他命令：管理员身份运行</p>\n<p>grep:需要搜索的字符串，要搜索的文件 –color： 搜索命令 –color表示高亮显示</p>\n<p>ps -A：列出所有进程</p>\n<p>ps -ef | grep 进程关键字</p>\n<p>kill 进程pid：杀死进程</p>\n<p>find 目录 参数 ： 寻找目录（查）。在/home目录下查找以 .txt 结尾的文件名:find /home -name “*.txt” </p>\n<p>ls ：查看目录信息</p>\n<p>free：显示系统内存的使用情况</p>\n<h1 id=\"23-中断的分类\"><a href=\"#23-中断的分类\" class=\"headerlink\" title=\"23.中断的分类\"></a>23.中断的分类</h1><ul>\n<li><p>中断可以分为同步中断（synchronous）和异步中断(asynchronous)。</p>\n</li>\n<li><p>中断可分为硬中断和软中断。</p>\n</li>\n<li><p>中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。</p>\n</li>\n</ul>\n<p>同步中断是在指令执行时由 CPU 主动产生的，受到 CPU 控制，其执行点是可控的。异步中断是 CPU 被动接收到的，由外设发出的电信号引起，其发生时间不可预测。</p>\n<h1 id=\"24-软中断和硬中断\"><a href=\"#24-软中断和硬中断\" class=\"headerlink\" title=\"24.软中断和硬中断\"></a>24.软中断和硬中断</h1><p>从本质上讲，中断(硬)是一种电信号，当设备有某种事情发生的时候，他就会产生中断，通过 总线把电信号发送给中断控制器。如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，跳到中断处理程序的入口点， 进行中断处理。</p>\n<p>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的 IRQ（中断请求）。</p>\n<p>软中断是由当前正在运行的进程所产生的。</p>\n<p>软中断比硬中断少了一个硬件发送信号的步骤。产生软中断的进程一定是当前正在运行的进 程，因此它们不会中断 CPU。但是它们会中断调用代码的流程。如果硬件需要 CPU 去做一些事情，那么这个硬件会使 CPU 中断当前正在运行的代码。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://blog.csdn.net/justloveyou_/article/details/78304294\">https://blog.csdn.net/justloveyou_/article/details/78304294</a></p>\n<p>[2]<a href=\"http://www.cyc2018.xyz/\">http://www.cyc2018.xyz/</a></p>\n<p>[3]<a href=\"https://leetcode-cn.com/circle/discuss/XXGdoF\">https://leetcode-cn.com/circle/discuss/XXGdoF</a></p>\n","categories":["操作系统"]},{"title":"字节面经","url":"/2021/05/10/zijiemianjing210510/","content":"<h2 id=\"字节一面凉经\"><a href=\"#字节一面凉经\" class=\"headerlink\" title=\"字节一面凉经\"></a>字节一面凉经</h2><h2 id=\"垃圾回收机制\"><a href=\"#垃圾回收机制\" class=\"headerlink\" title=\"垃圾回收机制\"></a>垃圾回收机制</h2><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p>\n<p><a href=\"https://www.jianshu.com/p/23f8249886c6\">JVM垃圾回收机制</a></p>\n<h2 id=\"你所使用的垃圾回收器\"><a href=\"#你所使用的垃圾回收器\" class=\"headerlink\" title=\"你所使用的垃圾回收器\"></a>你所使用的垃圾回收器</h2><h3 id=\"Java垃圾收集器的历史\"><a href=\"#Java垃圾收集器的历史\" class=\"headerlink\" title=\"Java垃圾收集器的历史\"></a>Java垃圾收集器的历史</h3><p>第一阶段，Serial（串行）收集器</p>\n<p>在jdk1.3.1之前，java虚拟机仅仅能使用Serial收集器。 Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>\n<p>PS：开启Serial收集器的方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>\n\n<p>第二阶段，Parallel（并行）收集器</p>\n<p>Parallel收集器也称吞吐量收集器，相比Serial收集器，Parallel最主要的优势在于使用多线程去完成垃圾清理工作，这样可以充分利用多核的特性，大幅降低gc时间。</p>\n<p>PS:开启Parallel收集器的方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-XX:+UseParallelGC -XX:+UseParallelOldGC</span><br></pre></td></tr></table></figure>\n\n<p>第三阶段，CMS（并发）收集器</p>\n<p>CMS收集器在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。</p>\n<p>PS:开启CMS收集器的方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure>\n\n<p>第四阶段，G1（并发）收集器</p>\n<p>G1收集器（或者垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4GB）时产生的停顿。相对于CMS的优势而言是内存碎片的产生率大大降低。</p>\n<p>PS:开启G1收集器的方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-XX:+UseG1GC</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"你常用Java的数据结构\"><a href=\"#你常用Java的数据结构\" class=\"headerlink\" title=\"你常用Java的数据结构\"></a>你常用Java的数据结构</h2><p>一、线性表（重点）</p>\n<p>线性表是由N个元素组成的有序序列，也是最常见的一种数据结构。重点有两个数组和链表。</p>\n<p>1、数组</p>\n<p>数组是一种存储单元连续，用来存储固定大小元素的线性表。java中对应的集合实现，比如ArrayList。</p>\n<p>2、链表</p>\n<p>链表又分单链表和双链表，是在物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。java中对应的集合实现，比如LinkedList。</p>\n<p>二、栈与队列</p>\n<p>1、栈</p>\n<p><a href=\"http://file.elecfans.com/web1/M00/A3/63/o4YBAF1VEn2ATJNmAAArq7iRv5U807.jpg\"><img src=\"http://file.elecfans.com/web1/M00/A3/63/o4YBAF1VEn2ATJNmAAArq7iRv5U807.jpg\" alt=\"img\"></a></p>\n<p>栈，是一种运算受限的线性表，重点掌握其后进先出的特点。表的末端叫栈顶，基本操作有push（进栈）和pop（出栈）。java中stack就是简单的栈实现。</p>\n<p>2、队列</p>\n<p>队列也是一种操作受限制的线性表，重点掌握其先进先出的特点。表的前端只允许进行删除操作，表的后端进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。java中很多Queue的实现，消息中间件的队列本质也是基于此的。</p>\n<p>三、树（重点）</p>\n<p>在非线性结构里面，树是非常非常重要的一种数据结构。基于其本身的结构优势，尤其在查找领域，应用广泛，其中又以二叉树最为重要。树的话我们这里只重点说一下二叉树。</p>\n<p>1、二叉搜索树</p>\n<p>二叉搜索树又叫二叉查找树，又叫二叉排序树。性质如下：（1） 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2） 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3） 左、右子树也分别为二叉排序树；（4） 没有键值相等的结点。</p>\n<p>2、平衡二叉树</p>\n<p>平衡二叉树又叫AVL树。性质如下：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</p>\n<p>3、红黑树</p>\n<p><a href=\"http://file.elecfans.com/web1/M00/A3/B6/pIYBAF1VEsOAap9mAAAlCFfvgWs929.jpg\"><img src=\"http://file.elecfans.com/web1/M00/A3/B6/pIYBAF1VEsOAap9mAAAlCFfvgWs929.jpg\" alt=\"img\"></a></p>\n<p>红黑树是一种特殊的平衡二叉树，它保证在最坏情况下基本动态集合操作的事件复杂度为O（log n）。</p>\n<p>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p>\n<p>四、图</p>\n<p>图是比线性表和树更复杂的数据结构，面试中基本不太会问到，大家有兴建的可以自己去了解下。</p>\n<h2 id=\"LinkedHashMap是怎么实现，HashMap是怎么实现的（HashMap、LinkedHashMap、TreeMap）的区别\"><a href=\"#LinkedHashMap是怎么实现，HashMap是怎么实现的（HashMap、LinkedHashMap、TreeMap）的区别\" class=\"headerlink\" title=\"LinkedHashMap是怎么实现，HashMap是怎么实现的（HashMap、LinkedHashMap、TreeMap）的区别\"></a>LinkedHashMap是怎么实现，HashMap是怎么实现的（HashMap、LinkedHashMap、TreeMap）的区别</h2><h3 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h3><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>\n<p><img src=\"https://img-blog.csdn.net/20170512155609530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>　与HashMap相比，LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 <strong>双向链表头结点header</strong> 和 <strong>标志位accessOrder</strong> (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p>\n<p>基本元素 Entry</p>\n<p>　　LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 before 和 after，它们分别用于维护双向链接列表。特别需要注意的是，next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的，源代码如下：</p>\n<p>private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; {</p>\n<pre><code>// These fields comprise the doubly linked list used for iteration.\nEntry&lt;K,V&gt; before, after;\n\nEntry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;\n    super(hash, key, value, next);\n&#125;\n...\n</code></pre>\n<p>}</p>\n<h3 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h3><p>HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</p>\n<p>SortedMap接口：（TreeMap继承自SortedMap）它用来保持键的有序顺序。SortedMap接口为映像的视图(子集)，包括两个端点提供了访问方法。除了排序是作用于映射的键以外，处理SortedMap和处理SortedSet一样。添加到SortedMap实现类的元素必须实现Comparable接口，否则您必须给它的构造函数提供一个Comparator接口的实现。TreeMap类是它的唯一一份实现。</p>\n<p>TreeMap：基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</p>\n<h2 id=\"ConcurrentHashMap是怎么实现的\"><a href=\"#ConcurrentHashMap是怎么实现的\" class=\"headerlink\" title=\"ConcurrentHashMap是怎么实现的\"></a>ConcurrentHashMap是怎么实现的</h2><p> Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。这样对每个segment中的数据需要同步操作的话都是使用每个segment容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的segment。这种做法，就称之为“分离锁”。</p>\n<h2 id=\"线程安全的相关Map有哪些，讲一下是怎么实现的\"><a href=\"#线程安全的相关Map有哪些，讲一下是怎么实现的\" class=\"headerlink\" title=\"线程安全的相关Map有哪些，讲一下是怎么实现的\"></a>线程安全的相关Map有哪些，讲一下是怎么实现的</h2><p>HashMap在多线程环境下是不安全的，jdk1.7中是因为采用的是头插法，在多线程环境下两个线程同时扩容时会出现环链导致死循环；而jdk1.8中改用尾插法，避免了这个情况，但是其put操作在多线程环境下会发生覆盖，导致线程不安全。那在多线程环境下我们应该怎么做呢？</p>\n<ul>\n<li>使用HashTable类</li>\n<li>使用Collections.synchronizedMap(<strong>Map</strong>)创建线程安全的map</li>\n<li>使用ConcurrentHashMap类</li>\n</ul>\n<h2 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h2><p>说HashTable是<strong>线程安全的</strong>是因为HashTable使用了synchronized关键字来保证线程同步。</p>\n<p>我们都知道使用synchronized属于独占式的悲观锁，加上的是重量级锁，当一个线程访问HashTable的同步方法时候，其它的线程只能是阻塞或轮询状态，所以HashTable的并发性是比较差的，效率比较低。翻阅源码还可以得到以下结论：</p>\n<h2 id=\"synchronizedMap\"><a href=\"#synchronizedMap\" class=\"headerlink\" title=\"synchronizedMap\"></a>synchronizedMap</h2><p>因此在jdk1.2中引入了Collections.synchronizedMap(<strong>Map</strong>)，这种相对较灵活的方式来保证<strong>Map</strong>的线程安全。</p>\n<p>内部类SynchronizedMap类维护了一个final类型的<strong>Map</strong>对象，以及一个互斥锁mutex。SynchronizedMap类有两个构造方法，一个只是把<strong>Map</strong>作为参数，那么就将排斥锁mutex赋值为该<strong>Map</strong>。如果再传入一个mutex参数，那么将对象排斥锁赋值为传入的对象，也就是说通过该参数，对<strong>Map</strong>方法的锁定将仅在该Object(mutex)上进行，因此，其灵活性要优于Hashtable，可以特定的为某个对象上锁。</p>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a><strong>ConcurrentHashMap</strong></h2><p>1.7版本</p>\n<p>通过源码我们可以看出每个Segment都继承ReentranLock(可重入锁)并单独加锁，因此每次进行加锁操作时锁住的就是一个Segment，这样我们只要保证每个Segment都是<strong>线程安全的</strong>，就能保证全局的线程安全。</p>\n<p>从上面的源码我们可以看出，jdk1.7中是如何保证segment中的<strong>线程安全的</strong>：首次进入该方法时先尝试获取该segment的锁，若获取失败，则调用 scanAndLockForPut(key, hash, value)方法来尝试自旋获取锁，如果自旋的次数达到了MAX_SCAN_RETRIES(最大自旋次数)，就会变成阻塞获取，确保可以成功获取锁；</p>\n<p>我们可以得出，get()方法不用加锁，而且ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。第一次Hash定位到Segment，第二次Hash定位到元素所在的具体位置上。</p>\n<h3 id=\"JDK1-8中的ConcurrentHashMap类\"><a href=\"#JDK1-8中的ConcurrentHashMap类\" class=\"headerlink\" title=\"JDK1.8中的ConcurrentHashMap类\"></a><strong>JDK1.8中的ConcurrentHashMap类</strong></h3><p>在JDK1.8中舍弃了Segment的概念，直接用Node数组+链表+红黑树的数据结构来实现，了解过JDK1.8中HashMap结构的同学，应该可以看出在JDK1.8中 ConcurrentHashMap结构基本上和HashMap一样，而且它们确实是有着有很多相同之处：</p>\n<ol>\n<li><p>数组的默认容量是16，最大容量是1&lt;&lt;30</p>\n</li>\n<li><p>当添加元素的时候，将列表转成树的阈值是8</p>\n</li>\n<li><p>在对数组扩容的时候，当树中元素个数小于或等于6时，将树转成链表</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/42c96d3ef1ed5fd8a01e18adfab0d27b.png\" alt=\"42c96d3ef1ed5fd8a01e18adfab0d27b.png\">而且我们从源码中也可以看出，其value值和next使用volatile修饰，保证了内存可见性，以及禁止指令重排。</p>\n</li>\n</ol>\n<p>首先ConcurrentHashMap中Node数组被volatile数组修饰，保证了内存可见性，以及禁止指令重排。</p>\n<p>再使用CAS+Synchronized结合来实现赋值的操作，用以确保当前线程操作只锁住该线程操作的节点所在的链表或红黑树，来保证线程安全。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a><strong>总结：</strong></h3><ol>\n<li>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构，提高了遍历的效率，从遍历链表的O(n)，到遍历红黑树的O(logN)。</li>\n<li>保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</li>\n<li>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁(Node)。</li>\n</ol>\n<h2 id=\"你使用过哪些锁\"><a href=\"#你使用过哪些锁\" class=\"headerlink\" title=\"你使用过哪些锁\"></a>你使用过哪些锁</h2><p>过</p>\n<h2 id=\"volatile能完全替代锁吗-其变量存在哪里\"><a href=\"#volatile能完全替代锁吗-其变量存在哪里\" class=\"headerlink\" title=\"volatile能完全替代锁吗,其变量存在哪里\"></a>volatile能完全替代锁吗,其变量存在哪里</h2><p>新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</p>\n<ul>\n<li>volatile 修饰的变量，是直接拿的主内存的值，就是说这个值永远是最新的，对其他线程是可见的。</li>\n<li>而访问非 <code>volatile</code> 变量时，每个线程都会从系统内存（主内存）拷贝变量到工作内存中，然后修改工作内存中的变量值，操控的变量可能不同。</li>\n</ul>\n<h2 id=\"synchronized跟lock的区别\"><a href=\"#synchronized跟lock的区别\" class=\"headerlink\" title=\"synchronized跟lock的区别\"></a>synchronized跟lock的区别</h2><p>过</p>\n<h2 id=\"基于什么样的规则选择哪些锁\"><a href=\"#基于什么样的规则选择哪些锁\" class=\"headerlink\" title=\"基于什么样的规则选择哪些锁\"></a>基于什么样的规则选择哪些锁</h2><h2 id=\"讲一下synchronized是怎么实现的\"><a href=\"#讲一下synchronized是怎么实现的\" class=\"headerlink\" title=\"讲一下synchronized是怎么实现的\"></a>讲一下synchronized是怎么实现的</h2><h3 id=\"synchronized使用场景\"><a href=\"#synchronized使用场景\" class=\"headerlink\" title=\"synchronized使用场景\"></a>synchronized使用场景</h3><p>使用在静态方法上，<code>synchronized</code>锁住的是类对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * synchronized 使用在静态方法上</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;I am test1 method&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用在实例方法上，<code>synchronized</code>锁住的是实例对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedTest</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * synchronized 使用在实例方法上</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">syncOnMethod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;a developer name Jimoer&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized用在代码块上</p>\n<p><code>synchronized</code>的同步代码块用在类实例的对象上，锁住的是当前的类的实例。<br>即执行buildName的时候，整个对象都会被锁住，直到执行完成buildName后释放锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedTest</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 带姓氏的名称</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> firstName 姓氏</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildName</span><span class=\"params\">(String firstName)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setName(firstName+<span class=\"keyword\">this</span>.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized的同步代码块用在类对象上，锁住的是该类的类对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedTest</span> </span>&#123;    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String myName = <span class=\"string\">&quot;Jimoer&quot;</span>;    <span class=\"comment\">/**     * 带姓氏的名称     * <span class=\"doctag\">@param</span> firstName 姓氏     */</span>    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">buildName</span><span class=\"params\">(String firstName)</span></span>&#123;        <span class=\"keyword\">synchronized</span>(SynchronizedTest.class)&#123;            System.out.println(firstName+myName);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized的同步代码块用在任意实例对象上，锁住的就是配置的实例对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedTest</span> </span>&#123;    <span class=\"keyword\">private</span> String lastName;    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLastName</span><span class=\"params\">()</span> </span>&#123;        <span class=\"keyword\">return</span> lastName;    &#125;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLastName</span><span class=\"params\">(String lastName)</span> </span>&#123;        <span class=\"keyword\">this</span>.lastName = lastName;    &#125;    <span class=\"comment\">/**     * 带姓氏的名称     * <span class=\"doctag\">@param</span> firstName 姓氏     */</span>    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildName</span><span class=\"params\">(String firstName)</span></span>&#123;        <span class=\"keyword\">synchronized</span>(lastName)&#123;            System.out.println(firstName+lastName);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized的原理\"><a href=\"#synchronized的原理\" class=\"headerlink\" title=\"synchronized的原理\"></a>synchronized的原理</h3><p>先进行反编译:</p>\n<ul>\n<li>在执行<code>monitorenter</code>指令的时候，首先要去尝试获取对象的锁（<strong>获取对象锁的过程，其实是获取monitor对象的所有权的过程</strong>）。</li>\n<li>如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一。</li>\n<li>而在执行<code>monitorexit</code>指令时会将锁计数器减一。一旦计数器的值为零，锁随即就被释放了。</li>\n<li>如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</li>\n</ul>\n<h3 id=\"monitor对象\"><a href=\"#monitor对象\" class=\"headerlink\" title=\"monitor对象\"></a>monitor对象</h3><p>我在上面说了，获取对象锁的过程，其实是获取monitor对象的所有权的过程。哪个线程持有了monitor对象，那么哪个线程就获得了锁，获得了锁的对象可以重复的来获取monitor对象，但是同一个线程每获取一次monitor对象所有权锁计数就加一，在解锁的时候也是需要将锁计数减成0才算真的释放了锁。<br>monitor对象，我们其实在Java的反编译文件中并没有看到。这个对象是存放在对象头中的。</p>\n<p>这里要说明一下，锁升级的过程是不可逆的。</p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>上面在介绍对象头的时候，说到了对象头中包含的内容了，其中有一个就是偏向锁的线程ID，它代表的意思就是说，如果当一个线程获取到了锁之后，锁的标志计数器就会+1，并且把这个线程的id存储在锁住的这个对象的对象头上面。<br><strong>这个过程是通过CAS来实现的，每次线程进入都是无锁的，当执行CAS成功后，直接将锁的标志计数+1（持有偏向锁的线程以后每次进入锁时不做任何操作，标志计数直接+1），这个时候其他线程再进来时，执行CAS就会失败，也就是获取锁失败。</strong></p>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><p>轻量级锁还是和对象头的第一部分（Mark Word）相关。</p>\n<ul>\n<li>在代码即将进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用户存储锁对象目前的Mark Word的拷贝。</li>\n<li>然后JVM将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，说明线程获取锁成功，并执行后面的同步操作。</li>\n<li>如果这个更新动作失败了，说明锁对象已经被其他线程抢占了，那轻量级锁不在有效，必须膨胀为重量级锁。此时被锁住的对象的标志变为重量级锁的标志。</li>\n</ul>\n<h3 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h3><p>当轻量级锁获取失败后，就会升级为重量级锁，但是重量级锁之前也介绍了是很耗资源的，JVM开发团队注意到许多程序上，共享数据的二锁定状态只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得。<br><strong>所以想到了一个策略，那就是当线程请求一个已经被锁住的对象时，可以让未获取锁的线程“稍等一会”，但不放弃处理器执行时间，只需要让线程执行一个忙循环（自旋），这就是所谓的自旋锁。</strong><br>自旋锁在JDK1.4.2中引入，默认关闭，可以通过-XX:UserSpinning参数来开启，默认自旋次数是10次，用户可以自定义次数，配置参数是-XX:PreBockSpin。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Synchronized减重的过程，通常被称为锁膨胀或是锁升级的过程。<br>主要步骤是：</p>\n<ul>\n<li>先是通过偏向锁来获取锁，解决了虽然有同步但无竞争的场景下锁的消耗。</li>\n<li>再是通过对象头的Mark Word来实现的轻量级锁，通过轻量级锁如果还有竞争，那么继续升级。</li>\n<li>升级为自旋锁，如果达到最大自旋次数了，那么就直接升级为重量级锁，所有未获取锁的线程都阻塞等待。</li>\n</ul>\n<h2 id=\"MySQL的存储引擎\"><a href=\"#MySQL的存储引擎\" class=\"headerlink\" title=\"MySQL的存储引擎\"></a>MySQL的存储引擎</h2><p>过</p>\n<h2 id=\"对索引有什么了解\"><a href=\"#对索引有什么了解\" class=\"headerlink\" title=\"对索引有什么了解\"></a>对索引有什么了解</h2><p>索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。</p>\n<p>索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。</p>\n<p>索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。</p>\n<h2 id=\"建立索引的策略\"><a href=\"#建立索引的策略\" class=\"headerlink\" title=\"建立索引的策略\"></a>建立索引的策略</h2><h3 id=\"适合建索引的字段：\"><a href=\"#适合建索引的字段：\" class=\"headerlink\" title=\"适合建索引的字段：\"></a>适合建索引的字段：</h3><ol>\n<li>经常被查询的字段，即在where子句中出现的字段</li>\n<li>在分组的字段，即在group by子句中出现的字段</li>\n<li>存在依赖关系的子表和父表之间的联合查询，即主键或外键字段</li>\n<li>设置唯一完整性约束的字段</li>\n</ol>\n<h3 id=\"不适合建索引字段：\"><a href=\"#不适合建索引字段：\" class=\"headerlink\" title=\"不适合建索引字段：\"></a>不适合建索引字段：</h3><ol>\n<li>在查询中很少被使用的字段</li>\n<li>拥有许多重复值的字段</li>\n</ol>\n<h2 id=\"索引有哪些类型\"><a href=\"#索引有哪些类型\" class=\"headerlink\" title=\"索引有哪些类型\"></a>索引有哪些类型</h2><p>索引类型<br>Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。</p>\n<h3 id=\"FULLTEXT\"><a href=\"#FULLTEXT\" class=\"headerlink\" title=\"FULLTEXT\"></a>FULLTEXT</h3><p>即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。</p>\n<p>全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%”这类针对文本的模糊查询效率较低的问题。</p>\n<h3 id=\"HASH\"><a href=\"#HASH\" class=\"headerlink\" title=\"HASH\"></a>HASH</h3><p>由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。</p>\n<p>HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</p>\n<p><strong>哈希索引的限制：</strong></p>\n<p>1.哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引的值来避免读取行</p>\n<p>2.哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序</p>\n<p>3.哈希索引不支持部分索引匹配查找(因为哈希索引始终是使用索引列的全部内容来计算哈希值的)</p>\n<p>4.哈希索引只支持等值查询，包括= ，in</p>\n<p>5.当出现哈希冲突(不同的索引列值却有相同的哈希值)时，存储引擎必须遍历链表中所有的行指针，逐个比较直至找到符合条件的行</p>\n<p>6.如果哈希冲突很多，则索引维护操作的代价会很高</p>\n<h3 id=\"BTREE\"><a href=\"#BTREE\" class=\"headerlink\" title=\"BTREE\"></a>BTREE</h3><p>BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</p>\n<h3 id=\"RTREE\"><a href=\"#RTREE\" class=\"headerlink\" title=\"RTREE\"></a>RTREE</h3><p>RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。</p>\n<p>//myisam支持空间索引，可以用作地理数据存储，R-tree无须前缀索引。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。</p>\n<p>相对于BTREE，RTREE的优势在于范围查找。</p>\n<h2 id=\"索引种类\"><a href=\"#索引种类\" class=\"headerlink\" title=\"索引种类\"></a>索引种类</h2><ul>\n<li>普通索引：仅加速查询</li>\n<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>\n<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>\n<li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>\n<li>全文索引：对文本的内容进行分词，进行搜索</li>\n</ul>\n<h2 id=\"什么时候用聚集索引\"><a href=\"#什么时候用聚集索引\" class=\"headerlink\" title=\"什么时候用聚集索引\"></a>什么时候用聚集索引</h2><p><strong>最左前缀原则：</strong></p>\n<p>顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上，</p>\n<p>注：如果第一个字段是范围查询需要单独建一个索引</p>\n<p>注：在创建联合索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。这样的话扩展性较好，比如 userid 经常需要作为查询条件，而 mobile 不常常用，则需要把 userid 放在联合索引的第一位置，即最左边</p>\n<p><strong>联合索引本质：</strong></p>\n<p>当创建(a,b,c)联合索引时，相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引</p>\n<p>想要索引生效的话,只能使用 a，和a,b，和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！</p>\n<p><strong>联合索引总结：</strong></p>\n<p>需要加索引的字段，要在where条件中；</p>\n<p>数据量少的字段不需要加索引（因为建索引有开销，速度反而慢）；</p>\n<p>如果where条件中是or关系，加索引不起作用；</p>\n<p>联合索引比每个列分别建索引更有优势，因为建索引有开销，顺序也要注意，一般不超过7，8个，应该将严格的索引放在前面，这样筛选力度会更大，效率更高。</p>\n<h2 id=\"说一下每个层的主要协议\"><a href=\"#说一下每个层的主要协议\" class=\"headerlink\" title=\"说一下每个层的主要协议\"></a>说一下每个层的主要协议</h2><p>协议分别有：</p>\n<p>1、物理层协议有：EIA/TIA-232， EIA/TIA-499，V.35， V.24，RJ45， Ethernet， 802.3 </p>\n<p>2、数据链路层协议有：Frame Relay，HDLC，PPP， IEEE 802.3/802.2</p>\n<p>3、网络层协议有：IP，IPX，AppleTalk DDP </p>\n<p>4、传输层协议有：TCP，UDP，SPX</p>\n<p>5、会话层协议有：RPC，SQL，NFS，NetBIOS，names，AppleTalk</p>\n<p>6、表示层协议有：TIFF，GIF，JPEG，PICT，ASCII，EBCDIC，encryption</p>\n<p>7、应用层协议有：FTP，WWW，Telnet，NFS，SMTP，Gateway，SNMP1</p>\n<p><img src=\"https://iknow-pic.cdn.bcebos.com/472309f790529822a5d75652daca7bcb0b46d4bf?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg\" alt=\"img\"></p>\n<h2 id=\"Socket属于哪一层\"><a href=\"#Socket属于哪一层\" class=\"headerlink\" title=\"Socket属于哪一层\"></a>Socket属于哪一层</h2><p>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>\n<h2 id=\"TCP与UDP的区别，使用场景\"><a href=\"#TCP与UDP的区别，使用场景\" class=\"headerlink\" title=\"TCP与UDP的区别，使用场景\"></a>TCP与UDP的区别，使用场景</h2><p>过</p>\n","categories":["面经"],"tags":["面经"]},{"title":"计算机网络","url":"/2021/03/23/computer-networks-interview/","content":"<h1 id=\"1-Http和Https的区别\"><a href=\"#1-Http和Https的区别\" class=\"headerlink\" title=\"1.Http和Https的区别\"></a>1.Http和Https的区别</h1><p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>\n<ul>\n<li><p>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p>\n</li>\n<li><p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p>\n</li>\n<li><p>开销：Https通信需要证书，而证书一般需要向认证机构购买；\n　</p>\n</li>\n</ul>\n<p>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>\n<h1 id=\"2-HTTP-是哪一层的协议？http常见的状态码\"><a href=\"#2-HTTP-是哪一层的协议？http常见的状态码\" class=\"headerlink\" title=\"2.HTTP 是哪一层的协议？http常见的状态码\"></a>2.HTTP 是哪一层的协议？http常见的状态码</h1><p>HTTP 协议 属于应用层的协议。</p>\n<p><strong>HTTP 协议是基于 TCP 协议的</strong>，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>\n<p>另外， HTTP协议是无状态的协议，它<strong>无法记录客户端用户的状态</strong> 一般我们都是通过Session 来记录客户端用户的状态。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">状态码</th>\n<th align=\"center\">类别</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1XX</td>\n<td align=\"center\">Informational（信息性状态码）</td>\n<td align=\"center\">接收的请求正在处理</td>\n</tr>\n<tr>\n<td align=\"center\">2XX</td>\n<td align=\"center\">Success（成功状态码）</td>\n<td align=\"center\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td align=\"center\">3XX</td>\n<td align=\"center\">Redirection（重定向状态码）</td>\n<td align=\"center\">需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td align=\"center\">4XX</td>\n<td align=\"center\">Client Error（客户端错误状态码）</td>\n<td align=\"center\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td align=\"center\">5XX</td>\n<td align=\"center\">Server Error（服务器错误状态码）</td>\n<td align=\"center\">服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<h2 id=\"1XX-信息\"><a href=\"#1XX-信息\" class=\"headerlink\" title=\"1XX 信息\"></a>1XX 信息</h2><ul>\n<li><u><strong>100 Continue</strong></u> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>\n</ul>\n<h2 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h2><ul>\n<li><u><strong>200 OK</strong></u></li>\n<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>\n<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>\n</ul>\n<h2 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h2><ul>\n<li><u><strong>301 Moved Permanently</strong></u> ：永久性重定向</li>\n<li><u><strong>302 Found</strong></u> ：临时性重定向</li>\n<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>\n<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>\n<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>\n<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>\n</ul>\n<h2 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h2><ul>\n<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>\n<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>\n<li><u><strong>403 Forbidden</strong></u> ：请求被拒绝。(可能没有权限)</li>\n<li><u><strong>404 Not Found</strong></u> :  没有对应资源</li>\n</ul>\n<h2 id=\"5XX-服务器错误\"><a href=\"#5XX-服务器错误\" class=\"headerlink\" title=\"5XX 服务器错误\"></a>5XX 服务器错误</h2><ul>\n<li><u><strong>500 Internal Server Error</strong></u>  ：服务器正在执行请求时发生错误。（有内部错误）</li>\n<li><u><strong>503 Service Unavailable</strong></u> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>\n</ul>\n<h1 id=\"3-对称式加密与非对称式加密\"><a href=\"#3-对称式加密与非对称式加密\" class=\"headerlink\" title=\"3.对称式加密与非对称式加密\"></a>3.对称式加密与非对称式加密</h1><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称 加密算法有DES、AES等；</p>\n<p>非对称密钥加密，加密和解密使用不同的密钥。通信发送方获得接收方的公开密钥之后，就 可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。可以更安全地将公 开密钥传输给通信发送方；运算速度慢。典型的非对称加密算法有RSA、DSA等</p>\n<p>HTTPS 采用的加密方式: HTTPS 采用混合的加密机制。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</p>\n<h1 id=\"4-HTTP-2-0\"><a href=\"#4-HTTP-2-0\" class=\"headerlink\" title=\"4.HTTP/2.0\"></a>4.HTTP/2.0</h1><h2 id=\"HTTP-1-x-缺陷\"><a href=\"#HTTP-1-x-缺陷\" class=\"headerlink\" title=\"HTTP/1.x 缺陷\"></a>HTTP/1.x 缺陷</h2><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p>\n<ul>\n<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>\n<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>\n<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>\n</ul>\n<h2 id=\"HTTP-2-0\"><a href=\"#HTTP-2-0\" class=\"headerlink\" title=\"HTTP/2.0\"></a>HTTP/2.0</h2><h3 id=\"二进制分帧层\"><a href=\"#二进制分帧层\" class=\"headerlink\" title=\"二进制分帧层\"></a>二进制分帧层</h3><ul>\n<li><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p>\n</li>\n<li><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>\n</li>\n</ul>\n<h3 id=\"服务端推送\"><a href=\"#服务端推送\" class=\"headerlink\" title=\"服务端推送\"></a>服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。</p>\n<h3 id=\"首部压缩\"><a href=\"#首部压缩\" class=\"headerlink\" title=\"首部压缩\"></a>首部压缩</h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>\n<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>\n<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>\n<h1 id=\"5-HTTP报文详解\"><a href=\"#5-HTTP报文详解\" class=\"headerlink\" title=\"5.HTTP报文详解\"></a>5.HTTP报文详解</h1><h2 id=\"请求和响应报文\"><a href=\"#请求和响应报文\" class=\"headerlink\" title=\"请求和响应报文\"></a>请求和响应报文</h2><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p>\n<p>请求报文结构：</p>\n<ul>\n<li>第一行是包含了请求方法、URL、协议版本；</li>\n<li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li>\n<li>一个空行用来分隔首部和内容主体 Body</li>\n<li>最后是请求的内容主体</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET http://www.example.com/ HTTP/1.1</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class=\"line\">Cache-Control: max-age=0</span><br><span class=\"line\">Host: www.example.com</span><br><span class=\"line\">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class=\"line\">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class=\"line\">Proxy-Connection: keep-alive</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla/5.0 xxx</span><br><span class=\"line\"></span><br><span class=\"line\">param1=1&amp;param2=2</span><br></pre></td></tr></table></figure>\n\n<p>响应报文结构：</p>\n<ul>\n<li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li>\n<li>接下来多行也是首部内容</li>\n<li>一个空行分隔首部和内容主体</li>\n<li>最后是响应的内容主体</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Age: 529651</span><br><span class=\"line\">Cache-Control: max-age=604800</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: 648</span><br><span class=\"line\">Content-Type: text/html; charset=UTF-8</span><br><span class=\"line\">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class=\"line\">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class=\"line\">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class=\"line\">Keep-Alive: timeout=4</span><br><span class=\"line\">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class=\"line\">Proxy-Connection: keep-alive</span><br><span class=\"line\">Server: ECS (sjc/16DF)</span><br><span class=\"line\">Vary: Accept-Encoding</span><br><span class=\"line\">X-Cache: HIT</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!doctype html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Example Domain&lt;/title&gt;</span><br><span class=\"line\">\t// 省略... </span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-HTTP-1-1-新特点\"><a href=\"#6-HTTP-1-1-新特点\" class=\"headerlink\" title=\"6.HTTP/1.1 新特点\"></a>6.HTTP/1.1 新特点</h1><ul>\n<li>默认是长连接</li>\n<li>支持流水线</li>\n<li>支持同时打开多个 TCP 连接</li>\n<li>支持虚拟主机</li>\n<li>新增状态码 100</li>\n<li>支持分块传输编码</li>\n<li>新增缓存处理指令 max-age</li>\n</ul>\n<h1 id=\"7-GET和POST的区别\"><a href=\"#7-GET和POST的区别\" class=\"headerlink\" title=\"7.GET和POST的区别\"></a>7.GET和POST的区别</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 <strong>请求头</strong> 中。而POST请求会把提交的数据则放置在是HTTP请求报文的 **请求体 **中。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>\n<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>\n<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>\n<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>\n<h2 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>\n<p>所有的安全方法也都是幂等的。</p>\n<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>\n<h2 id=\"请求的大小\"><a href=\"#请求的大小\" class=\"headerlink\" title=\"请求的大小\"></a>请求的大小</h2><p>GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p>\n<h1 id=\"8-TCP-IP-4-层模型了解么\"><a href=\"#8-TCP-IP-4-层模型了解么\" class=\"headerlink\" title=\"8.TCP/IP 4 层模型了解么\"></a>8.TCP/IP 4 层模型了解么</h1><p>TCP/IP 4 层模型:</p>\n<ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层</li>\n</ol>\n<h1 id=\"9-OSI网络体系结构与TCP-IP协议模型\"><a href=\"#9-OSI网络体系结构与TCP-IP协议模型\" class=\"headerlink\" title=\"9.OSI网络体系结构与TCP/IP协议模型\"></a>9.OSI网络体系结构与TCP/IP协议模型</h1><p>​    我们知道TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对OSI七层模型的各层进行简要的介绍：</p>\n<p>　　　　　　　　　<img src=\"http://static.zybuluo.com/Rico123/0qwq331jj8bzgmqst282f6lp/OSI%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8ETCPIP%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png\" alt=\"OSI网络体系结构与TCPIP协议模型.png-51.3kB\">　</p>\n<p>1). 物理层</p>\n<p>　　参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。</p>\n<p>2). 数据链路层（data link layer）</p>\n<p>　　接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p>\n<p>3). 网络层</p>\n<p>　　将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。</p>\n<p>　　　　　　<img src=\"http://static.zybuluo.com/Rico123/ed9145bf4nus32fr7umxxnk7/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E8%B7%AF%E5%B1%82.png\" alt=\"数据链路层与网路层.png-58.4kB\">　　　　</p>\n<p>4). 传输层（transport layer）</p>\n<p>　　在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。</p>\n<p>　　　　　<img src=\"http://static.zybuluo.com/Rico123/5td1y45fm09cbhgw07o6fgfc/%E7%BD%91%E8%B7%AF%E5%B1%82%E4%B8%8E%E4%BC%A0%E8%BE%93%E5%B1%82.png\" alt=\"网路层与传输层.png-52.8kB\">　　　　　</p>\n<p>　　实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。</p>\n<p>5). 会话层（Session Layer）</p>\n<p>　　会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。</p>\n<p>6). 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密</p>\n<p>　　表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p>\n<p>7). 应用层（Application layer）：为用户的应用进程提供网络通信服务</p>\n<h1 id=\"10-三次握手\"><a href=\"#10-三次握手\" class=\"headerlink\" title=\"10.三次握手\"></a>10.三次握手</h1><p><img src=\"/images/pasted-210323threehandshake.jpg\"></p>\n<p><img src=\"/images/pasted-210323fourhandshake.jpg\"></p>\n<p><img src=\"/images/pasted-210323statechange.jpg\"></p>\n<h2 id=\"文字说明\"><a href=\"#文字说明\" class=\"headerlink\" title=\"文字说明\"></a>文字说明</h2><p>三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：</p>\n<ul>\n<li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>\n</li>\n<li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>\n</li>\n<li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>\n</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/Rico123/c7m5fo6qdua0q7me88jm9w10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png\" alt=\"三次握手.png-12.4kB\"></p>\n<h2 id=\"三次握手的原因\"><a href=\"#三次握手的原因\" class=\"headerlink\" title=\"三次握手的原因\"></a>三次握手的原因</h2><p>三次握手的目的是建立可靠的通信信道，三次握手最主要的目的就是双方确认自己与对方的 发送与接收是正常的。</p>\n<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>\n<h2 id=\"为什么两次不行\"><a href=\"#为什么两次不行\" class=\"headerlink\" title=\"为什么两次不行\"></a>为什么两次不行</h2><p>​        为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。</p>\n<p>　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p>\n<h1 id=\"11-四次挥手\"><a href=\"#11-四次挥手\" class=\"headerlink\" title=\"11.四次挥手\"></a>11.四次挥手</h1><p><img src=\"/images/pasted-210323groupchange.jpg\"></p>\n<h2 id=\"文字说明-1\"><a href=\"#文字说明-1\" class=\"headerlink\" title=\"文字说明\"></a>文字说明</h2><ul>\n<li><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>\n</li>\n<li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p>\n</li>\n<li><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>\n</li>\n<li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。<br><img src=\"http://static.zybuluo.com/Rico123/ardiuu1otopo9f1jd4df18iz/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\" alt=\"四次挥手.png-12.6kB\"></p>\n</li>\n</ul>\n<h2 id=\"CLOSE-WAIT-状态问题：\"><a href=\"#CLOSE-WAIT-状态问题：\" class=\"headerlink\" title=\"CLOSE-WAIT 状态问题：\"></a>CLOSE-WAIT 状态问题：</h2><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN 连接释放报文。</p>\n<h2 id=\"TIME-WAIT-状态问题-这个问题问过很多次但总是答得不甚满意-：\"><a href=\"#TIME-WAIT-状态问题-这个问题问过很多次但总是答得不甚满意-：\" class=\"headerlink\" title=\"TIME-WAIT 状态问题(这个问题问过很多次但总是答得不甚满意)：\"></a>TIME-WAIT 状态问题(这个问题问过很多次但总是答得不甚满意)：</h2><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>\n<p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>\n<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一 个新的连接不会出现旧的连接请求报文。</p>\n<p>通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。</p>\n<h1 id=\"12-TCP滑动窗口是干什么的\"><a href=\"#12-TCP滑动窗口是干什么的\" class=\"headerlink\" title=\"12.TCP滑动窗口是干什么的\"></a>12.TCP滑动窗口是干什么的</h1><p>滑动窗口：窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接 收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>\n<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。接收窗口只会对窗口内 最后一个按序到达的字节进行确认。如果发送窗口内的字节已经发送并且收到了确认，那么 就将发送窗口向右滑动一定距离，直到第一个字节不是已发送并且已确认的状态；接收窗口 的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向滑动接收窗口。</p>\n<h1 id=\"13-TCP的可靠性体现在哪里\"><a href=\"#13-TCP的可靠性体现在哪里\" class=\"headerlink\" title=\"13.TCP的可靠性体现在哪里\"></a>13.TCP的可靠性体现在哪里</h1><p>对于可靠性，TCP通过以下方式进行保证：</p>\n<ul>\n<li><p>数据包校验（校验和）：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>\n</li>\n<li><p>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>\n</li>\n<li><p>丢弃重复数据：对于重复数据，能够丢弃重复数据；</p>\n</li>\n<li><p>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>\n</li>\n<li><p>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>\n</li>\n<li><p>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>\n</li>\n<li><p>拥塞控制：当网络拥塞时，减少数据的发送。</p>\n</li>\n</ul>\n<h1 id=\"14-TCP流量控制\"><a href=\"#14-TCP流量控制\" class=\"headerlink\" title=\"14.TCP流量控制\"></a>14.TCP流量控制</h1><p><strong>流量控制如何实现</strong>：流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>\n<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送 速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<h1 id=\"15-拥塞控制如何实现\"><a href=\"#15-拥塞控制如何实现\" class=\"headerlink\" title=\"15.拥塞控制如何实现\"></a>15.拥塞控制如何实现</h1><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞 程度更高。因此当出现拥塞时，应当控制发送方的速率。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>\n<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。</p>\n<p>1）<strong>慢启动：</strong>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p>\n<p>2） <strong>拥塞避免：</strong>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。如果出现了超时，则令慢开始门限 = 拥塞窗口大小 / 2，然后重新执行慢开始。</p>\n<p><img src=\"http://static.zybuluo.com/Rico123/whi0y5sbc3tx9qcdp0s532gw/%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png\" alt=\"慢开始与拥塞避免.png-90.3kB\"></p>\n<p>3）<strong>快重传：</strong>快重传要求接收方在收到一个 <strong>失序的报文段</strong> 后就立即发出 <strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>\n<p><img src=\"http://static.zybuluo.com/Rico123/wuktdms9jtg4s9m4pe5kcbiq/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg\" alt=\"快重传.jpg-42.3kB\"></p>\n<p>4）<strong>快恢复</strong>：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>\n<h1 id=\"16-TCP和UDP有什么区别？及其适用的场景\"><a href=\"#16-TCP和UDP有什么区别？及其适用的场景\" class=\"headerlink\" title=\"16.TCP和UDP有什么区别？及其适用的场景\"></a>16.TCP和UDP有什么区别？及其适用的场景</h1><p>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：</p>\n<ul>\n<li><p>TCP是面向连接的，UDP是无连接的；</p>\n</li>\n<li><p>TCP是可靠的，UDP是不可靠的；</p>\n</li>\n<li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p>\n</li>\n<li><p>TCP是面向字节流的，UDP是面向报文的；</p>\n</li>\n<li><p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p>\n</li>\n<li><p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p>\n</li>\n</ul>\n<p><strong>TCP应用场景</strong>：</p>\n<p>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、 排序等操作，相比之下效率没有UDP高。举几个例子：文件传输、接受邮件、远程登录。</p>\n<p><strong>UDP应用场景</strong>：</p>\n<p>效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话、广播通信（广播、多播）。</p>\n<p>1). TCP对应的应用层协议</p>\n<ul>\n<li><p>FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</p>\n</li>\n<li><p>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</p>\n</li>\n<li><p>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</p>\n</li>\n<li><p>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p>\n</li>\n<li><p>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</p>\n</li>\n</ul>\n<p>2). UDP对应的应用层协议</p>\n<ul>\n<li><p>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p>\n</li>\n<li><p>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>\n</li>\n<li><p>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p>\n</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/Rico123/r3gm4e6y9hlgqllw8ba10676/TCP%E5%92%8CUDP%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.png\" alt=\"TCP和UDP分别对应的常见应用层协议.png-41.5kB\"></p>\n<h1 id=\"17-UDP为何快\"><a href=\"#17-UDP为何快\" class=\"headerlink\" title=\"17.UDP为何快\"></a>17.UDP为何快</h1><p><strong>UDP为何快？</strong></p>\n<ol>\n<li>不需要建立连接</li>\n<li>对于收到的数据，不用给出确认</li>\n<li>没有超时重发机制</li>\n<li>没有流量控制和拥塞控制</li>\n</ol>\n<h1 id=\"18-Mac-地址和-ip-地址的区别？既然有了-Mac-地址，为什么还要-ip-地址呢？\"><a href=\"#18-Mac-地址和-ip-地址的区别？既然有了-Mac-地址，为什么还要-ip-地址呢？\" class=\"headerlink\" title=\"18.Mac 地址和 ip 地址的区别？既然有了 Mac 地址，为什么还要 ip 地址呢？\"></a>18.Mac 地址和 ip 地址的区别？既然有了 Mac 地址，为什么还要 ip 地址呢？</h1><p>MAC地址是烧录在网卡或者接口上的<strong>物理地址</strong>，具有<strong>全球唯一性</strong>，一般不能被改变。IP地址是网络中的主机或接口在网络中的<strong>逻辑地址</strong>，在<strong>同一个网络内具有唯一性</strong>。</p>\n<h1 id=\"19-当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。\"><a href=\"#19-当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。\" class=\"headerlink\" title=\"19.当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。\"></a>19.当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。</h1><ol>\n<li>浏览器查找域名的IP地址 （DNS：获取域名对应的IP）</li>\n<li> 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>\n<li>TCP/IP链接建立起来后，浏览器向web服务器发送HTTP请求（cookies会随着请求发送给服务器）</li>\n<li>服务器处理请求 （请求 处理请求 参数、cookies、生成一个HTML响应）</li>\n<li>服务器返回HTTP报文，发回一个HTML响应。</li>\n<li>浏览器解析渲染页面，浏览器开始显示HTML。</li>\n<li>连接结束</li>\n</ol>\n<p>使用的协议:</p>\n<p><strong>DNS</strong>: 获取域名对应的IP TCP: 与服务器建立TCP连接</p>\n<p><strong>IP</strong>: 建立TCP协议时，需要发送数据，发送数据在网络层上使用IP协议</p>\n<p><strong>OSPF</strong>：IP数据包在路由器之间，路由选择使用OSPF协议</p>\n<p><strong>ARP</strong>：路由器在与服务器进行通信的过程中，将IP地址装换成MAC地址</p>\n<p><strong>HTTP</strong>：客户端浏览器与Web服务器之间的应用层通信协议，在TCP建立完成后，使用HTTP协议访问网页</p>\n<h1 id=\"20-网络层的ARP协议工作原理\"><a href=\"#20-网络层的ARP协议工作原理\" class=\"headerlink\" title=\"20.网络层的ARP协议工作原理\"></a>20.<strong>网络层的ARP协议工作原理</strong></h1><p>​    <strong>网络层的ARP协议完成了IP地址与物理地址的映射</strong>。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>\n<h1 id=\"21-电子邮件的发送过程\"><a href=\"#21-电子邮件的发送过程\" class=\"headerlink\" title=\"21.电子邮件的发送过程?\"></a>21.电子邮件的发送过程?</h1><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>\n<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>\n<ol>\n<li>用户A的邮箱是QQ邮箱，他要发往的邮箱是163邮箱，用户A写好一封邮件点击发送， 即提交到了QQ邮箱服务器，使用的是SMTP协议。</li>\n<li>QQ邮箱会对A发送邮件的收件地址进行解析，判断是否为内部邮箱的账号，如果也是QQ邮箱，会直接存储到自己的存储空间，如果不是则会发送到指定邮箱服务器，使用 的也是SMTP协议。</li>\n<li>163的邮箱服务器收到邮件后会再次判断该邮件是否为自己的邮件，如果是则存到自己的存储空间，等待POP3服务去读取邮件。</li>\n<li>用户B收到消息后，打开客户端访问163服务器，调用POP3服务。</li>\n<li>Pop3服务接到指令后，读取存储空间中发送给B的未读邮件服务。</li>\n<li>将读取到的邮件返回给客户端软件。</li>\n</ol>\n<h1 id=\"22-DNS解析过程，DNS劫持了解吗？\"><a href=\"#22-DNS解析过程，DNS劫持了解吗？\" class=\"headerlink\" title=\"22.DNS解析过程，DNS劫持了解吗？\"></a>22.DNS解析过程，DNS劫持了解吗？</h1><p>DNS完成的工作是：域名到IP地址的解析。将域名和IP地址相互映射的一个分布式数据库。</p>\n<ul>\n<li><p>第一步：客户机提出域名解析请求，并将该请求发送给本地域名服务器。</p>\n</li>\n<li><p>第二步：当本地域名服务器收到请求后，就先查询本地缓存，如果有该纪录项，则本地域名服务器就直接把查询结果返回。</p>\n</li>\n<li><p>第三步：如果本地缓存中没该纪录，则本地域名服务器就直接把请求发给根域名服务器，然 后根域名服务器再返回给本地域名服务器一个所查询域(根子域)主域名服务器地址。</p>\n</li>\n<li><p>第四步：本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自 己的缓存，如果没该纪录，则返回相关下级域名服务器地址。</p>\n</li>\n<li><p>第五步：重复第四步，直到找到正确纪录。</p>\n</li>\n<li><p>第六步：本地域名服务器把返回结果保存到缓存，以备下一次使用，同时还将结果返回给客 户机。</p>\n</li>\n</ul>\n<p>DNS劫持：在DNS服务器中，将www..com的域名对应的IP地址进行了变化。你解析出来的 域名对应的IP，在劫持前后不一样。</p>\n<p>HTTP劫持：你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。</p>\n<p>DNS在区域传输的时候使用TCP协议,其他时候使用UDP协议。</p>\n<h1 id=\"23-session和cookie的问题？\"><a href=\"#23-session和cookie的问题？\" class=\"headerlink\" title=\"23.session和cookie的问题？\"></a>23.session和cookie的问题？</h1><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式</p>\n<p>Cookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录用户的状态</p>\n<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将Cookie 信息加密然后使用到的时候再去服务器端解密。</p>\n<h1 id=\"24-HTTP是不保存状态的协议-如何保存用户状态\"><a href=\"#24-HTTP是不保存状态的协议-如何保存用户状态\" class=\"headerlink\" title=\"24.HTTP是不保存状态的协议,如何保存用户状态?\"></a>24.HTTP是不保存状态的协议,如何保存用户状态?</h1><p>HTTP 是一种无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。主要通过session机制来进行解决，Session 的主要作用就是通过服务端记录用户的状态。</p>\n<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下， 我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>\n<p>ps:<strong>Cookie</strong> 被禁用怎么办： 最常用的就是利用 URL 把 Session ID 直接附加在URL路径的后面。</p>\n<h1 id=\"25-Session-与-Cookie-的对比\"><a href=\"#25-Session-与-Cookie-的对比\" class=\"headerlink\" title=\"25.Session 与 Cookie 的对比\"></a>25.Session 与 Cookie 的对比</h1><ul>\n<li><p>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p>\n</li>\n<li><p>大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>\n</li>\n<li><p>安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>\n</li>\n<li><p>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>\n</li>\n</ul>\n<h1 id=\"26-IP地址的划分\"><a href=\"#26-IP地址的划分\" class=\"headerlink\" title=\"26.IP地址的划分\"></a>26.IP地址的划分</h1><p>IP 地址的编址方式经历了三个历史阶段：</p>\n<ul>\n<li>分类</li>\n<li>子网划分</li>\n<li>无分类</li>\n</ul>\n<h2 id=\"1-分类\"><a href=\"#1-分类\" class=\"headerlink\" title=\"1. 分类\"></a>1. 分类</h2><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>\n<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>\n<p><img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png\" alt=\"img\"></p>\n<ul>\n<li>A类地址：以0开头，第一个字节范围：0~127；（地址范围1.0.0.0到127.255.255.255）</li>\n<li>B类地址：以10开头，第一个字节范围：128~191；（地址范围128.0.0.0-191.255.255.255）</li>\n<li>C类地址：以110开头，第一个字节范围：192~223；（地址范围192.0.0.0-223.255.255.255）</li>\n<li>D类地址：以1110开头，第一个字节范围为224~239；（地址范围224.0.0.0到239.255.255.255。）</li>\n<li>E类地址：以1111开头，保留地址</li>\n</ul>\n<h2 id=\"2-子网划分\"><a href=\"#2-子网划分\" class=\"headerlink\" title=\"2. 子网划分\"></a>2. 子网划分</h2><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>\n<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>\n<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>\n<p>注意，外部网络看不到子网的存在。</p>\n<h2 id=\"3-无分类\"><a href=\"#3-无分类\" class=\"headerlink\" title=\"3. 无分类\"></a>3. 无分类</h2><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>\n<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>\n<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>\n<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>\n<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p>\n<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>\n<h1 id=\"27-DDos攻击了解吗？\"><a href=\"#27-DDos攻击了解吗？\" class=\"headerlink\" title=\"27.DDos攻击了解吗？\"></a>27.DDos攻击了解吗？</h1><p>分布式拒绝服务，一般来说是指攻击者利用一些被控制的设备对目标网站在较短的时间内发 起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1]<a href=\"https://leetcode-cn.com/circle/discuss/XXGdoF\">https://leetcode-cn.com/circle/discuss/XXGdoF</a></p>\n<p>[2]<a href=\"https://blog.csdn.net/justloveyou_/article/details/78303617?spm=1001.2014.3001.5501\">https://blog.csdn.net/justloveyou_/article/details/78303617?spm=1001.2014.3001.5501</a></p>\n<p>[3]<a href=\"http://www.cyc2018.xyz/\">http://www.cyc2018.xyz/</a></p>\n","categories":["计算机网络"],"tags":["面试"]},{"title":"美团面经准备","url":"/2021/05/24/meituanmianjing210524/","content":"<h1 id=\"抽象类和接口的区别\"><a href=\"#抽象类和接口的区别\" class=\"headerlink\" title=\"抽象类和接口的区别\"></a>抽象类和接口的区别</h1><p>含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p>\n<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p>\n<p>下面比较一下两者的语法区别：</p>\n<ol>\n<li><p>抽象类可以有构造方法，接口中不能有构造方法。</p>\n</li>\n<li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量</p>\n</li>\n<li><p>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>\n</li>\n<li><p>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</p>\n</li>\n<li><p>抽象类中可以包含静态方法，接口中不能包含静态方法</p>\n</li>\n<li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</p>\n</li>\n<li><p>一个类可以实现多个接口，但只能继承一个抽象类。</p>\n</li>\n</ol>\n<p>具体参考：<a href=\"https://blog.csdn.net/qq_41933748/article/details/82670072\">抽象类和接口的区别（面试题）</a></p>\n<h1 id=\"为什么volatile-可以保证可见性-但不能保证原子性\"><a href=\"#为什么volatile-可以保证可见性-但不能保证原子性\" class=\"headerlink\" title=\"为什么volatile 可以保证可见性,但不能保证原子性\"></a>为什么volatile 可以保证可见性,但不能保证原子性</h1><h2 id=\"保证可见性：\"><a href=\"#保证可见性：\" class=\"headerlink\" title=\"保证可见性：\"></a>保证可见性：</h2><p>内存屏障（<a href=\"http://en.wikipedia.org/wiki/Memory_barrier\">memory barrier</a>） 是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障， 相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会 把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p>\n<p>内存屏障和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在<strong>写操作后</strong>插入一个写屏障 指令，在<strong>读操作前</strong>插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将 会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。 </p>\n<p>明白了内存屏障这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但<strong>中间的几步（从Load到Store）</strong>是不安全的，中间如果其他的CPU修改了值将会丢失。</p>\n<p>所以volatile不能保证i++操作的原子性</p>\n<h2 id=\"不能保证原子性：\"><a href=\"#不能保证原子性：\" class=\"headerlink\" title=\"不能保证原子性：\"></a>不能保证原子性：</h2><p>当需要使用被volatile修饰的变量时，线程会从主内存中重新获取该变量的值，但当该线程修改完该变量的值写入主内存的时候，并没有判断主内存内该变量是否已经变化，故可能出现非预期的结果。如主内存内有被volatile修饰变量 a，值为3，某线程使用该变量时，重新从主存内读取该变量的值，为3，然后对其进行+1操作，此时该线程内a变量的副本值为4。但此时该线程的时间片时间到了，等该线程再次获得时间片的时候，主存内a的值已经是另外的值，如5，但是该线程并不知道，该线程继续完成其未完成的工作，将线程内的a副本的值4写入主存，这时，主存内a的值就是4了。这样，之前修改a的值为5的操作就相当于没有发生了，a的值出现了意料之外的结果。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_32534441/article/details/88596268\">volatile 可以保证可见性，但不能保证原子性</a></p>\n<h1 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h1><p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_35583772/article/details/90167214\">从原始到最新的垃圾回收器</a></p>\n<h1 id=\"集合类\"><a href=\"#集合类\" class=\"headerlink\" title=\"集合类\"></a>集合类</h1><h2 id=\"1-集合类的作用\"><a href=\"#1-集合类的作用\" class=\"headerlink\" title=\"(1).集合类的作用\"></a><strong>(1).集合类的作用</strong></h2><p>集合类也叫做容器类，和数组一样，用于存储数据，但数组类型单一，并且长度固定，限制性很大，而集合类可以动态增加长度。</p>\n<p>集合存储的元素都是对象(引用地址)，所以集合可以存储不同的数据类型，但如果是需要比较元素来排序的集合，则需要类型一致。</p>\n<p>集合中提供了统一的增删改查方法，使用方便。</p>\n<p>支持泛型，避免数据不一致和转换异常，还对常用的数据结构进行了封装。</p>\n<p>所有的集合类的都在java.util包下。</p>\n<h2 id=\"2-集合框架体系的组成\"><a href=\"#2-集合框架体系的组成\" class=\"headerlink\" title=\"(2)集合框架体系的组成\"></a><strong>(2)集合框架体系的组成</strong></h2><p>集合框架体系是由Collection、Map(映射关系)和Iterator(迭代器)组成，各部分的作用如下所示。</p>\n<h3 id=\"1-Collection体系中有三种集合：Set、List、Queue\"><a href=\"#1-Collection体系中有三种集合：Set、List、Queue\" class=\"headerlink\" title=\"[1]Collection体系中有三种集合：Set、List、Queue\"></a><strong>[1]Collection体系中有三种集合：Set、List、Queue</strong></h3><p> Set(集)： 元素是无序的且不可重复。</p>\n<p> List(列表)：元素是有序的且可重复。</p>\n<p> Queue(队列)：封装了数据结构中的队列。</p>\n<h3 id=\"2-Map体系\"><a href=\"#2-Map体系\" class=\"headerlink\" title=\"[2]Map体系\"></a><strong>[2]Map体系</strong></h3><p> Map用于保存具有映射关系的数据，即key-value(键值对)。Map集合的key是唯一的，不可重复，而value可以重复。所以一个value可以对应多个key。</p>\n<p> Map体系除了常用类之外，还有Properties（属性类）也属于Map体系。</p>\n<h3 id=\"3-Iterator-迭代器\"><a href=\"#3-Iterator-迭代器\" class=\"headerlink\" title=\"[3]Iterator(迭代器)\"></a><strong>[3]Iterator(迭代器)</strong></h3><p>请查看上面! </p>\n<h1 id=\"hashmap的hash函数\"><a href=\"#hashmap的hash函数\" class=\"headerlink\" title=\"hashmap的hash函数\"></a>hashmap的hash函数</h1><p>hash() 方法对 hashCode 分别无符号右移 （&gt;&gt;&gt;） 7 位和 4 位，再与自身进行异或（^）处理。</p>\n<p>推荐看一下：</p>\n<p><a href=\"https://blog.csdn.net/q5706503/article/details/85114159\">深入理解 hashcode() 和 HashMap 中的hash 算法</a></p>\n<h1 id=\"BIO与NIO、AIO的区别\"><a href=\"#BIO与NIO、AIO的区别\" class=\"headerlink\" title=\"BIO与NIO、AIO的区别\"></a>BIO与NIO、AIO的区别</h1><p>Java对BIO、NIO、AIO的支持：</p>\n<ul>\n<li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>\n<li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li>\n<li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li>\n</ul>\n<p>BIO、NIO、AIO适用场景分析:</p>\n<ul>\n<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>\n<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>\n<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>\n</ul>\n<h1 id=\"JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰\"><a href=\"#JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰\" class=\"headerlink\" title=\"JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰\"></a>JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰</h1><p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/tianjindong0804/article/details/81710268\">JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰</a></p>\n<h1 id=\"cookie和session常见面试题\"><a href=\"#cookie和session常见面试题\" class=\"headerlink\" title=\"cookie和session常见面试题\"></a>cookie和session常见面试题</h1><p>1、cookie和session原理及区别   </p>\n<p>cookie采用的是客户端的会话状态的一种储存机制。它是服务器在本地机器上存储的小段文本或者是内存中的一段数据，并随每一个请求发送至同一个服务器。</p>\n<p>session是一种服务器端的信息管理机制，它把这些文件信息以文件的形式存放在服务器的硬盘空间上（这是默认情况，可以用memcache把这种数据放到内存里面）当客户端向服务器发出请求时，要求服务器端产生一个session时，服务器端会先检查一下，客户端的cookie里面有没有session_id，是否过期。如果有这样的session_id的话，服务器端会根据cookie里的session_id把服务器的session检索出来。如果没有这样的session_id的话，服务器端会重新建立一个。PHPSESSID是一串加了密的字符串，它的生成按照一定的规则来执行。同一客户端启动二次session_start的话，session_id是不一样的。 </p>\n<p>区别：Cookie保存在客户端浏览器中，而Session保存在服务器上。Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>\n<hr>\n<p>2、  session产生的session_id放在cookie里面，如果用户把cookie禁止掉，是不是session也不能用了呢？</p>\n<p>禁止掉cookie后，session当然可以用，不过通过其他的方式来获得这个sessionid，比如，可以跟在url的后面，或者以表单的形势提交到服务器端。从而使服务器端了解客户端的状态。</p>\n<hr>\n<p>3、  为什么说session 比cookie更安全？</p>\n<p>真正的cookie存在于客户端硬盘上的一个文本文件，如果两者一样的话，只要cookie就好了，让客户端来分提服务器的负担，并且对于用户来说又是透明的。但实际上不是。</p>\n<p>session的sessionID是放在cookie里，要想功破session的话，得分两步：</p>\n<p>第一要得到sessionID。攻破cookie后，你要得到sessionID,sessionID是要有人登录，或者启动session_start才会有，你不知道什么时候会有人登录。</p>\n<p>第二取有效sessionID。sessionID是加密的，第二次session_start的时候，前一次的sessionID就没有用了，session过期时sessionid也会失效，想在短时间内功破加了密的 sessionID很难。session是针对某一次通信而言，会话结束session也就随着消失了。<br>使session失效的方法：<br>1.关闭tomcat  2.重启web应用  3.session时间到  4.无效的session</p>\n<hr>\n<p>cookie和session的区别：</p>\n<p>①存在的位置：</p>\n<p>cookie 存在于客户端，临时文件夹中；  session存在于服务器的内存中，一个session域对象为一个用户浏览器服务</p>\n<p>②安全性<br>cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；  session存放于服务器的内存中，所以安全性好</p>\n<p>③网络传输量<br>cookie会传递消息给服务器；  session本身存放于服务器，不会有传送流量</p>\n<p>④生命周期(以20分钟为例)<br>cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束；<br>session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁。但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期。关机会造成session生命周期的结束，但是对cookie没有影响</p>\n<p>⑤访问范围<br>cookie为多个用户浏览器共享；  session为一个用户浏览器独享<br>————————————————<br>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78552633\">cookie和session常见面试题</a></p>\n<h1 id=\"Java匿名内部类\"><a href=\"#Java匿名内部类\" class=\"headerlink\" title=\"Java匿名内部类\"></a>Java匿名内部类</h1><p>具体参考：</p>\n<p> <a href=\"https://www.cnblogs.com/wuhenzhidu/p/anonymous.html\">JAVA匿名内部类(Anonymous Classes)</a></p>\n<h1 id=\"post能不能把数据放到url里面\"><a href=\"#post能不能把数据放到url里面\" class=\"headerlink\" title=\"post能不能把数据放到url里面\"></a>post能不能把数据放到url里面</h1><p>应该能，但放在url里能访问的数据太少，可能不够</p>\n<h1 id=\"进程通信方式（详解）\"><a href=\"#进程通信方式（详解）\" class=\"headerlink\" title=\"进程通信方式（详解）\"></a>进程通信方式（详解）</h1><h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><ol>\n<li>管道为空时，读操作会被阻塞；管道满时，写操作会被阻塞 </li>\n<li>可以有多个进程读写，只是不能同时写。    </li>\n<li>匿名管道只能单向，命名管道可以双向。    </li>\n<li>管道是在内存中。</li>\n</ol>\n<h3 id=\"匿名管道：\"><a href=\"#匿名管道：\" class=\"headerlink\" title=\"匿名管道：\"></a>匿名管道：</h3><p>管道是IPC最基本的一种实现机制。我们都知道在Linux下“一切皆文件”，其实这里的管道就是一个文件。管道实现进程通信就是让两个进程都能访问该文件。<br>管道的特征：<br>①只提供单向通信，也就是说，两个进程都能访问这个文件，假设进程1往文件内写东西，那么进程2 就只能读取文件的内容。<br>②只能用于具有血缘关系的进程间通信，通常用于父子进程建通信<br>③管道是基于字节流来通信的<br>④依赖于文件系统，它的生命周期随进程的结束结束（随进程）<br>⑤其本身自带同步互斥效果</p>\n<h3 id=\"命名管道（FIFO）\"><a href=\"#命名管道（FIFO）\" class=\"headerlink\" title=\"命名管道（FIFO）\"></a>命名管道（FIFO）</h3><p>上述管道虽然实现了进程间通信，但是它具有一定的局限性：首先，这个管道只能是具有血缘关系的进程之间通信；第二，它只能实现一个进程写另一个进程读，而如果需要两者同时进行时，就得重新打开一个管道。<br>为了使任意两个进程之间能够通信，就提出了命名管道（named pipe 或 FIFO）。<br>1、与管道的区别：提供了一个路径名与之关联，以FIFO文件的形式存储于文件系统中，能够实现任何两个进程之间通信。而匿名管道对于文件系统是不可见的，它仅限于在父子进程之间的通信。<br>2、FIFO是一个设备文件，在文件系统中以文件名的形式存在，因此即使进程与创建FIFO的进程不存在血缘关系也依然可以通信，前提是可以访问该路径。<br>3、FIFO(first input first output)总是遵循先进先出的原则，即第一个进来的数据会第一个被读走。</p>\n<p>那么知道什么是命名管道后我们如何通过一个命名管道实现两个进程之间通信呢？？？？同上一样，我们先给出函数：</p>\n<h3 id=\"二者区别\"><a href=\"#二者区别\" class=\"headerlink\" title=\"二者区别\"></a>二者区别</h3><p>命名管道与匿名管道使用的区别：<br>命名管道创建完成后就可以使用，其使用方法与管道一样，区别在于：命名管道使用之前需要使用open()打开。这是因为：命名管道是设备文件，它是存储在硬盘上的，而管道是存在内存中的特殊文件。但是需要注意的是，命名管道调用open()打开有可能会阻塞，但是如果以读写方式（O_RDWR）打开则一定不会阻塞；以只读（O_RDONLY）方式打开时，调用open()的函数会被阻塞直到有数据可读；如果以只写方式（O_WRONLY）打开时同样也会被阻塞，知道有以读方式打开该管道。</p>\n<h2 id=\"信号（Signal）\"><a href=\"#信号（Signal）\" class=\"headerlink\" title=\"信号（Signal）\"></a>信号（Signal）</h2><p>信号是比较复杂的通信方式，用于通知接受进程有某种事件发生。</p>\n<p><strong>SIGINT</strong>：ctrl+c 终止信号</p>\n<p>SIGTSTP:ctrl+z 暂停信号</p>\n<p>SIGCHLD：子进程状态改变，父进程收到信号</p>\n<p>SIGKILL：杀死信号</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>\n<p>先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>\n<p>解耦</p>\n<p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p>\n<p><img src=\"https://pic3.zhimg.com/v2-176cf95bae99a81c9531733d7e36f5e6_b.jpg\" alt=\"img\"></p>\n<p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p>\n<p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p>\n<p><img src=\"https://pic4.zhimg.com/v2-6b109327d85feeb52144a4398faf4ae7_b.jpg\" alt=\"img\"></p>\n<p><strong>总结</strong>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p>\n<p><strong>面试技巧</strong>：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</p>\n<p>异步</p>\n<p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p>\n<p><img src=\"https://pic4.zhimg.com/v2-a0de9e2326358225d2ab542881862dbb_b.jpg\" alt=\"img\"></p>\n<p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p>\n<p>如果<strong>使用 MQ</strong>，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p>\n<p><img src=\"https://pic1.zhimg.com/v2-212009a1822e7b38ad1f42a00f6a7294_b.jpg\" alt=\"img\"></p>\n<p>削峰</p>\n<p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p>\n<p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p>\n<p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p>\n<p><img src=\"https://pic2.zhimg.com/v2-5daf297f23003c6a5cfcd87aa7c9ed99_b.jpg\" alt=\"img\"></p>\n<p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p>\n<p><img src=\"https://pic4.zhimg.com/v2-ebe47086a4494ce5b4963f1d05e7984b_b.jpg\" alt=\"img\"></p>\n<p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p>\n<p>消息队列有什么优缺点</p>\n<p>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>\n<p>缺点有以下几个：</p>\n<ul>\n<li>系统可用性降低</li>\n<li>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以点击这里查看。</li>\n<li>系统复杂度提高</li>\n<li>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li>\n<li>一致性问题</li>\n<li>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</li>\n</ul>\n<h2 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h2><p>使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p>\n<p> 在java语言中，基本上没有说起共享内存这个概念。</p>\n<p>在jdk1.4中提供的类MappedByteBuffer为咱们实现共享内存提供了较好的方法。该缓冲区其实是一个磁盘文件的内存映像。两者的变化将保持同步，即内存数据发生变化会马上反映到磁盘文件中，这样会有效的保证共享内存的实现。</p>\n<h2 id=\"信号量（semaphore）\"><a href=\"#信号量（semaphore）\" class=\"headerlink\" title=\"信号量（semaphore）\"></a>信号量（semaphore）</h2><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>\n<p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p>\n<p>如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p>\n<h2 id=\"套接口（Socket）\"><a href=\"#套接口（Socket）\" class=\"headerlink\" title=\"套接口（Socket）\"></a>套接口（Socket）</h2><p>套接口（Socket）：更为一般的进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。可用于不同机器之间的进程间通信。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/Longtermevolution/article/details/107243574\">java进程间通信的几种方式？对比总结</a></p>\n<p><a href=\"https://blog.csdn.net/jdliyao/article/details/79836882\">java 管道</a></p>\n<p><a href=\"https://blog.csdn.net/qq_33951180/article/details/68959819\">匿名管道和命名管道</a></p>\n<p> <a href=\"https://www.cnblogs.com/carsonwuu/p/10399527.html\">Java消息队列</a></p>\n<h1 id=\"临界区，互斥量，信号量\"><a href=\"#临界区，互斥量，信号量\" class=\"headerlink\" title=\"临界区，互斥量，信号量\"></a>临界区，互斥量，信号量</h1><p>四种进程或线程同步互斥的控制方法<br>1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>2、互斥量:为协调共同对一个共享资源的单独访问而设计的。<br>3、信号量:为控制一个具有有限数量用户资源而设计。<br>4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>\n<p>1.临界区（Critical Section）<br>       保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。<br>      临界区包含两个操作原语： </p>\n<p>EnterCriticalSection（） 进入临界区<br>LeaveCriticalSection（） 离开临界区<br>EnterCriticalSection（） 语句执行后代码将进入临界区以后无论发生什么，必须确保与之匹配的 LeaveCriticalSection（）都能够被执行到。否则临界区保护的共享资源将永远不会被释放。虽然临界区同步速度很快，但却只能用来同步本 进程内的线程，而不可用来同步多个进程中的线程。 </p>\n<p>​        </p>\n<p>2.互斥量（Mutex）<br>       互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。 </p>\n<p>互斥量包含的几个操作原语：<br>CreateMutex（） 创建一个互斥量<br>OpenMutex（） 打开一个互斥量<br>ReleaseMutex（） 释放互斥量<br>WaitForMultipleObjects（） 等待互斥量对象 </p>\n<ol start=\"3\">\n<li><p>信号量（Semaphores）</p>\n<p>信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源 ，这与操作系统中的PV操作相同。它指出了同时访问共享 资源的线程 最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。在用CreateSemaphore（）创建信号量 时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数 就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目， 不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可 用资源计数加1。在任何时候当前可用资源计数决不可能大于最大资源计数。 </p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_36582604/article/details/82078249\">java并发编程——临界区，互斥量，信号量</a></p>\n</li>\n</ol>\n<h1 id=\"“-”和equals的差别\"><a href=\"#“-”和equals的差别\" class=\"headerlink\" title=\"“==”和equals的差别\"></a>“==”和equals的差别</h1><p><strong>一、java当中的数据类型和“==”的含义：</strong></p>\n<ul>\n<li>基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。</li>\n<li>引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是<strong>堆内存</strong>地址）。</li>\n</ul>\n<p>注：对于第二种类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。</p>\n<p><strong>二、equals()方法介绍：</strong></p>\n<p>JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object obj) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;this - s1</span><br><span class=\"line\">    &#x2F;&#x2F;obj - s2</span><br><span class=\"line\">    return (this &#x3D;&#x3D; obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。<br>所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。</p>\n<p>我们对上面的两段内容做个总结吧：</p>\n<p> <strong>== 的作用：</strong><br>　　基本类型：比较的就是值是否相同<br>　　引用类型：比较的就是地址值是否相同<br><strong>equals 的作用:</strong><br>　　引用类型：默认情况下，比较的是地址值。<br>注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同</p>\n<p><strong>三、String类的equals()方法：</strong></p>\n<p>现在我们拿String类来举例：</p>\n<p>我们去\\src\\java\\lang目录中找到String类，发现equals方法被重写如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span>     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"number\">2</span>         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\"> <span class=\"number\">3</span>             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"> <span class=\"number\">4</span>         &#125;</span><br><span class=\"line\"> <span class=\"number\">5</span>         <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\"> <span class=\"number\">6</span>             String anotherString = (String)anObject;</span><br><span class=\"line\"> <span class=\"number\">7</span>             <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\"> <span class=\"number\">8</span>             <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\"> <span class=\"number\">9</span>                 <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\"><span class=\"number\">10</span>                 <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\"><span class=\"number\">11</span>                 <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">12</span>                 <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"number\">13</span>                     <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\"><span class=\"number\">14</span>                         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">15</span>                     i++;</span><br><span class=\"line\"><span class=\"number\">16</span>                 &#125;</span><br><span class=\"line\"><span class=\"number\">17</span>                 <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">18</span>             &#125;</span><br><span class=\"line\"><span class=\"number\">19</span>         &#125;</span><br><span class=\"line\"><span class=\"number\">20</span>         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">21</span>     &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码可以看出，String类中被复写的equals()方法其实是比较两个字符串的内容。下面我们通过实际代码来看看String类的比较。</p>\n<p>1、举例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringDemo</span> </span>&#123;</span><br><span class=\"line\"><span class=\"number\">2</span>     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"number\">3</span>         String s1 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"><span class=\"number\">4</span>         String s2 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>         System.out.println(s1 == s2);   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">6</span>     &#125;</span><br><span class=\"line\"><span class=\"number\">7</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上方代码中，用“==”比较s1和s2，返回的结果是true。</p>\n<p>2、稍微改动一下程序，会有奇怪的发现：</p>\n<p><img src=\"https://common.cnblogs.com/images/copycode.gif\" alt=\"复制代码\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">1</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringDemo</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"number\">2</span>     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"number\">3</span>         String str1 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"> <span class=\"number\">4</span>         String str2 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\"> <span class=\"number\">5</span>         String str3 = str2; <span class=\"comment\">// 引用传递</span></span><br><span class=\"line\"> <span class=\"number\">6</span>         System.out.println(str1 == str2); <span class=\"comment\">// false</span></span><br><span class=\"line\"> <span class=\"number\">7</span>         System.out.println(str1 == str3); <span class=\"comment\">// false</span></span><br><span class=\"line\"> <span class=\"number\">8</span>         System.out.println(str2 == str3); <span class=\"comment\">// true</span></span><br><span class=\"line\"> <span class=\"number\">9</span>         System.out.println(str1.equals(str2)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">10</span>         System.out.println(str1.equals(str3)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">11</span>         System.out.println(str2.equals(str3)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">12</span>     &#125;</span><br><span class=\"line\"><span class=\"number\">13</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p> 上方第4行代码中，我们new了一个对象，用“==”比较s1和s2，返回的结果却是false；而用用“equals”比较s1和s2，返回的结果是true。 </p>\n<p>为了分析上面的代码，我们必须首先分析堆内存空间和栈内存空间，这一点非常重要：</p>\n<p><img src=\"https://images0.cnblogs.com/blog/641601/201408/221553240496054.png\" alt=\"img\"></p>\n<p>看完上面的图，再结合上面的代码，就一目了然了。现在我们可以给自己出一道面试题：</p>\n<p><strong>面试题：请解释字符串比较之中“==”和equals()的区别？</strong></p>\n<ul>\n<li> ==：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；</li>\n<li> equals()：比较的是两个字符串的内容，属于内容比较。</li>\n</ul>\n<p><strong>以后进行字符串相等判断的时候都使用equals()。</strong></p>\n<p>3、再次更改程序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectDemo</span></span>&#123;</span><br><span class=\"line\"><span class=\"number\">2</span>     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"number\">3</span>         String s1 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"><span class=\"number\">4</span>         String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\"><span class=\"number\">5</span>         s2 = s2.intern();</span><br><span class=\"line\"><span class=\"number\">6</span>         System.out.println(s1 == s2);       <span class=\"comment\">//  true</span></span><br><span class=\"line\"><span class=\"number\">7</span>         System.out.println(s1.equals(s2));  <span class=\"comment\">//  true</span></span><br><span class=\"line\"><span class=\"number\">8</span>     &#125;</span><br><span class=\"line\"><span class=\"number\">9</span> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>上述代码的第5行中，java.lang.String的intern()方法”abc”.intern()方法的返回值还是字符串”abc”，表面上看起来好像这个方法没什么用处。但实际上，它做了个小动作：检查字符串池里是否存在”abc”这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把”abc”添加到字符串池中，然后再返回它的引用。</p>\n<h1 id=\"Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。\"><a href=\"#Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。\" class=\"headerlink\" title=\"Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。\"></a><strong>Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。</strong></h1><p>　总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。</p>\n<p>  于是，Java采用了哈希表的原理。哈希算法也称为散列算法，当集合要添加新的元素时，将对象通过哈希算法计算得到哈希值（正整数），然后将哈希值和集合（数组）长度进行&amp;运算，得到该对象在该数组存放的位置索引。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就表示发生冲突了，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。</p>\n<p>  这样一来，实际调用equals方法比较的次数就大大降低了，几乎只需要一两次。</p>\n<p>  <strong>简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！</strong></p>\n<h1 id=\"Java-对象的equal方法和hashCode方法的关系\"><a href=\"#Java-对象的equal方法和hashCode方法的关系\" class=\"headerlink\" title=\"Java  对象的equal方法和hashCode方法的关系\"></a><strong>Java  对象的equal方法和hashCode方法的关系</strong></h1><p><strong>首先，Java对象相同指的是两个对象通过eqauls方法判断的结果为true</strong></p>\n<p>Java对象的eqauls方法和hashCode方法是这样规定的：</p>\n<p><strong>1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。</strong></p>\n<p><strong>2、如果两个对象的hashCode相同，它们并不一定相同。</strong></p>\n<p>关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？</p>\n<p> 想象一下，假如两个Java对象A和B，A和B相等（eqauls结果为true），但A和B的哈希码不同，则A和B存入HashMap时的哈希码计算得到的HashMap内部数组位置索引可能不同，那么A和B很有可能允许同时存入HashMap，显然相等/相同的元素是不允许同时存入HashMap，HashMap不允许存放重复元素。</p>\n<p> <strong>关于第二点，两个对象的hashCode相同，它们并不一定相同</strong></p>\n<p> 也就是说，不同对象的hashCode可能相同；假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_41125219/article/details/81981805\">HashMap中实现原理及hashcode方法</a></p>\n<h1 id=\"HashMap怎么解决hash冲突\"><a href=\"#HashMap怎么解决hash冲突\" class=\"headerlink\" title=\"HashMap怎么解决hash冲突\"></a>HashMap怎么解决hash冲突</h1><p>HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。当程序执行 map.put(String,Obect)方法 时，系统将调用String的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置。</p>\n<p>源码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> putForNullKey(value);  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key.hashCode());  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = indexFor(hash, table.length);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">            Object k;  </span><br><span class=\"line\">            <span class=\"comment\">//判断当前确定的索引位置是否存在相同hashcode和相同key的元素，如果存在相同的hashcode和相同的key的元素，那么新值覆盖原来的旧值，并返回旧值。  </span></span><br><span class=\"line\">            <span class=\"comment\">//如果存在相同的hashcode，那么他们确定的索引位置就相同，这时判断他们的key是否相同，如果不相同，这时就是产生了hash冲突。  </span></span><br><span class=\"line\">            <span class=\"comment\">//Hash冲突后，那么HashMap的单个bucket里存储的不是一个 Entry，而是一个 Entry 链。  </span></span><br><span class=\"line\">            <span class=\"comment\">//系统只能必须按顺序遍历每个 Entry，直到找到想搜索的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry 是最早放入该 bucket 中），  </span></span><br><span class=\"line\">            <span class=\"comment\">//那系统必须循环到最后才能找到该元素。  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class=\"line\">                V oldValue = e.value;  </span><br><span class=\"line\">                e.value = value;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        modCount++;  </span><br><span class=\"line\">        addEntry(hash, key, value, i);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125; </span><br></pre></td></tr></table></figure>\n\n<p>当创建 HashMap 时，有一个默认的负载因子（load factor），其默认值为 0.75，这是时间和空间成本上一种折衷：增大负载因子可以减少 Hash 表（就是那个 Entry 数组）所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的的操作（HashMap 的 get() 与 put() 方法都要用到查询）；减小负载因子会提高数据查询的性能，但会增加 Hash 表所占用的内存空间。<br>其中loadFactor加载因子是表示Hsah表中元素的填满的程度.</p>\n<p>若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.链表长度会越来越长,查找效率降低。反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏（很多空间还没用，就开始扩容了）</p>\n<p>冲突的机会越大,则查找的成本越高.</p>\n<p>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的”时-空”矛盾的平衡与折衷.</p>\n<p>如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/lanzhupi/article/details/109616944\">16面试常问：你能谈谈HashMap怎样解决hash冲突吗</a></p>\n<h1 id=\"java泛型\"><a href=\"#java泛型\" class=\"headerlink\" title=\"java泛型\"></a>java泛型</h1><p>具体参考：</p>\n<p><a href=\"https://www.jianshu.com/p/5972220efc9a\">java泛型你需要知道的一切</a></p>\n<h1 id=\"阻塞队列详解\"><a href=\"#阻塞队列详解\" class=\"headerlink\" title=\"阻塞队列详解\"></a>阻塞队列详解</h1><p>具体参考：</p>\n<p> <a href=\"https://www.cnblogs.com/tjudzj/p/4454490.html\">BlockingQueue（阻塞队列）详解</a></p>\n<h1 id=\"浏览器输入网址之后发生了什么？——url全过程\"><a href=\"#浏览器输入网址之后发生了什么？——url全过程\" class=\"headerlink\" title=\"浏览器输入网址之后发生了什么？——url全过程\"></a>浏览器输入网址之后发生了什么？——url全过程</h1><p>浏览器输入网址之后发生了什么<br>一、DNS域名解析<br>域名系统（英文：Domain Name System，缩写：DNS）</p>\n<p>1、浏览器自己的DNS缓存中找，没有就下一步</p>\n<p>2、在操作系统的DNS缓存中找</p>\n<p>3、操作系统本地自己的host文件中找</p>\n<p>4、操作系统就向本地域名服务器发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果找不到，运营商DNS服务器会代我们向根域名服务器发起迭代查询请求，得到顶级域名服务器的IP，根向顶级域名服务器得到权限域名服务器IP，顶级域名服务器向权限域名服务器发请求得到IP，得到了这个IP后，本地域名服务器返回IP给操作系统，同时将IP缓存下来，操作系统在还给浏览器，同时缓存IP</p>\n<p>二、与服务器建立连接<br>TCP连接的建立</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200923143246516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE4NTgyNg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020092314331484.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE4NTgyNg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li>Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</li>\n<li>Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</li>\n<li>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</li>\n</ol>\n<p>三、发起HTTP连接<br><strong>Http是什么？</strong></p>\n<p>http协议是超文本传输，通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。</p>\n<p>四个基于：</p>\n<p><strong>请求与响应：</strong>客户端发送请求，服务器端响应数据</p>\n<p><strong>无状态的：</strong>协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。</p>\n<p><strong>应用层</strong>： Http是属于应用层的协议，配合TCP/IP使用。</p>\n<p><strong>TCP/IP</strong>： Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。</p>\n<p><strong>HTTP请求报文结构</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200923143437600.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE4NTgyNg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>1.请求行：</p>\n<p>例如：POST /chapter17/user.html HTTP/1.1</p>\n<p>格式：请求方式 资源路径 协议/版本</p>\n<p>2.请求方法</p>\n<p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p>\n<p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p>\n<p>网络体系（OSI七层、TCP/IP四层、五层）</p>\n<p>3.协议版本</p>\n<p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>\n<p>四、服务器响应HTTP请求，浏览器得到html代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">··[状态码]()</span><br><span class=\"line\">1xx: 信息性状态码</span><br><span class=\"line\">  100, 101</span><br><span class=\"line\">2xx: 成功状态码</span><br><span class=\"line\">  200：OK</span><br><span class=\"line\">3xx: 重定向状态码</span><br><span class=\"line\">  301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;</span><br><span class=\"line\">  302: 临时重定向，显式重定向, Location响应首部的值为新的URL</span><br><span class=\"line\">  304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可。</span><br><span class=\"line\">4xx: 客户端错误状态码</span><br><span class=\"line\">  404: Not Found  请求的URL资源并不存在</span><br><span class=\"line\">5xx: 服务器端错误状态码</span><br><span class=\"line\">  500: Internal Server Error  服务器内部错误</span><br><span class=\"line\">  502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现</span><br><span class=\"line\">  504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应</span><br></pre></td></tr></table></figure>\n\n<p>五、浏览器解析html代码，并请求html代码中的资源<br>六、 浏览器对页面进行渲染呈现给用户<br>七、TCP断开连接<br>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_41185826/article/details/108752571\">浏览器输入网址之后发生了什么？</a></p>\n<h1 id=\"三大范式\"><a href=\"#三大范式\" class=\"headerlink\" title=\"三大范式\"></a>三大范式</h1><p>第一范式： 所有字段值都是不可分解的原子值 。例如有一个列是电话号码一个人可能有一个办公电话一个移动电话。第一范式就需要拆开成两个属性。<br>第二范式：非主属性完全函数依赖于候选键。如PersonID，ProductID，ProductName，PersonName可以看到，OrderID和ProductID是联合主键，但是ProductName是依赖于ProductID的，只依赖了部分主键，没有依赖全部主键。需要拆分成三个表：PersonID, PersonName, ProductID, ProductName和PersonID, ProductID<br>第三范式： 每一列数据都和主键直接相关，而不能间接相关<br>如OrderID，ProductID，ProductName，OrderID是主键，但是ProductID依赖了OrderID，而ProductName依赖了ProductID，等于说是间接依赖了OrderID，所以需要拆分为两个表：OrderID, ProductID和ProductID, ProductName</p>\n<p><strong>这里需要指明范式不是最好的，我们需要混合使用范式和反范式</strong></p>\n<ul>\n<li>范式的优点：因为相对来说有较少的重复数据，范式化的更新操作要比反范式快。同时范式化需要更少的distinct和order by</li>\n<li>范式化缺点：通常需要关联，不仅代价昂贵，也可能会使的一些索引无效</li>\n</ul>\n<p>常用的反范式方法：</p>\n<ul>\n<li>复制：在两个表中根据实际业务情况存储<strong>部分</strong>相同的字段列，即有利于查询，也不会把表搞的太大</li>\n<li>缓存：对于需要多次join查询的表，可以在一个表中加入一个缓存列，用来缓存所join表的部分常用数据，如count等，我们需要实时更新该缓存</li>\n</ul>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_43968895/article/details/107052903\">MySql面试题总结</a></p>\n<h1 id=\"网络分层及常用网络设备所在的层\"><a href=\"#网络分层及常用网络设备所在的层\" class=\"headerlink\" title=\"网络分层及常用网络设备所在的层\"></a>网络分层及常用网络设备所在的层</h1><table>\n<thead>\n<tr>\n<th align=\"left\">TCP/IP</th>\n<th align=\"left\">OSI</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">应用层</td>\n<td align=\"left\">应用层  表示层  会话层</td>\n</tr>\n<tr>\n<td align=\"left\">主机到主机层（TCP）（又称传输层）</td>\n<td align=\"left\">传输层</td>\n</tr>\n<tr>\n<td align=\"left\">网络层（IP）(又称互联层)</td>\n<td align=\"left\">网络层</td>\n</tr>\n<tr>\n<td align=\"left\">网络接口层（又称链路层）</td>\n<td align=\"left\">数据链路层</td>\n</tr>\n<tr>\n<td align=\"left\">物理层</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>物理层设备：中继器，集线器</p>\n<p>数据链路层设备：网桥，交换机</p>\n<p>网路层设备：三层交换机，路由器</p>\n<p><img src=\"https://iknow-pic.cdn.bcebos.com/b151f8198618367a54183fc324738bd4b31ce51f?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg\" alt=\"img\"></p>\n<p><img src=\"https://iknow-pic.cdn.bcebos.com/0d338744ebf81a4c9c98acd7dd2a6059252da602?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg\" alt=\"img\"></p>\n<h1 id=\"HashMap的时间复杂度分析\"><a href=\"#HashMap的时间复杂度分析\" class=\"headerlink\" title=\"HashMap的时间复杂度分析\"></a>HashMap的时间复杂度分析</h1><p>不管插入还是查找，由key获取hash值然后定位到桶的时间复杂度都是O（1），那么真正决定时间复杂度的实际上是桶里面链表/红黑树的情况</p>\n<p>如果桶里面没有元素，那么直接将元素插入/或者直接返回未查找到，时间复杂度就是O（1），如果里面有元素，那么就沿着链表进行遍历，时间复杂度就是O（n），链表越短时间复杂度越低，如果是红黑树的话那就是O（logn）</p>\n<p>所以平均复杂度很难说，只能说在最优的情况下是O（1）</p>\n<h1 id=\"mysql怎么实现主从复制\"><a href=\"#mysql怎么实现主从复制\" class=\"headerlink\" title=\"mysql怎么实现主从复制\"></a>mysql怎么实现主从复制</h1><ol>\n<li>Master开启bin-log功能，服务器配置二进制日志（binlog日志），只保留update等的数据。</li>\n<li>需要开启三个线程，Master：I/O线程；Slave：I/O线程，SQL线程。</li>\n<li>从数据库会请求主数据库的binlog日志，将bin-log日志内容写入到relay-log中继日志，创建一个master.info文件，然后按日志执行</li>\n<li>Slave已经开启了sql线程，由sql线程实时监测relay-log日志内容是否有更新，如果有更新，则解析文件中的sql语句，并在Slave数据库中执行相同的操作语句。</li>\n</ol>\n<h1 id=\"数据库备份\"><a href=\"#数据库备份\" class=\"headerlink\" title=\"数据库备份\"></a>数据库备份</h1><h2 id=\"备份方式\"><a href=\"#备份方式\" class=\"headerlink\" title=\"备份方式\"></a>备份方式</h2><h3 id=\"逻辑备份\"><a href=\"#逻辑备份\" class=\"headerlink\" title=\"逻辑备份\"></a>逻辑备份</h3><p>SQL级别的备份机制，其将数据表导成SQL脚本文件，然后相当于在另一台服务器上执行一遍备份的SQL语句。</p>\n<ul>\n<li><p><strong>操作语句：</strong> 使用<code>mysqldump</code>语句来实现，具体语句为：</p>\n<p><code>mysqldump -h主机名 -P端口 -u用户名 -p密码 --database 数据库名 &gt; 文件名.sql</code></p>\n</li>\n<li><p><strong>优点：</strong> 恢复简单、与存储引擎无关，消除了底层数据存储的不同，有助于避免数据损坏</p>\n</li>\n<li><p><strong>缺点：</strong> 必须有数据库完成逻辑工作，需要更多地CPU周期，且逻辑备份还原慢</p>\n</li>\n</ul>\n<h3 id=\"物理备份\"><a href=\"#物理备份\" class=\"headerlink\" title=\"物理备份\"></a>物理备份</h3><p>是基于文件的物理备份，比较类似于拷贝数据库的文件，然后复制到另一台服务器加载。</p>\n<ul>\n<li><strong>优点：</strong> 容易跨平台、跨操作系统和MySQL版本，且恢复起来很快</li>\n<li><strong>缺点：</strong> 文件比较大，不总是可以跨平台、操作系统和MySQL版本</li>\n</ul>\n<h1 id=\"LRU的实现方案\"><a href=\"#LRU的实现方案\" class=\"headerlink\" title=\"LRU的实现方案\"></a>LRU的实现方案</h1><ol>\n<li>用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。</li>\n<li>利用一个链表来实现，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。</li>\n<li>利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。</li>\n</ol>\n<h1 id=\"Java包装类、拆箱和装箱详解\"><a href=\"#Java包装类、拆箱和装箱详解\" class=\"headerlink\" title=\"Java包装类、拆箱和装箱详解\"></a>Java包装类、拆箱和装箱详解</h1><p>Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。</p>\n<table>\n<thead>\n<tr>\n<th>基本数据类型</th>\n<th>对应的包装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n</tbody></table>\n<p>每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。</p>\n<p>基本类型和对应的包装类可以相互装换：<br>• 由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；<br>• 包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</p>\n<h3 id=\"1-包装类的特点\"><a href=\"#1-包装类的特点\" class=\"headerlink\" title=\"1.包装类的特点\"></a>1.包装类的特点</h3><p>(1)所有的包装类都是final类型，因此不能创建它们的子类。<br>(2)包装类是不可变类，一个包装类的对象创建后，它所包含的基本数据类型就不能被改变。</p>\n<h2 id=\"自动拆箱和装箱\"><a href=\"#自动拆箱和装箱\" class=\"headerlink\" title=\"自动拆箱和装箱\"></a>自动拆箱和装箱</h2><p>上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。</p>\n<p>Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/y396397735/article/details/79394637\"> Java包装类、拆箱和装箱详解</a></p>\n<h1 id=\"Object-类\"><a href=\"#Object-类\" class=\"headerlink\" title=\"Object 类\"></a>Object 类</h1><p>1.Object类的简单介绍<br>1）Java中的类都会默认继承Object类。Object类是所有类的父类。因此所有类的对象都可以用Object类进行接收。<br>            2）所有Java类都继承了Object类的方法，包括wait()、notify()、equals()和toString().<br>            3）如果一个类希望接收所有的数据类型，那么考虑使用Object类。</p>\n<p>2.Object类的方法<br>2.1 构造方法</p>\n<p>  public Object(){}//方法体为空<br>2.2 其它方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span><span class=\"comment\">//比较两个对象是否相等</span></span></span><br><span class=\"line\"><span class=\"function\">2 <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">()</span><span class=\"comment\">//从等待池中唤醒另一个线程，把它转移到锁池。</span></span></span><br><span class=\"line\"><span class=\"function\">3 <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyAll</span><span class=\"params\">()</span><span class=\"comment\">//从等待池中唤醒所有的线程，把它转移到锁池。</span></span></span><br><span class=\"line\"><span class=\"function\">4 <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;<span class=\"comment\">//使当前线程进入等待状态，直到别的线程调用notify()或notifyAll()方法唤醒它。</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span><span class=\"comment\">//返回对象的哈希码。</span></span></span><br><span class=\"line\"><span class=\"function\">6 <span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span><span class=\"comment\">//返回当前对象的字符串表示。格式为“类名@对象的十六进制哈希码&quot;</span></span></span><br><span class=\"line\"><span class=\"function\">7 <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable<span class=\"comment\">//对于一个不被任何变量引用的对象，当垃圾回收器准备回收该对象所占用的内存时，将自动调用该对象的finalize()方法。</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/smell201611010513/article/details/89886448\">Java之Object类与包装类</a></p>\n<h1 id=\"为什么要有object类\"><a href=\"#为什么要有object类\" class=\"headerlink\" title=\"为什么要有object类\"></a>为什么要有object类</h1><p>（1）可以使不同对象之间可以统一、互转。我觉得其中还包括 toString(),wait()…等公共方法的统一定义</p>\n<p>（2）对父类的逻辑处理统一，不需要根据有没有父类分两种实现，</p>\n<h1 id=\"java的根类Object详细分析\"><a href=\"#java的根类Object详细分析\" class=\"headerlink\" title=\"java的根类Object详细分析\"></a>java的根类Object详细分析</h1><p> hashCode()方法返回一个整形数值，表示该对象的哈希码值。</p>\n<p> <strong>hashCode()具有如下约定：</strong></p>\n<p> 1).在Java应用程序程序执行期间，对于同一对象<strong>多次调用hashCode()方法时，其返回的哈希码是相同的</strong>，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致；</p>\n<p>2).如果<strong>两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等</strong>；</p>\n<p>3).反之，两个对象调用h<strong>asCode()返回的哈希码相等，这两个对象不一定相等。</strong></p>\n<p>​    即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt;  equals()相等  =&gt; hashCode()相等。因此，<strong>重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立</strong>，同时可以推理出：<strong>hasCode()不相等 =&gt; equals（）不相等 &lt;=&gt; 两个对象不相等。</strong></p>\n<h3 id=\"注意：先用hasCode-方法去判断再用equals方法判断\"><a href=\"#注意：先用hasCode-方法去判断再用equals方法判断\" class=\"headerlink\" title=\"注意：先用hasCode()方法去判断再用equals方法判断\"></a>注意：先用hasCode()方法去判断再用equals方法判断</h3><p>可能有人在此产生疑问：既然比较两个对象是否相等的唯一条件（也是冲要条件）是equals，那么为什么还要弄出一个hashCode()，并且进行如此约定，弄得这么麻烦？</p>\n<p><strong>其实，*<em>这主要体现在hashCode()方法的作用上，其主要用于增强哈希表的性能。*</em></strong></p>\n<p>   以集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。（注：Set的底层用的是Map的原理实现）</p>\n<p>  在此需要纠正一个理解上的误区：<strong>对象的hashCode()返回的不是对象所在的物理内存地址。甚至也不一定是对象的逻辑地址，hashCode()相同的两个对象，不一定相等，换言之，不相等的两个对象，hashCode()返回的哈希码可能相同。</strong></p>\n<p>因此，在上述代码中，重写了equals()方法后，需要重写hashCode()方法。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/jianchilu/article/details/83627621?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control\">java的根类Object详细分析</a></p>\n<h1 id=\"TCP滑动窗口控制流量的原理\"><a href=\"#TCP滑动窗口控制流量的原理\" class=\"headerlink\" title=\"TCP滑动窗口控制流量的原理\"></a>TCP滑动窗口控制流量的原理</h1><p>TCP的滑动窗口机制<br>   TCP这个协议是网络中使用的比较广泛，他是一个面向连接的可靠的传输协议。既然是一个可靠的传输协议就需要对数据进行确认。TCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。</p>\n<p>​    TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。</p>\n<p>具体参考：</p>\n<p> <a href=\"https://www.cnblogs.com/luoquan/p/4886345.html\">TCP滑动窗口控制流量的原理</a></p>\n","categories":["面经"]},{"title":"华为面经体验","url":"/2021/04/08/HuaweiMainjing210408/","content":"<h1 id=\"http-协议如何保证可靠性\"><a href=\"#http-协议如何保证可靠性\" class=\"headerlink\" title=\"http 协议如何保证可靠性\"></a>http 协议如何保证可靠性</h1><p><strong>重要的数据，要加密</strong>，比如用户名密码，我们需要加密，这样即使被抓包监听，他们也不知道原始数据是什么（如果简单的md5，是可以暴力破解），所以加密方法越复杂越安全，根据需要，常见的是 md5(不可逆)，aes（可逆），自由组合吧,你还可以加一些特殊字符啊，没有做不到只有想不到， 举例：username = aes(username), pwd = MD5(pwd + username);。。。。。</p>\n<p><strong>非重要数据，要签名</strong>，签名的目的是为了防止篡改，比如<a href=\"http://www.xxx.com/getnews?id=1%EF%BC%8C%E8%8E%B7%E5%8F%96id%E4%B8%BA1%E7%9A%84%E6%96%B0%E9%97%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E7%AD%BE%E5%90%8D%E9%82%A3%E4%B9%88%E9%80%9A%E8%BF%87id=2,%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%962%E7%9A%84%E5%86%85%E5%AE%B9%E7%AD%89%E7%AD%89%E3%80%82%E6%80%8E%E6%A0%B7%E7%AD%BE%E5%90%8D%E5%91%A2%EF%BC%9F%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8sign%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8E%9F%E9%93%BE%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%E5%8A%A0%E4%B8%80%E4%B8%AAsign%E5%8F%82%E6%95%B0%EF%BC%8Csign=md5(id=1)%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E5%8F%97%E5%88%B0%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%AA%8C%E8%AF%81sign%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8Emd5(id=1)%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%AD%89%E4%BA%8E%E8%AF%B4%E6%98%8E%E6%AD%A3%E5%B8%B8%E8%AF%B7%E6%B1%82%E3%80%82%E8%BF%99%E4%BC%9A%E6%9C%89%E4%B8%AA%E5%BC%8A%E7%AB%AF%EF%BC%8C%E5%81%87%E5%A6%82%E8%A7%84%E5%88%99%E8%A2%AB%E5%8F%91%E7%8E%B0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E4%BC%9A%E8%A2%AB%E4%BC%AA%E9%80%A0%EF%BC%8C%E6%89%80%E4%BB%A5%E9%80%82%E5%BD%93%E5%A4%8D%E6%9D%82%E4%B8%80%E4%BA%9B%EF%BC%8C%E8%BF%98%E6%98%AF%E8%83%BD%E5%A4%9F%E6%8F%90%E9%AB%98%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E3%80%82\">http://www.xxx.com/getnews?id=1，获取id为1的新闻，如果不签名那么通过id=2,就可以获取2的内容等等。怎样签名呢？通常使用sign，比如原链接请求的时候加一个sign参数，sign=md5(id=1)，服务器接受到请求，验证sign是否等于md5(id=1)，如果等于说明正常请求。这会有个弊端，假如规则被发现，那么就会被伪造，所以适当复杂一些，还是能够提高安全性的。</a></p>\n<p><strong>登录态怎么做，</strong>http是无状态的，也就是服务器没法自己判断两个请求是否有联系，那么登录之后，以后的接口怎么判定是否登录呢，简单的做法，在数据库中存一个token字段（名字随意），当用户调用登陆接口成功的时候，就将该字段设一个值，（比如aes(过期时间)），同时返回给前端，以后每次前端请求带上该值，服务器首先校验是否过期，其次校验是否正确，不通过就让其登陆。（redis 做这个很方便哦，key有过期时间）。</p>\n<p>具体可参考：</p>\n<p><a href=\"https://blog.csdn.net/l18848956739/article/details/81011194\">如何保证http传输安全性</a> </p>\n<p><a href=\"%5Bhttps://hellogoogle.blog.csdn.net/article/details/94440881?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1329187.12416.16178842483851657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control%5D(https://hellogoogle.blog.csdn.net/article/details/94440881?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1329187.12416.16178842483851657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control)\">【Java】【通信安全】怎么保证http请求的安全性</a></p>\n<h1 id=\"IP-TCP-UDP首部详解\"><a href=\"#IP-TCP-UDP首部详解\" class=\"headerlink\" title=\"IP,TCP,UDP首部详解\"></a>IP,TCP,UDP首部详解</h1><h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><p><img src=\"https://img-blog.csdn.net/20160916110056051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p><img src=\"https://img-blog.csdn.net/20160916110125505?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p><img src=\"https://img-blog.csdn.net/20160916110144427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_39584315/article/details/79387811?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242\">IP、TCP、UDP首部详解</a></p>\n<h1 id=\"多线程相关面试题\"><a href=\"#多线程相关面试题\" class=\"headerlink\" title=\"多线程相关面试题\"></a>多线程相关面试题</h1><p>具体可参考：</p>\n<p> <a href=\"https://www.cnblogs.com/weibanggang/p/9470462.html\">多线程面试题</a></p>\n<h1 id=\"多线程的优缺点\"><a href=\"#多线程的优缺点\" class=\"headerlink\" title=\"多线程的优缺点\"></a>多线程的优缺点</h1><p>何时使用多线程技术,何时避免用它,是我们需要掌握的重要课题。多线程技术是一把双刃剑,在使用时需要充分考虑它的优缺点。<br>多线程处理可以同时运行多个线程。由于多线程应用程序将程序划分成多个独立的任务,因此可以在以下方面显著提高性能:<br>(1)多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态;</p>\n<p>(2)当前没有进行处理的任务时可以将处理器时间让给其它任务;</p>\n<p>(3)占用大量处理时间的任务可以定期将处理器时间让给其它任务;</p>\n<p>(4)可以随时停止任务;</p>\n<p>(5)可以分别设置各个任务的优先级以优化性能。</p>\n<p> 是否需要创建多个线程取决于各种因素。在以下情况下,最适合采用多线程处理:<br>(1)耗时或大量占用处理器的任务阻塞用户界面操作;</p>\n<p>(2)各个任务必须等待外部资源 (如远程文件或 Internet连接)。</p>\n<p>同样的 ,多线程也存在许多缺点 ,在考虑多线程时需要进行充分的考虑。多线程的主要缺点包括:<br>(1)等候使用共享资源时造成程序的运行速度变慢。这些共享资源主要是独占性的资源 ,如打印机等。</p>\n<p>(2)对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担超过一定程度时,多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。</p>\n<p>(3)线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。</p>\n<p>(4)对公有变量的同时读或写。当多个线程需要对公有变量进行写操作时,后一个线程往往会修改掉前一个线程存放的数据,从而使前一个线程的参数被修改;另外 ,当公用变量的读写操作是非原子性时,在不同的机器上,中断时间的不确定性,会导致数据在一个线程内的操作产生错误,从而产生莫名其妙的错误,而这种错误是程序员无法预知的。</p>\n<h1 id=\"IPv4和-IPv6的地址长度分别是多少位？\"><a href=\"#IPv4和-IPv6的地址长度分别是多少位？\" class=\"headerlink\" title=\"IPv4和 IPv6的地址长度分别是多少位？\"></a>IPv4和 IPv6的地址长度分别是多少位？</h1><p>ipv4的地址是32位，用点分十进制表示，每八位划分，也就是四个0~255的十进制数，这是很常见的。</p>\n<p>ipv6的地址是128位，一般用点分十六进制表示，每八位划分，也就是十六个0x00~0xff的十六进制数。</p>\n<p>IPv6的地址空间更大。IPv4中规定IP地址长度为32,即有2^32-1个地址；而IPv6中IP地址的长度为128,即有2^128-1个地址。夸张点说就是，如果IPV6被广泛应用以后，全世界的每一粒沙子都会有相对应的一个IP地址。</p>\n<h1 id=\"ArrayList和LinkedList的区别，以及应用场景\"><a href=\"#ArrayList和LinkedList的区别，以及应用场景\" class=\"headerlink\" title=\"ArrayList和LinkedList的区别，以及应用场景\"></a>ArrayList和LinkedList的区别，以及应用场景</h1><ol>\n<li>ArrayList是基于数组实现的，其构造函数为：</li>\n</ol>\n<p>private transient Object[] elementData;</p>\n<p>private int size;</p>\n<p>ArryList初始化时，elementData数组大小默认为10；</p>\n<p>每次add（）时，先调用ensureCapacity（）保证数组不会溢出，如果此时已满，会扩展为数组length的1.5倍+1，然后用array.copy的方法，将原数组拷贝到新的数组中；</p>\n<p>ArrayList线程不安全，Vector方法是同步的，线程安全；</p>\n<ol start=\"2\">\n<li>LinkedList是基于双链表实现的：</li>\n</ol>\n<p>Object element;</p>\n<p>Entry next,previous;</p>\n<p>初始化时，有个header Entry，值为null；</p>\n<p>使用header的优点是：在任何一个条目（包括第一个和最后一个）都有一个前置条目和一个后置条目，因此在LinkedList对象的开始或者末尾进行插入操作没有特殊的地方；</p>\n<p><strong>使用场景：</strong></p>\n<p>如果应用程序对各个索引位置的元素进行大量的存取或删除操作，ArrayList对象要远优于LinkedList对象；<br>如果应用程序主要是对列表进行循环，并且循环时候进行插入或者删除操作，LinkedList对象要远优于ArrayList对象；</p>\n<p>ArrayList 与 LinkedList 有什么区别 ?</p>\n<p>存储结构上 ArrayList 底层使用数组进行元素的存储，LinkedList 使用双向链表作为存储结构。<br>两者均与允许存储 null 也允许存储重复元素。<br>在性能上 ArrayList 在存储大量元素时候的增删效率 平均低于 LinkedList，因为 ArrayList 在增删的是需要拷贝元素到新的数组，而 LinkedList 只需要将节点前后指针指向改变。<br>在根据角标获取元素的时间效率上ArrayList优于 LinkedList，因为数组本身有存储连续，有 index 角标，而 LinkedList 存储元素离散，需要遍历链表。<br>不要使用 for 循环去遍历 LinkedList 因为效率很低。<br>两者都是线程不安全的，都可以使用 Collections.synchronizedList(List<E> list) 方法生成一个线程安全的 List。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/github_37130188/article/details/96508345\">ArrayList和LinkedList的区别，以及应用场景</a></p>\n<h1 id=\"如何实现线程同步\"><a href=\"#如何实现线程同步\" class=\"headerlink\" title=\"如何实现线程同步\"></a>如何实现线程同步</h1><h2 id=\"Synchronized-用在普通方法和-static-上的区别\"><a href=\"#Synchronized-用在普通方法和-static-上的区别\" class=\"headerlink\" title=\"Synchronized 用在普通方法和 static 上的区别\"></a>Synchronized 用在普通方法和 static 上的区别</h2><p>当使用synchronized修饰静态方法时，线程此时获得的锁对象是类的Class对象（<strong>堆内存中只有唯一一个Class对象，因为Class对象是在类加载时产生的，而类加载只执行一次</strong>），因此会锁住整个类，其他线程无法访问该类的同步静态方法，但是可以访问非同步的方法</p>\n<p>回答2：</p>\n<p>synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；</p>\n<p>synchronized修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p>\n<p>具体可参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_33819764/article/details/81736729\">【多线程】实现线程同步的几种方法</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_43658899/article/details/107230699\">Synchronized关键字加在普通方法上和加在静态方法上有什么区别?</a></p>\n<p><a href=\"https://www.cnblogs.com/suger43894/p/12171341.html\">synchronized底层原理</a></p>\n<h1 id=\"如何实现线程安全\"><a href=\"#如何实现线程安全\" class=\"headerlink\" title=\"如何实现线程安全\"></a>如何实现线程安全</h1><p>线程安全在三个方面体现</p>\n<p>1.原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</p>\n<p>2.可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</p>\n<p>3.有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>\n<ul>\n<li><strong>原子性</strong>：JDK里面提供了很多atomic类，AtomicInteger,AtomicLong,AtomicBoolean等等。</li>\n</ul>\n<p>它们是通过CAS完成原子性。</p>\n<ul>\n<li><strong>原子性：</strong>synchronized是一种同步锁，通过锁实现原子操作。</li>\n</ul>\n<p>JDK提供锁分两种：一种是synchronized，依赖JVM实现锁，因此在这个关键字作用对象的作用范围内是同一时刻只能有一个线程进行操作；另一种是LOCK，是JDK提供的代码层面的锁，依赖CPU指令，代表性的是ReentrantLock。</p>\n<p>synchronized修饰的对象有四种：</p>\n<p>（1）修饰代码块，作用于调用的对象；</p>\n<p>（2）修饰方法，作用于调用的对象；</p>\n<p>（3）修饰静态方法，作用于所有对象；</p>\n<p>（4）修饰类，作用于所有对象。</p>\n<ul>\n<li><p>可见性—volatile</p>\n<p>对于可见性，JVM提供了synchronized和volatile。这里我们看volatile。</p>\n<p>（1）volatile的可见性是通过内存屏障和禁止重排序实现的</p>\n<p>volatile会在写操作时，会在写操作后加一条store屏障指令，将本地内存中的共享变量值刷新到主内存：<br>volatile在进行读操作时，会在读操作前加一条load指令，从内存中读取共享变量：</p>\n<p>2）但是volatile不是原子性的，进行++操作不是安全的。执行后发现线程不安全，原因是 执行conut++ 时分成了三步，第一步是取出当前内存 count 值，这时 count 值时最新的，接下来执行了两步操作，分别是 +1 和重新写回主存。假设有两个线程同时在执行 count++ ，两个内存都执行了第一步，比如当前 count 值为 5 ，它们都读到了，然后两个线程分别执行了 +1 ，并写回主存，这样就丢掉了一次加一的操作。</p>\n<p>（3）volatile适用的场景</p>\n<p>既然volatile不适用于计数，那么volatile适用于哪些场景呢：</p>\n<p>\\1. 对变量的写操作不依赖于当前值</p>\n<p>\\2. 该变量没有包含在具有其他变量不变的式子中</p>\n</li>\n<li><p>有序性</p>\n</li>\n</ul>\n<p>有序性是指，在JMM中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>可以通过volatile、synchronized、lock保证有序性。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_40459875/article/details/80290875\">Java中如何保证线程安全性</a></p>\n<h1 id=\"Java中如何保证线程安全性\"><a href=\"#Java中如何保证线程安全性\" class=\"headerlink\" title=\"Java中如何保证线程安全性\"></a>Java中如何保证线程安全性</h1><p> <a href=\"https://blog.csdn.net/weixin_40459875/article/details/80290875\">ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</a></p>\n<p>ReentrantLock的介绍<br>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。在java关键字synchronized隐式支持重入性（关于synchronized可以看这篇文章），synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：1. 重入性的实现原理；2. 公平锁和非公平锁。<br>具体参考：<br><a href=\"https://blog.csdn.net/ThinkWon/article/details/102469388\">ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</a></p>\n<h1 id=\"MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖\"><a href=\"#MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖\" class=\"headerlink\" title=\"MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖\"></a>MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖</h1><h2 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h2><p>前面提到mysql中是通过B+树来组织一张表数据的，而B+树每个节点上都有一个关键字，在进行搜索的时候要从根节点开始查找，直到在叶子节点上查询到对应的关键字和这行数据。那么MySQL中是使用什么作为B+树节点上的关键字呢？答案是主键索引，MySQL是通过主键索引作为B+树节点上的关键字来组织数据的。那么MySQL又是怎样确定使用哪个字段作为主键索引呢？规则如下：</p>\n<p>如果建表时指定了主键，则使用主键作为B+树节点的关键字。<br>如果表中没有主键，但是有唯一索引，则会选取一个唯一索引作为关键字。<br>如果既没有主键也没有唯一索引，MySQL会自动生成一个6字节的整型唯一标识作为关键字。<br>也就是说，MySQL每张表中都必须有一个主键索引，使用这个主键索引作为关键字将整张表组织成一棵B+树。</p>\n<h2 id=\"聚簇索引和非聚簇索引\"><a href=\"#聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"聚簇索引和非聚簇索引\"></a>聚簇索引和非聚簇索引</h2><p>在MySQL中不管是InnoDB还是MyISAM都是使用B+树来组织表中的数据的。但是在具体实现方法上略有不同。InnoDB的主键索引是聚簇索引，在InnoDB的实现中，把主键作为关键字组织到B+树的各个节点上，而叶子节点上存储的是主键列的值和对应的整行数据。注意这里说的是将表中实际的一整行数据直接存到叶子节点上MyISAM是非聚簇索引，在MyISAM的实现中，叶子节点中存储的是一行数据在磁盘上的地址（可以理解为行号）。所以聚簇索引和非聚簇索引本质的区别就是B+树的叶子节点上存储的是行数据还是行数据的地址（行号）。</p>\n<h1 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h1><h2 id=\"索引的类型：\"><a href=\"#索引的类型：\" class=\"headerlink\" title=\"索引的类型：\"></a>索引的类型：</h2><p><strong>普通索引：</strong><br>最基本的索引，没有任何限制，是我们大多数情况下使用到的索引<br>如何创建：<br>1.直接创建：<br>CREATE INDEX index_name ON table(column(length))<br>2.修改原有表结构：<br>ALTER TABLE table_name ADD INDEX index_name ON(column(length))<br>若是char、varchar类型length可不填，默认字段的实际长度，若是blob、text类型则必须指定长度<br><strong>唯一索引：</strong><br>与普通索引类似，不同之处在于索引列的值必须唯一，但允许有空值(和主键不同之处)，若是联合索引，则列值得组合必须唯一<br>如何创建：<br>1.直接创建：<br>CREATE UNIQUE INDEX index_name ON table(column(length))<br>2.修改原有表结构：<br>ALTER TABLE table ADD UNIQUE index_name ON(column(length))<br><strong>主键索引：</strong><br>不允许有空值，主键索引建立的规则是int优于varchar，一般在剪标的时候创建，最好是与表的其他字段不想关的列或者是业务不相关的列，一般为int且是AUTO_INCREMENT自增长类型的<br><strong>联合索引：</strong><br>通俗地讲就是，索引包含多个字段但只有一个名称，这个才是本篇文章要讲的重点<br>如何创建：<br>CREATE INDEX index_name ON table_name(column1(length1),column2(length2……))<br>一个联合索引根据”最左前缀”会包含多个索引：<br>比如：建立了联合索引(A,B,C)，实际上它包含了3个索引，分别是(A)、(A,B)、(A,B,C)，即包含了联合索引的左子集，这也是为什么我们建了联合索引(A,B,C)，就没必要再单独建一个普通索引(A)的原因<br>建立联合索引的时候，通常需要将其他相关的查询都拿来参考，以便做综合评估，进一步提高索引的使用效率与查询效率<br><strong>联合索引的特点：</strong><br>实例的背景——在T_news表中建立以ischecked、channel_id、audit_time3个字段为联合索引<br>a.最左前缀：索引where时的条件要按照建立索引的时候字段的排列顺序<br>实例如下：<br>where条件单独使用ischecked字段，符合最左前缀，联合索引起作用</p>\n<h1 id=\"创建索引的几个原则\"><a href=\"#创建索引的几个原则\" class=\"headerlink\" title=\"创建索引的几个原则\"></a>创建索引的几个原则</h1><p><strong>a.最左前缀匹配原则</strong>，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like ‘%…’)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，若建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整<br><strong>b.=和in可以乱序，</strong>比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会优化成索引可识别的形式<br><strong>c.尽量选择区分度高(cardinality越大越好)的列作为索引</strong>,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，一般需要join的字段都要求是0.1以上，当然，使用场景不同，该值也难以确定<br><strong>d.索引列不能是表达式的一部分或mysql函数的参数</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，因为b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，成本太大，故不能走索引，所以语句应写成create_time = unix_timestamp(’2014-05-29’)<br><strong>e.尽量的扩展索引，</strong>不要新建索引，比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/linbiaorui/article/details/72793527\">mysql索引优化</a> </p>\n<h1 id=\"Java语言的特点和特性\"><a href=\"#Java语言的特点和特性\" class=\"headerlink\" title=\"Java语言的特点和特性\"></a>Java语言的特点和特性</h1><h2 id=\"1-Java语言的主要特点：\"><a href=\"#1-Java语言的主要特点：\" class=\"headerlink\" title=\"1.　　Java语言的主要特点：\"></a>1.　　<strong>Java</strong>语言的主要特点：</h2><p>　　　1. 跨平台性</p>\n<p>　　　所谓的跨平台性，是指软件可以不受计算机硬件和操作系统的约束而在任意计算机环境下正常运行。这是软件发展的趋势和编程人员追求的目标。之所以这样说，是因为计算机硬件的种类繁多，操作系统也各不相同，不同的用户和公司有自己不同的计算机环境偏好，而软件为了能在这些不同的环境里正常运行，就需要独立于这些平台。而在<strong>Java</strong>语言中， <strong>Java</strong>自带的虚拟机很好地实现了跨平台性。 <strong>Java</strong>源程序代码经过编译后生成二进制的字节码是与平台无关的，但是可被<strong>Java</strong>虚拟机识别的一种机器码指令。 <strong>Java</strong>虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得<strong>Java</strong>语言具备跨平台性。</p>\n<p>　　　2. 面向对象</p>\n<p>　　　面向对象是指以对象为基本粒度，其下包含属性和方法。对象的说明用属性表达，而通过使用方法来操作这个对象。面向对象技术使得应用程序的开发变得简单易用，节省代码。<strong>Java</strong>是一种面向对象<strong>的语言</strong>，也继承了面向对象的诸多好处，如代码扩展、代码复用等。</p>\n<p>　　　3. 安全性</p>\n<p>　　　安全性可以分为四个层面，即语言级安全性、编译时安全性、运行时安全性、可执行代码安全性。语言级安全性指<strong>Java</strong>的数据结构是完整的对象，这些封装过的数据类型具有安全性。编译时要进行<strong>Java</strong>语言和语义的检查，保证每个变量对应一个相应的值，编译后生成<strong>Java</strong>类。运行时<strong>Java</strong>类需要类加载器载入www jxzxmr net，并经由字节码校验器校验之后才可以运行。 <strong>Java</strong>类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。</p>\n<p>　　　4. 多线程</p>\n<p>　　　多线程在操作系统中已得到了最成功的应用。多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于支持事务并发和多任务处理。 <strong>Java</strong>除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。</p>\n<p>　　　5. 简单易用</p>\n<p>　　　<strong>Java</strong>源代码的书写不拘泥于特定的环境，可以用记事本、文本编辑器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。</p>\n<h2 id=\"2-Java语言的几大特性：\"><a href=\"#2-Java语言的几大特性：\" class=\"headerlink\" title=\"2.　　Java语言的几大特性：\"></a>2.　　<strong>Java</strong>语言的几大<strong>特性</strong>：</h2><p>　　　1.封装： </p>\n<p>　　　封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在<strong>java</strong>中通过关键字private，protected和public实现封装。什么是封装？封装把对象的所有组成部分组合在一起，封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。</p>\n<p>　　　2.继承：</p>\n<p>　　　继承是面向对象最显著的一个<strong>特性</strong>。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 <strong>Java</strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。这种技术使得复用以前的代码非常容易，能够大大缩短开发周期，降低开发费用</p>\n<p>　　　3.多态： </p>\n<p>　　　按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的<strong>特性</strong>以不同的方式运作 多态的话，我觉得是更好的利用了继承这一<strong>特性</strong>，然后为什么能实现多态，因为可以重写父类的方法。说重写可能不清楚，具体来说就是子类父类可以存在分别存在名字相同的属性或者方法，然后可视声明的类去调用相应的方法等。</p>\n<p>　　　4.抽象：<br>　　　抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法，我觉得理解成一种方法比较好。就是我们通过对事物的认知，将某一或者一类事物的属性变化成<strong>JAVA</strong>语言能识别的类。</p>\n<h1 id=\"static关键字总结\"><a href=\"#static关键字总结\" class=\"headerlink\" title=\"static关键字总结\"></a>static关键字总结</h1><h2 id=\"静态变量和静态方法\"><a href=\"#静态变量和静态方法\" class=\"headerlink\" title=\"静态变量和静态方法\"></a><strong>静态变量和静态方法</strong></h2><p>static关键字最基本的用法是：</p>\n<p>1、被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来</p>\n<p>2、被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来\\</p>\n<h2 id=\"静态块\"><a href=\"#静态块\" class=\"headerlink\" title=\"静态块\"></a><strong>静态块</strong></h2><p>静态块也是static的重要应用之一。也是用于初始化一个类的时候做操作用的，和静态变量、静态方法一样，<strong>静态块里面的代码只执行一次，且只在初始化类的时候执行</strong>。静态块很简单，不过提三个小细节：</p>\n<ol>\n<li><p><strong>静态资源的加载顺序是严格按照静态资源的定义顺序来加载的</strong>。</p>\n</li>\n<li><p><strong>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问</strong>。</p>\n</li>\n<li><p><strong>静态代码块是严格按照父类静态代码块-&gt;子类静态代码块的顺序加载的，且只加载一次</strong>。</p>\n<p>最后一个小例子：</p>\n</li>\n</ol>\n<p>具体可参考：</p>\n<p> <a href=\"https://www.cnblogs.com/swisszhang/p/9892992.html\">static关键字作用总结</a></p>\n<h1 id=\"final的用法\"><a href=\"#final的用法\" class=\"headerlink\" title=\"final的用法\"></a>final的用法</h1><h3 id=\"1-修饰数据\"><a href=\"#1-修饰数据\" class=\"headerlink\" title=\"1.修饰数据\"></a>1.修饰数据</h3><h3 id=\"2-修饰方法参数\"><a href=\"#2-修饰方法参数\" class=\"headerlink\" title=\"2.修饰方法参数\"></a>2.修饰方法参数</h3><h3 id=\"3-修饰方法\"><a href=\"#3-修饰方法\" class=\"headerlink\" title=\"3.修饰方法\"></a>3.修饰方法</h3><h3 id=\"4-修饰类\"><a href=\"#4-修饰类\" class=\"headerlink\" title=\"4.修饰类\"></a>4.修饰类</h3><p>总结<br>final关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：</p>\n<ol>\n<li><p>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；</p>\n</li>\n<li><p>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；</p>\n</li>\n<li><p>修饰方法，表示该方法无法被重写；</p>\n</li>\n<li><p>修饰类，表示该类无法被继承。</p>\n</li>\n</ol>\n<p>上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。</p>\n<h1 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h1><h2 id=\"volatile的第一个特性–保证可见性\"><a href=\"#volatile的第一个特性–保证可见性\" class=\"headerlink\" title=\"volatile的第一个特性–保证可见性\"></a>volatile的第一个特性–保证可见性</h2><p>解决内存可见性问题方式的一种是加锁，但是使用锁太笨重，因为它会带来线程上下文的切换开销。Java提供了一种弱形式的同步，也就是volatile关键字。该关键字确保对一个变量的更新对其他线程马上可见。</p>\n<p><strong>当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。</strong></p>\n<p><strong>当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。</strong></p>\n<p>理解volatile保证可见性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。</p>\n<h2 id=\"volatile的第二个特性–保证有序性\"><a href=\"#volatile的第二个特性–保证有序性\" class=\"headerlink\" title=\"volatile的第二个特性–保证有序性\"></a>volatile的第二个特性–保证有序性</h2><p>Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。</p>\n<blockquote>\n<p>什么是数据依赖性？<br>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>\n</blockquote>\n<p>在单线程下重排序可以保证最终执行结果与程序顺序执行的结果一致，但是在多线程下就会出现问题。</p>\n<h2 id=\"volatile保证有序性和可见性的原理–内存屏障\"><a href=\"#volatile保证有序性和可见性的原理–内存屏障\" class=\"headerlink\" title=\"volatile保证有序性和可见性的原理–内存屏障\"></a>volatile保证有序性和可见性的原理–内存屏障</h2><p>前面介绍了volatile关键字的两大特性，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序。</p>\n<h2 id=\"什么是内存屏障\"><a href=\"#什么是内存屏障\" class=\"headerlink\" title=\"什么是内存屏障\"></a>什么是内存屏障</h2><p>维基百科中对内存屏障的描述如下：</p>\n<blockquote>\n<p>内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，它使得 CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行, 也就是说在memory barrier 之前的指令和memory barrier之后的指令不会由于系统优化等原因而导致乱序。<br>大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。<br>语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。</p>\n</blockquote>\n<p>在JVM中提供了四类内存屏障指令：</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-06ae616adae545c36a01f7eaa192ac52_720w.jpg\" alt=\"img\"></p>\n<h2 id=\"内存屏障的插入\"><a href=\"#内存屏障的插入\" class=\"headerlink\" title=\"内存屏障的插入\"></a>内存屏障的插入</h2><p>了解什么是内存屏障之后，我们再来看看JMM是如何插入内存屏障的。</p>\n<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p>\n<ul>\n<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>\n<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>\n<li>在每个volatile读操作的前面插入一个LoadLoad屏障。</li>\n<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>\n</ul>\n<p>在此策略下，volatile写操作插入内存屏障后生成的指令序列如下图所示。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-e6737695804284045f66f0e1163425b0_720w.jpg\" alt=\"img\"></p>\n<p>由于StoreStore屏障保障上面所有的普通写在volatile写之前刷新到主内存，StoreStore屏障可以保证在volaitle写之前，其前面的所有普通写操作已经对任意处理器可见了。</p>\n<p>volatile读操作插入内存屏障后生成的指令序列如下图所示。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-c1a18b0fea3fcd2efe52ca35f658d1d1_720w.jpg\" alt=\"img\"></p>\n<p>需要注意的是，在实际执行时，为了保证效率，编译器可以根据具体的情况省略不必要的屏障。</p>\n<p>关于volatile的特性和实现原理就介绍到这里。</p>\n<p>具体参考：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/151289085\">volatile关键字的作用以及原理</a></p>\n<h1 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h1><p><strong>存储引擎</strong>说白了就是如何存储数据、如何为存储的数据建立<strong>索引</strong>和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以<strong>存储引擎</strong>也可以称为表类型（即存储和操作此表的类型）。</p>\n<p>在Oracle 和SQL Server等数据库中只有一种<strong>存储引擎</strong>，所有数据存储管理机制都是一样的。而MySql数据库提供了多种<strong>存储引擎</strong>。用户可以根据不同的需求为数据表选择不同的<strong>存储引擎</strong>，用户也可以根据自己的需要编写自己的<strong>存储引擎</strong>。</p>\n<p>\\2.   <strong>存储引擎</strong>的类型及特点</p>\n<table>\n<thead>\n<tr>\n<th><strong>引擎名称</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺陷</strong></th>\n<th><strong>应用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>MyISAM</strong></td>\n<td>独立于操作系统，这说明可以轻松地将其从Windows服务器移植到Linux服务器</td>\n<td>不支持事务/行级锁/外键约束</td>\n<td>适合管理邮件或Web服务器日志数据</td>\n</tr>\n<tr>\n<td><strong>InnoDB</strong></td>\n<td>健壮的事务型<strong>存储引擎</strong>；支持事务/行级锁/外键约束自动灾难恢复/AUTO_INCREMENT</td>\n<td></td>\n<td>需要事务支持，并且有较高的并发读取频率</td>\n</tr>\n<tr>\n<td><strong>MEMORY</strong></td>\n<td>为得到最快的响应时间，采用的逻辑存储介质是系统内存</td>\n<td>当mysqld守护进程崩溃时，所有的Memory数据都会丢失；不能使用BLOB和TEXT这样的长度可变的数据类型</td>\n<td>临时表</td>\n</tr>\n<tr>\n<td><strong>MERGE</strong></td>\n<td>是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表</td>\n<td></td>\n<td>常应用于日志和数据仓库</td>\n</tr>\n<tr>\n<td><strong>ARCHIVE</strong></td>\n<td>归档的意思，支持<strong>索引</strong>，拥有很好的压缩机制</td>\n<td>仅支持插入和查询功能</td>\n<td>经常被用来当做仓库使用</td>\n</tr>\n</tbody></table>\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><h2 id=\"什么是索引\"><a href=\"#什么是索引\" class=\"headerlink\" title=\"什么是索引\"></a>什么是索引</h2><p>索引是对<a href=\"https://coding.imooc.com/?c=data\">数据库</a>表中一个或多个列（例如，employee 表的姓名 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</p>\n<p>例如这样一个查询：select * from table1 where id=10000。如果没有索引，必须遍历整个表，直到ID等于10000的这一行被找到为止；有了索引之后(必须是在ID这一列上建立的索引)，即可在索引中查找。由于索引是经过某种算法优化过的，因而查找次数要少的多。可见，索引是用来定位的。</p>\n<h2 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a><strong>分类：</strong></h2><p><strong>唯一索引</strong></p>\n<p>唯一索引是不允许其中任何两行具有相同索引值的索引。<br>当现有数据中存在重复的键值时，大多数<a href=\"https://coding.imooc.com/?c=data\">数据库</a>不允许将新创建的唯一索引与表一起保存。<a href=\"https://coding.imooc.com/?c=data\">数据库</a>还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p>\n<p><strong>主键索引</strong></p>\n<p><a href=\"https://coding.imooc.com/?c=data\">数据库</a>表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。<br>在<a href=\"https://coding.imooc.com/?c=data\">数据库</a>关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>\n<p><strong>聚集索引</strong></p>\n<p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。<br>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>\n<p>具体参考：</p>\n<p><a href=\"https://www.imooc.com/article/11725\"><strong>【程序员必读系列】-数据库索引的原理</strong></a></p>\n<h1 id=\"分布式、微服务和集群的初步了解\"><a href=\"#分布式、微服务和集群的初步了解\" class=\"headerlink\" title=\"分布式、微服务和集群的初步了解\"></a>分布式、微服务和集群的初步了解</h1><p><strong>微服务</strong></p>\n<p>简单来说微服务就是很小的服务，<strong>小到一个服务只对应一个单一的功能，只做一件事</strong>。这个服务可以单独部署运行，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</p>\n<p><strong>微服务架构</strong></p>\n<p>在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。</p>\n<p><strong>分布式</strong></p>\n<p>分布式服务顾名思义服务是<strong>分散部署在不同的机器上</strong>，一个服务可能负责几个功能，是一种面向SOA架构的，服务之间也是通过rpc来交互或者是webservice来交互的。</p>\n<p>逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署，生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。<br>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难.</p>\n<p>具体参考：</p>\n<p><a href=\"https://www.cnblogs.com/yaoyao-sun/p/10422019.html\">分布式、微服务和集群的初步了解</a></p>\n<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>\n<h2 id=\"获取Class对象的三种方式\"><a href=\"#获取Class对象的三种方式\" class=\"headerlink\" title=\"获取Class对象的三种方式\"></a>获取Class对象的三种方式</h2><h3 id=\"1-1-Object-——-gt-getClass\"><a href=\"#1-1-Object-——-gt-getClass\" class=\"headerlink\" title=\"1.1 Object ——&gt; getClass();\"></a>1.1 Object ——&gt; getClass();</h3><h3 id=\"1-2-任何数据类型（包括基本数据类型）都有一个“静态”的class属性\"><a href=\"#1-2-任何数据类型（包括基本数据类型）都有一个“静态”的class属性\" class=\"headerlink\" title=\"1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性\"></a>1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</h3><h3 id=\"1-3-通过Class类的静态方法：forName（String-className）-常用\"><a href=\"#1-3-通过Class类的静态方法：forName（String-className）-常用\" class=\"headerlink\" title=\"1.3 通过Class类的静态方法：forName（String  className）(常用)\"></a>1.3 通过Class类的静态方法：forName（String  className）(常用)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> fanshe;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取Class对象的三种方式</span></span><br><span class=\"line\"><span class=\"comment\"> * 1 Object ——&gt; getClass();</span></span><br><span class=\"line\"><span class=\"comment\"> * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</span></span><br><span class=\"line\"><span class=\"comment\"> * 3 通过Class类的静态方法：forName（String  className）(常用)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fanshe</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//第一种方式获取Class对象  </span></span><br><span class=\"line\">        Student stu1 = <span class=\"keyword\">new</span> Student();<span class=\"comment\">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class=\"line\">        Class stuClass = stu1.getClass();<span class=\"comment\">//获取Class对象</span></span><br><span class=\"line\">        System.out.println(stuClass.getName());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//第二种方式获取Class对象</span></span><br><span class=\"line\">        Class stuClass2 = Student.class;</span><br><span class=\"line\">        System.out.println(stuClass == stuClass2);<span class=\"comment\">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//第三种方式获取Class对象</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class stuClass3 = Class.forName(<span class=\"string\">&quot;fanshe.Student&quot;</span>);<span class=\"comment\">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class=\"line\">            System.out.println(stuClass3 == stuClass2);<span class=\"comment\">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Java类加载器与双亲委派模式的详解\"><a href=\"#Java类加载器与双亲委派模式的详解\" class=\"headerlink\" title=\"Java类加载器与双亲委派模式的详解\"></a>Java类加载器与双亲委派模式的详解</h1><p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_38055381/article/details/81382115\">Java类加载器与双亲委派模式的详解</a></p>\n<h1 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h1><p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p>\n<h1 id=\"B树，B-树的原理及区别\"><a href=\"#B树，B-树的原理及区别\" class=\"headerlink\" title=\"B树，B+树的原理及区别\"></a>B树，B+树的原理及区别</h1><h2 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B-树\"></a>B-树</h2><p><img src=\"/images/pasted-210408Btree.jpg\"></p>\n<h2 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+树\"></a>B+树</h2><pre><code>  1.其定义基本与B-树同，除了：\n</code></pre>\n<p>​      2.非叶子结点的子树指针与关键字个数相同；</p>\n<p>​      3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</p>\n<p>​      4.为所有叶子结点增加一个链指针；</p>\n<p>​      5.所有关键字都在叶子结点出现；</p>\n<p><img src=\"/images/pasted-210408B+tree.jpg\"></p>\n<p> B+的特性：</p>\n<p>​      1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>\n<p>​      2.不可能在非叶子结点命中；</p>\n<p>​      3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>\n<p>​      4.更适合文件索引系统；</p>\n<h2 id=\"为什么B-树比B树更适合数据库索引？\"><a href=\"#为什么B-树比B树更适合数据库索引？\" class=\"headerlink\" title=\"为什么B+树比B树更适合数据库索引？\"></a>为什么B+树比B树更适合数据库索引？</h2><p>1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>\n<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>\n<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>\n<p>4、B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p>\n<p>具体参考：<a href=\"https://blog.csdn.net/wuzzi/article/details/90208999\">为什么说B+树比B树更适合数据库索引？</a></p>\n<h1 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h1><h2 id=\"红黑树规则\"><a href=\"#红黑树规则\" class=\"headerlink\" title=\"红黑树规则\"></a>红黑树规则</h2><p>红黑树有必须要遵守的规则，称为红-黑规则：</p>\n<p>每个节点不是红色就是黑色的；<br>根节点总是黑色的；<br>红色节点的子节点必须是黑色的（反之不一定）。也就是从每个叶子到根的路径上不能有两个连续的红色节点；<br>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</p>\n<h2 id=\"红黑树性能分析\"><a href=\"#红黑树性能分析\" class=\"headerlink\" title=\"红黑树性能分析\"></a>红黑树性能分析</h2><p>红黑树的查找、插入和删除时间复杂度都为O(logN)，额外的开销是每个节点的存储空间都稍微增加了一点，因为一个存储红黑树节点的颜色变量。插入和删除的时间要增加一个常数因子，因为要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是 O(logN)，(时间复杂度的计算要省略常数)，但实际上红黑树的插入和删除比普通的二叉树是要慢的。</p>\n<p>红黑树适用于查找的次数比插入和删除的次数大很多的情况，红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。</p>\n<p>具体参考：<br>原文链接：<a href=\"https://blog.csdn.net/Mr_Wanderer/article/details/113872720\">https://blog.csdn.net/Mr_Wanderer/article/details/113872720</a></p>\n<h1 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h1><p>二叉搜索树作为一种数据结构，其查找、插入和删除操作的时间复杂度都为O(logn)，底数为2。</p>\n<p>但是我们说这个时间复杂度是在平衡的二叉搜索树上体现的，也就是如果插入的数据是随机的，则效率很高，但是如果插入的数据是有序的，比如从小到大的顺序【10,20,30,40,50】插入到二叉搜索树中：从大到小就是全部在左边，这和链表没有任何区别了，这种情况下查找的时间复杂度为O(N)，而不是O(logN)。当然这是在最不平衡的条件下，实际情况下，<strong>二叉搜索树的效率应该在O(N)和O(logN)之间，这取决于树的不平衡程度</strong>。</p>\n<h1 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h1><p>查找、插入和删除在平均和最坏情况下都是O（log n）。</p>\n<p> 高度为 h 的 AVL 树，节点数 N 最多2^h − 1；</p>\n<h1 id=\"浅拷贝和深拷贝\"><a href=\"#浅拷贝和深拷贝\" class=\"headerlink\" title=\"浅拷贝和深拷贝\"></a>浅拷贝和深拷贝</h1><h2 id=\"浅拷贝（Shallow-Copy）：\"><a href=\"#浅拷贝（Shallow-Copy）：\" class=\"headerlink\" title=\"浅拷贝（Shallow Copy）：\"></a><strong>浅拷贝</strong>（Shallow Copy）：</h2><p>①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1218256/201710/1218256-20171011182513121-1029542999.png\" alt=\"img\"></p>\n<p>浅拷贝的实现方式主要有三种：</p>\n<p>一、通过拷贝构造方法实现浅拷贝：</p>\n<p>拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。</p>\n<p>二、通过重写clone()方法进行浅拷贝：</p>\n<p>Object类是类结构的根类，其中有一个方法为protected Object <strong>clone</strong>() throws <a href=\"http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/CloneNotSupportedException.html\">CloneNotSupportedException</a>，这个方法就是进行的浅拷贝。有了这个浅拷贝模板，我们可以通过调用clone()方法来实现对象的浅拷贝。但是需要注意：1、Object类虽然有这个方法，但是这个方法是受保护的（被protected修饰），所以我们无法直接使用。2、使用clone方法的类必须实现Cloneable接口，否则会抛出异常CloneNotSupportedException。对于这两点，我们的解决方法是，在要使用clone方法的类中重写clone()方法，通过super.clone()调用Object类中的原clone方法。</p>\n<p>基本数据类型是值传递，所以修改值后不会影响另一个对象的该属性值；</p>\n<p>引用数据类型是地址传递（引用传递），所以修改值后另一个对象的该属性值会同步被修改。</p>\n<h2 id=\"深拷贝：\"><a href=\"#深拷贝：\" class=\"headerlink\" title=\"深拷贝：\"></a>深拷贝：</h2><p>首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象图进行拷贝！</p>\n<p>简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。</p>\n<p>深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。</p>\n<p><img src=\"https://images2017.cnblogs.com/blog/1218256/201710/1218256-20171011190501371-68869476.png\" alt=\"img\"></p>\n<p>因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。</p>\n<p>深拷贝的实现方法主要有两种：</p>\n<p>一、通过重写clone方法来实现深拷贝</p>\n<p>与通过重写clone方法实现浅拷贝的基本思路一样，只需要为对象图的每一层的每一个对象都实现Cloneable接口并重写clone方法，最后在最顶层的类的重写的clone方法中调用所有的clone方法即可实现深拷贝。简单的说就是：每一层的每个对象都进行浅拷贝=深拷贝。</p>\n<p>分析结果可以验证：进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。</p>\n<p>二、通过对象序列化实现深拷贝</p>\n<p>虽然层次调用clone方法可以实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写clone方法太过繁琐。</p>\n<p>将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。</p>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><p>JVM在进行GC时，并不是对这三个区域统一回收。 大部分时候，回收都是新生代~<br>●新生代<br><strong>●幸存区(form，to)</strong><br>●老年区<br>GC两种类:轻GC (普通的GC)， 重GC (全局GC)<br>GC常见面试题目:<br>●JVM的内存模型和分区~详细到每个区放什么?<br><img src=\"https://img-blog.csdnimg.cn/20200715153153103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p> 图 JVM内存模型和分区</p>\n<p>●堆里面的分区有哪些?<br>Eden, form, to, 老年区,说说他们的特点!<br>●GC的算法有哪些?<br>标记清除法，标记整理,复制算法，引用计数器<br>●轻GC和重GC分别在什么时候发生?</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_42671148/article/details/108274558\">JVM-狂神学习笔记</a></p>\n<h1 id=\"线程池的作用\"><a href=\"#线程池的作用\" class=\"headerlink\" title=\"线程池的作用\"></a>线程池的作用</h1><p>在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程<br>　　<strong>第一</strong>：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>　　<strong>第二</strong>：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>　　<strong>第三</strong>：提高线程的可管理性。<br>常用线程池：ExecutorService 是主要的实现类，其中常用的有 :<br>Executors.newSingleThreadPool()</p>\n<p>  　　newFixedThreadPool()</p>\n<p>  　　newcachedTheadPool()</p>\n<p>  　 newScheduledThreadPool()</p>\n<p>具体参考：</p>\n<p><a href=\"https://www.cnblogs.com/zeze/p/6548649.html\">线程池的作用</a></p>\n<p><a href=\"https://www.cnblogs.com/superfj/p/7544971.html\">由浅入深理解Java线程池及线程池的如何使用</a></p>\n<h1 id=\"局部性\"><a href=\"#局部性\" class=\"headerlink\" title=\"局部性\"></a>局部性</h1><p>局部性通常分为：<strong>时间局部性</strong>和<strong>空间局部性</strong>。</p>\n<p>1）时间局部性<br>时间局部性是指被引用过一次的内存位置很可能在不远的将来再被多次引用。</p>\n<p>2）空间局部性<br>空间局部性是指如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用其附近的一个内存位置。</p>\n<p>3）局部性原理举例</p>\n<ul>\n<li>在硬件层，局部性原理允许计算机设计者通过引入小而快的高速缓存存储器来保存最近被引用的指令和数据项，从而提高对主存的访问速度。</li>\n<li>在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。</li>\n<li>类似的，操作系统用主存来缓存磁盘文件系统中最近被使用的磁盘块。</li>\n<li>在应用程序的设计，如Web浏览器将最近被请求的文档放在本地磁盘上，利用的就是时间局部性。大容量的Web服务器将最近被请求的文档放在前端磁盘高速缓存中，不需要服务器的干预就可满足对这些文档的请求。</li>\n</ul>\n<h1 id=\"Linux-文件与目录管理\"><a href=\"#Linux-文件与目录管理\" class=\"headerlink\" title=\"Linux 文件与目录管理\"></a>Linux 文件与目录管理</h1><h2 id=\"处理目录的常用命令\"><a href=\"#处理目录的常用命令\" class=\"headerlink\" title=\"处理目录的常用命令\"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p>\n<ul>\n<li>ls（英文全拼：list files）: 列出目录及文件名</li>\n<li>cd（英文全拼：change directory）：切换目录</li>\n<li>pwd（英文全拼：print work directory）：显示目前的目录</li>\n<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>\n<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>\n<li>cp（英文全拼：copy file）: 复制文件或目录</li>\n<li>rm（英文全拼：remove）: 删除文件或目录</li>\n<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>\n</ul>\n<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>\n<h2 id=\"Linux-文件内容查看\"><a href=\"#Linux-文件内容查看\" class=\"headerlink\" title=\"Linux 文件内容查看\"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>\n<ul>\n<li>cat 由第一行开始显示文件内容</li>\n<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>\n<li>nl  显示的时候，顺道输出行号！</li>\n<li>more 一页一页的显示文件内容</li>\n<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>\n<li>head 只看头几行</li>\n<li>tail 只看尾巴几行</li>\n</ul>\n<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>\n<h1 id=\"Linux下的编译和执行\"><a href=\"#Linux下的编译和执行\" class=\"headerlink\" title=\"Linux下的编译和执行\"></a>Linux下的编译和执行</h1><p>具体参考：</p>\n<p> <a href=\"https://blog.csdn.net/u013793399/article/details/51365311\">在Linux系统下编译并执行C++程序</a></p>\n<h1 id=\"Spring相关面试题\"><a href=\"#Spring相关面试题\" class=\"headerlink\" title=\"Spring相关面试题\"></a>Spring相关面试题</h1><p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_41701956/article/details/81389067\">近5年来的 Spring 相关面试题整理</a></p>\n<h1 id=\"JVM垃圾回收机制\"><a href=\"#JVM垃圾回收机制\" class=\"headerlink\" title=\"JVM垃圾回收机制\"></a>JVM垃圾回收机制</h1><p>具体参考：</p>\n<p><a href=\"%5Bhttps://jpeony.blog.csdn.net/article/details/80950336?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control%5D(https://jpeony.blog.csdn.net/article/details/80950336?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control)\">【JVM】垃圾回收机制(1)–如何判定对象可以回收</a></p>\n<h1 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h1><p>SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。</p>\n<h2 id=\"SQL注入攻击的总体思路\"><a href=\"#SQL注入攻击的总体思路\" class=\"headerlink\" title=\"SQL注入攻击的总体思路\"></a>SQL注入攻击的总体思路</h2><p>　　1：寻找到SQL注入的位置</p>\n<p>　　2：判断服务器类型和后台数据库类型</p>\n<p>　　3：针对不同的服务器和数据库特点进行SQL注入攻击</p>\n<h1 id=\"各网络层的协议\"><a href=\"#各网络层的协议\" class=\"headerlink\" title=\"各网络层的协议\"></a>各网络层的协议</h1><p>TCP/IP体系结构</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200823014026904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI4MjA2Mw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"img\"></p>\n<p>TCP/IP协议各层功能</p>\n<p>各层所包含的协议</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200823014123331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI4MjA2Mw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>协议栈<br>各层的所有协议被称为协 议栈(protocol stack).因特网的协议栈由5个层次组成：物理层，数据链路层，网络层，运输层，应用层。</p>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><p>(1)应用层(application layer) 应用层是体系结构中的最高层。应用层直接为用户的应用进程提供服务。这里的进程就是指正在运行的程序。在因特网中的应用层协议很多， 如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等等。<br>应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中 的应用程序交换信息分组。我们将这种位于应用层的信息分组称为报文（message）。</p>\n<h2 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h2><p>迈输层提供了在应用程序端点之间传送应用层报文的服务。<br>(2)运输层(transport layer) 运输层的任务就是负责向两个主机中进程之间的通信提 供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多 个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付给上面 应用层中的相应的进程。运输层分组称为报文段。<br>运输层主要使用以下两种协议：<br>① 传输控制协议TCP (Transmission Control Protocol) 面向连接的，数据传输的单位<br>是报文段(segment),能够提供可靠的交付。<br>② 用户数据报协议UDP (User Datagram Protocol) 无连接的，数据传输的单位是用<br>户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付(best-effortdelivery)”<br>TCP与UDP区别<br>协议，即TCP和UDP,利用其中的任何一个都能传输应用层报文。TCP向它的应用程序提供了 面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流童控制(即发送方/接 收方速率匹配)。TCP也将长报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时， 源抑制其传输速率。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务 的服务，不提供可靠性，没有流量控制，也没有拥塞控制。</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><p>(3)因特网的网络层负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主 机。源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址， 就像你向邮政信件提供目的地址一样。在 TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报，或简称为数据报。<br>因特网的网络层包括著名的IP协议，该协议定义了数据报中的各个字段以及端系统和路 由器如何作用于这些字段。仅有一个IP协议，所有具有网络层的因特网组件都必须运行IP协议。</p>\n<h2 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h2><p>(4)数据链路层(data link layer) 常简称为链路层。我们知道，两个主机之间的数据 传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间(主机和路由器之 间或两个路由器之间)传送数据是直接传送的(点对点)。这时就需要使用专门的链路层的 协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧 (framing),在两个相邻结点间的链路上“透明”地传送帧(frame)中的数据。每一帧包括数据 和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</p>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><p>链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将 该帧中的一个一个比特从一个节点移动到下一个节点。该层中的协议仍然是链路相关的，并 且进一步与链路（例如，双绞铜线、单模光纤）的实际传输媒体相关。例如，以太网具有许 多物理层协议：关于双绞铜线的，关于同轴电缆的，关于光纤的，等等。在每种情况下，跨 越这些链路移动一个比特的方式不同。</p>\n<h1 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h1><p>一篇比较好的并查集：<a href=\"https://blog.csdn.net/qq_42011541/article/details/83378709\">https://blog.csdn.net/qq_42011541/article/details/83378709</a></p>\n<p>N个人要坐在桌子上吃饭，但是人们拒绝和陌生人坐在一张桌子上。什么样的不算陌生人呢？主要是朋友的朋友的朋友的…..只要能扯上关系就不算陌生人。能扯上关系就可以坐在一张桌子上。所以至少要准备多少张桌子？</p>\n<p>思路：其实就是对并查集进行合并操作，只要俩人认识，就组队。把队组好以后，看最后有多少个组(集合)就行了。最初每个人都自成一组，所以有多少人就有多少组。但是随着他们组队，每两个组合并成一个组，总的组数就会少1。如果组队的时候发现，他俩已经早就‘扯上关系了’，也就表名他俩早就是一组了，那就不用继续合并了，也就不用再 -1 了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnionFind</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] parent;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] weight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;<span class=\"comment\">//代表并查集中元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> groups;<span class=\"comment\">//代表并查集中有多少个集合（小组）</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UnionFind</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.weight = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.groups = size;<span class=\"comment\">//因为初始的时候每个人自成一组，所以有多少人就有多少组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.parent[i] = i;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.weight[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> element)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (element != parent[element]) &#123;</span><br><span class=\"line\">            parent[element] = parent[parent[element]];</span><br><span class=\"line\">            element = parent[element];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isConnected</span><span class=\"params\">(<span class=\"keyword\">int</span> firstElement, <span class=\"keyword\">int</span> secondElement)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(firstElement) == find(secondElement);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unionElements</span><span class=\"params\">(<span class=\"keyword\">int</span> firstElement, <span class=\"keyword\">int</span> secondElement)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> firstRoot = find(firstElement);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> secondRoot = find(secondElement);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//如果已经属于同一个集合了，就不用再合并了。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (firstRoot == secondRoot) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (weight[firstRoot] &gt; weight[secondRoot]) &#123;</span><br><span class=\"line\">            parent[secondRoot] = firstRoot;</span><br><span class=\"line\">            weight[firstRoot] += weight[secondRoot];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//weight[firstRoot] &lt;= weight[secondRoot]</span></span><br><span class=\"line\">            parent[firstRoot] = secondRoot;</span><br><span class=\"line\">            weight[secondRoot] += weight[firstRoot];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//合并 firstElement 和 secondElement 所在的两个组后，就少了一组。</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.groups--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getGroups</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.groups;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        java.util.Scanner scanner = <span class=\"keyword\">new</span> java.util.Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> times = scanner.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; times; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = scanner.nextInt();</span><br><span class=\"line\">            UnionFind union = <span class=\"keyword\">new</span> UnionFind(size);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> input = scanner.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; input; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//因为测试数据是从1开始，而我们的并查集是从数组的第0位开始</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> first = scanner.nextInt() - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> second = scanner.nextInt() - <span class=\"number\">1</span>;</span><br><span class=\"line\">                union.unionElements(first, second);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(union.getGroups());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;　</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"transient关键字\"><a href=\"#transient关键字\" class=\"headerlink\" title=\"transient关键字\"></a>transient关键字</h1><p>transient关键字的作用是：被transient修饰的变量不参与序列化和反序列化。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。</p>\n<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><p>简要解释：<br>　　序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>　　序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，<br>然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>\n<p>具体参考：</p>\n<p><a href=\"https://www.cnblogs.com/yangchunze/p/6728086.html\">什么是Java序列化，如何实现java序列化</a></p>\n<h1 id=\"线程的优先级\"><a href=\"#线程的优先级\" class=\"headerlink\" title=\"线程的优先级\"></a>线程的优先级</h1><p>Java线程可以有优先级的设定，高优先级的线程比低优先级的线程有更高的几率得到执行（不完全正确，请参考下面的“线程优先级的问题“）。</p>\n<ol>\n<li>记住当线程的优先级没有指定时，所有线程都携带普通优先级。</li>\n<li>优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。</li>\n<li>记住优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态。</li>\n<li>与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。</li>\n<li>由调度程序决定哪一个线程被执行。</li>\n<li>t.setPriority()用来设定线程的优先级。</li>\n<li>记住在线程开始方法被调用之前，线程的优先级应该被设定。</li>\n<li>你可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级。</li>\n</ol>\n<h1 id=\"Java线程和操作系统线程的关系\"><a href=\"#Java线程和操作系统线程的关系\" class=\"headerlink\" title=\"Java线程和操作系统线程的关系\"></a>Java线程和操作系统线程的关系</h1><p>Java中的线程：</p>\n<p><strong>特别注意：这些线程的状态时JVM中的线程状态！不是操作系统中的线程状态。</strong></p>\n<p><img src=\"https://img-blog.csdn.net/20180418174102632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ3JpbmdLb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/CringKong/article/details/79994511\">Java线程和操作系统线程的关系</a></p>\n<h1 id=\"从输入URL到页面展示的详细过程\"><a href=\"#从输入URL到页面展示的详细过程\" class=\"headerlink\" title=\"从输入URL到页面展示的详细过程\"></a>从输入URL到页面展示的详细过程</h1><p>大致过程：</p>\n<ul>\n<li>1、输入网址</li>\n<li>2、DNS解析</li>\n<li>3、建立tcp连接</li>\n<li>4、客户端发送HTPP请求</li>\n<li>5、服务器处理请求</li>\n<li>6、服务器响应请求</li>\n<li>7、浏览器展示HTML</li>\n<li>8、浏览器发送请求获取其他在HTML中的资源。</li>\n</ul>\n<h2 id=\"1、输入地址\"><a href=\"#1、输入地址\" class=\"headerlink\" title=\"1、输入地址\"></a>1、输入地址</h2><p>  当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>\n<h2 id=\"2、浏览器查找域名的-IP-地址\"><a href=\"#2、浏览器查找域名的-IP-地址\" class=\"headerlink\" title=\"2、浏览器查找域名的 IP 地址\"></a>2、浏览器查找域名的 IP 地址</h2><p>　　1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>\n<p>   2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p>\n<p>　  3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</p>\n<p>　　4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。</p>\n<p>　　5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p>\n<p>　　6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>\n<h2 id=\"3、浏览器向-web-服务器发送一个-HTTP-请求\"><a href=\"#3、浏览器向-web-服务器发送一个-HTTP-请求\" class=\"headerlink\" title=\"3、浏览器向 web 服务器发送一个 HTTP 请求\"></a>3、浏览器向 web 服务器发送一个 HTTP 请求</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>\n<p>建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。</p>\n<p>　　客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>\n<p>　　| 请求方法URI协议/版本</p>\n<p>​        | 请求头(Request Header)</p>\n<p>　　| 请求正文：</p>\n<h2 id=\"4、服务器的永久重定向响应\"><a href=\"#4、服务器的永久重定向响应\" class=\"headerlink\" title=\"4、服务器的永久重定向响应\"></a>4、服务器的永久重定向响应</h2><p>​        服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“<a href=\"http://www.google.com/%E2%80%9D\">http://www.google.com/”</a> 而非“<a href=\"http://google.com/%E2%80%9D%E3%80%82\">http://google.com/”。</a></p>\n<p>　　为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<a href=\"http://www.yy.com/%E5%92%8Chttp://yy.com/%EF%BC%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%9A%E8%AE%A4%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E7%BB%93%E6%9E%9C%E9%80%A0%E6%88%90%E6%AF%8F%E4%B8%AA%E6%90%9C%E7%B4%A2%E9%93%BE%E6%8E%A5%E9%83%BD%E5%87%8F%E5%B0%91%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E6%8E%92%E5%90%8D%E3%80%82%E8%80%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9F%A5%E9%81%93301%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%BC%9A%E6%8A%8A%E8%AE%BF%E9%97%AE%E5%B8%A6www%E7%9A%84%E5%92%8C%E4%B8%8D%E5%B8%A6www%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%92%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E6%8E%92%E5%90%8D%E4%B8%8B%E3%80%82%E8%BF%98%E6%9C%89%E5%B0%B1%E6%98%AF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E9%80%A0%E6%88%90%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E6%80%A7%E5%8F%98%E5%B7%AE%EF%BC%8C%E5%BD%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%90%8D%E5%AD%97%E6%97%B6%EF%BC%8C%E5%AE%83%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%9C%A8%E7%BC%93%E5%AD%98%E9%87%8C%E5%87%BA%E7%8E%B0%E5%A5%BD%E5%87%A0%E6%AC%A1%E3%80%82\">http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。</a></p>\n<h2 id=\"5、浏览器跟踪重定向地址\"><a href=\"#5、浏览器跟踪重定向地址\" class=\"headerlink\" title=\"5、浏览器跟踪重定向地址\"></a>5、浏览器跟踪重定向地址</h2><p>  现在浏览器知道了 “<a href=\"http://www.google.com/&quot;%E6%89%8D%E6%98%AF%E8%A6%81%E8%AE%BF%E9%97%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%83%E4%BC%9A%E5%8F%91%E9%80%81%E5%8F%A6%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82%E3%80%82%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89%E5%95%A5%E5%A5%BD%E8%AF%B4%E7%9A%84\">http://www.google.com/&quot;才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的</a></p>\n<h2 id=\"6、服务器处理请求\"><a href=\"#6、服务器处理请求\" class=\"headerlink\" title=\"6、服务器处理请求\"></a>6、服务器处理请求</h2><p>　　经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？</p>\n<p>　　后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p>\n<p>　　一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>\n<h2 id=\"7、服务器返回一个-HTTP-响应\"><a href=\"#7、服务器返回一个-HTTP-响应\" class=\"headerlink\" title=\"7、服务器返回一个 HTTP 响应\"></a>7、服务器返回一个 HTTP 响应</h2><p>　　经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。</p>\n<p>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>\n<p>l 状态行</p>\n<p>l 响应头(Response Header)</p>\n<p>l 响应正文</p>\n<h2 id=\"8、浏览器显示-HTML\"><a href=\"#8、浏览器显示-HTML\" class=\"headerlink\" title=\"8、浏览器显示 HTML\"></a>8、浏览器显示 HTML</h2><p>　　在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：(暂略)</p>\n<h2 id=\"9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）\"><a href=\"#9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）\" class=\"headerlink\" title=\"9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）\"></a>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</h2><p>​        其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：</p>\n<p>图片：<a href=\"http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif\">http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif</a></p>\n<p>CSS式样表：<a href=\"http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css\">http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css</a></p>\n<p>JavaScript 文件：<a href=\"http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js\">http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js</a></p>\n<p>　　这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p>\n<p>不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中</p>\n<h1 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h1><h2 id=\"1-什么是DNS？\"><a href=\"#1-什么是DNS？\" class=\"headerlink\" title=\"1)什么是DNS？\"></a>1)什么是DNS？</h2><p>　　DNS（Domain Name System，域名系统），因特网上作为域名和<a href=\"http://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80\">IP地址</a>相互映射的一个<a href=\"http://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93\">分布式数据库</a>，能够使用户更方便的访问<a href=\"http://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91\">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a href=\"http://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA\">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>\n<p>　　通俗的讲，我们更习惯于记住一个网站的名字，比如<a href=\"http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。\">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</a></p>\n<h2 id=\"2-DNS查询的两种方式：递归查询和迭代查询\"><a href=\"#2-DNS查询的两种方式：递归查询和迭代查询\" class=\"headerlink\" title=\"2)DNS查询的两种方式：递归查询和迭代查询\"></a>2)DNS查询的两种方式：递归查询和迭代查询</h2><p>1、递归解析</p>\n<p>  当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图\\所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p>\n<p>2、迭代解析</p>\n<p>　　当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p>\n<h2 id=\"4-DNS负载均衡\"><a href=\"#4-DNS负载均衡\" class=\"headerlink\" title=\"4)DNS负载均衡\"></a>4)DNS负载均衡</h2><p>　　当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>\n<h1 id=\"重定向原因\"><a href=\"#重定向原因\" class=\"headerlink\" title=\"重定向原因\"></a>重定向原因</h1><p>（1）网站调整（如改变网页目录结构）；</p>\n<p>（2）网页被移到一个新地址；</p>\n<p>（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</p>\n<p>​    这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>\n<h1 id=\"状态码301和302\"><a href=\"#状态码301和302\" class=\"headerlink\" title=\"状态码301和302\"></a>状态码301和302</h1><h2 id=\"1）301和302的区别。\"><a href=\"#1）301和302的区别。\" class=\"headerlink\" title=\"1）301和302的区别。\"></a>1）301和302的区别。</h2><p>　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。</p>\n<p>　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</p>\n<p>　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 所以302好于301。</p>\n<h2 id=\"2）什么时候进行301或者302跳转呢？\"><a href=\"#2）什么时候进行301或者302跳转呢？\" class=\"headerlink\" title=\"2）什么时候进行301或者302跳转呢？\"></a>2）什么时候进行301或者302跳转呢？</h2><p>​    当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。</p>\n<p>清晰明确而言：使用301跳转的大概场景如下：</p>\n<p>1、域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</p>\n<p>2、在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</p>\n<p>3、空间服务器不稳定，换空间的时候。</p>\n<h1 id=\"如何判断一个对象是否应该被回收\"><a href=\"#如何判断一个对象是否应该被回收\" class=\"headerlink\" title=\"如何判断一个对象是否应该被回收\"></a>如何判断一个对象是否应该被回收</h1><p>这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析。由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法。</p>\n<h3 id=\"1、引用计数法\"><a href=\"#1、引用计数法\" class=\"headerlink\" title=\"1、引用计数法\"></a>1、引用计数法</h3><p>引用计数法的逻辑非常简单，但是存在问题，java并不采用这种方式进行对象存活判断。</p>\n<p>引用计数法的逻辑是：在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。</p>\n<p>这种方法来标记对象的状态会存在很多问题：</p>\n<p>jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。 </p>\n<h3 id=\"2、可达性分析算法\"><a href=\"#2、可达性分析算法\" class=\"headerlink\" title=\"2、可达性分析算法\"></a>2、可达性分析算法</h3><p>在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。<br><img src=\"https://img-blog.csdnimg.cn/20190529111953162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTk2NzYx,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/qq_42996761/article/details/90667725\">如何判断一个对象是否应该被回收</a></p>\n<h1 id=\"Java内存泄露和内存溢出的区别和联系\"><a href=\"#Java内存泄露和内存溢出的区别和联系\" class=\"headerlink\" title=\"Java内存泄露和内存溢出的区别和联系\"></a>Java内存泄露和内存溢出的区别和联系</h1><h2 id=\"1、内存泄漏memory-leak\"><a href=\"#1、内存泄漏memory-leak\" class=\"headerlink\" title=\"1、内存泄漏memory leak :\"></a>1、内存泄漏memory leak :</h2><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>\n<h2 id=\"2、内存溢出-out-of-memory\"><a href=\"#2、内存溢出-out-of-memory\" class=\"headerlink\" title=\"2、内存溢出 out of memory :\"></a>2、内存溢出 out of memory :</h2><p>指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p>\n<h2 id=\"3、二者的关系：\"><a href=\"#3、二者的关系：\" class=\"headerlink\" title=\"3、二者的关系：\"></a>3、二者的关系：</h2><ol>\n<li>内存泄漏的堆积最终会导致内存溢出</li>\n<li>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</li>\n<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</li>\n<li>内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。</li>\n</ol>\n<h2 id=\"内存泄露的场景\"><a href=\"#内存泄露的场景\" class=\"headerlink\" title=\"内存泄露的场景\"></a>内存泄露的场景</h2><ol>\n<li>静态集合类引起内存泄漏：静态成员的生命周期是整个程序运行期间。</li>\n<li>调用 remove()方法时不起作用</li>\n<li>各种连接对象( IO 流对象、数据库连接对象、网络连接对象)使用后未关闭：因为每个流 在操作系统层面都对应了打开的文件句柄，流没有关闭，会导致操作系统的文件句柄一 直处于打开状态，而jvm会消耗内存来跟踪操作系统打开的文件句柄。</li>\n<li>监听器的使用：在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li>\n<li>不正确使用单例模式是引起内存泄漏：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</li>\n</ol>\n<h2 id=\"内存泄漏解决措施\"><a href=\"#内存泄漏解决措施\" class=\"headerlink\" title=\"内存泄漏解决措施\"></a>内存泄漏解决措施</h2><ol>\n<li><p>尽量减少使用静态变量，类的静态变量的生命周期和类同步的。</p>\n</li>\n<li><p>声明对象引用之前，明确内存对象的有效作用域，尽量减小对象的作用域，将类的成员 变量改写为方法内的局部变量；</p>\n</li>\n<li><p>减少长生命周期的对象持有短生命周期的引用；</p>\n</li>\n<li><p>使用 StringBuilder 和 StringBuffer 进行字符串连接，Sting 和 StringBuilder 以及 StringBuffer 等都可以代表字符串，其中 String 字符串代表的是不可变的字符串，后两者表示 可变的字符串。如果使用多个 String 对象进行字符串连接运算，在运行时可能产生大量临时字符串，这些字符串会保存在内存中从而导致程序性能下降。</p>\n</li>\n<li><p>对于不需要使用的对象手动设置 null 值，不管 GC 何时会开始清理，我们都应及时的将无用的对象标记为可被清理的对象；</p>\n</li>\n<li><p>各种连接（数据库连接，网络连接，IO 连接）操作，务必显示调用 close 关闭。</p>\n</li>\n</ol>\n<h2 id=\"内存溢出的场景\"><a href=\"#内存溢出的场景\" class=\"headerlink\" title=\"内存溢出的场景\"></a>内存溢出的场景</h2><h3 id=\"JVM-Heap（堆）溢出：\"><a href=\"#JVM-Heap（堆）溢出：\" class=\"headerlink\" title=\"JVM Heap（堆）溢出：\"></a><strong>JVM Heap（堆）溢出</strong>：</h3><p> 发生这种问题的原因是 java 虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已 经用满了。</p>\n<p>解决方法：</p>\n<ol>\n<li>手动设置 JVM Heap（堆）的大小。</li>\n<li>检查程序，看是否有死循环或不必要地重复创建大量对象。</li>\n</ol>\n<h2 id=\"Metaspace溢出\"><a href=\"#Metaspace溢出\" class=\"headerlink\" title=\"Metaspace溢出\"></a><strong>Metaspace溢出</strong></h2><p>Metaspace 程序中使用了大量的 jar 或 class，使 java 虚拟机装载类的空间不够，与 metaspace 大小有关。方法区用于存放 Java 类型的相关信息。在类装载器加载 class 文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的 内存占用又已经达到 -XX:MaxMetaspaceSize 设置的最大值，将会抛出 OutOfMemoryError 异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</p>\n<p>解决方法:</p>\n<ol>\n<li>通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。</li>\n</ol>\n<h2 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a><strong>栈溢出</strong></h2><p>java.lang.StackOverflowError : Thread Stack space：线程的方法嵌套调用层次太多(如递归调用)，以致于把栈区溢出了。</p>\n<p>解决方法：</p>\n<ol>\n<li>修改程序。</li>\n<li>通过 -Xss: 来设置每个线程的 Stack 大小即可。</li>\n</ol>\n<p>具体参考：</p>\n<p><a href=\"https://my.oschina.net/sunmin/blog/3034336\">JAVA内存泄漏和内存溢出的区别和联系</a></p>\n<h1 id=\"散列函数和Hash冲突\"><a href=\"#散列函数和Hash冲突\" class=\"headerlink\" title=\"散列函数和Hash冲突\"></a>散列函数和Hash冲突</h1><h2 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h2><ol>\n<li>直接定值法：例如线性函数</li>\n<li>数字分析法：根据数字特性来决定</li>\n<li>除留余数法：例如除以某个质数</li>\n<li>平方取中法</li>\n<li>基数转换法</li>\n<li>折叠法</li>\n</ol>\n<h2 id=\"Hash冲突\"><a href=\"#Hash冲突\" class=\"headerlink\" title=\"Hash冲突\"></a>Hash冲突</h2><ol>\n<li><p>开放定址法：</p>\n<ul>\n<li><p>线性探测再散列 di = 1 , 2 , 3 , … , m-1</p>\n</li>\n<li><p>平方探测再散列 di = 1 , -1 , 2, -2 , 3 , -3 , … , k , -k(取相应数的平方)</p>\n</li>\n<li><p>随机探测再散列 di 是一组伪随机数列</p>\n</li>\n</ul>\n</li>\n<li><p>链接法：</p>\n<p>将所有哈希地址相同的记录都链接在同一链表中。</p>\n</li>\n<li><p>再哈希法：</p>\n<p>再次进行另一个哈希函数计算，直到冲突不发生。</p>\n</li>\n<li><p>建立公共溢出区</p>\n<p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>\n</li>\n</ol>\n<h1 id=\"Integer比较大小要注意的地方\"><a href=\"#Integer比较大小要注意的地方\" class=\"headerlink\" title=\"Integer比较大小要注意的地方\"></a>Integer比较大小要注意的地方</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"number\">1</span>;</span><br><span class=\"line\">Integer b = <span class=\"number\">1</span>;</span><br><span class=\"line\">System.out.println(a == b);     <span class=\"comment\">// true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">Integer c = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer d = <span class=\"number\">128</span>;</span><br><span class=\"line\">System.out.println(c == d);    <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>这是因为 Integer 类在内存中有一个值的范围为[-128, 127]的对象池。只要 Integer 对象的值在[-128, 127]范围内，都是从这个对象池中取。所以只要是这个范围的 Integer 对象，只要值相同，就是同一个对象。那么 == 的结果，就是 true。超过了这个范围，则会 new 新的 Integer 对象，尽管值相同，但是已经是不同的对象了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>);</span><br><span class=\"line\">Integer b = <span class=\"keyword\">new</span> Integer(<span class=\"number\">1</span>);</span><br><span class=\"line\">System.out.println(a == b);    <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>那么结果就是 false 了，因为他重新生成对象了；</p>\n<p>如果超过了 [-128, 127] 之间的值，被装箱后的 Integer 对象并不会被重用，即相当于每次装箱时都新建一个 Integer 对象，所以 Integer c = 128，Integer d = 128 参考的不同的对象。内存地址不同，结果是 false，对象如果要比较值，应该用 .equals()方法。<br><em>注意</em>：只有 Integer 类有对象池，其他的 Short…Double 都没有对象池</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/fly_sky23/article/details/85162859\">Java中两个Integer比较大小需要注意的误区</a></p>\n<h1 id=\"Mysql实现乐观锁\"><a href=\"#Mysql实现乐观锁\" class=\"headerlink\" title=\"Mysql实现乐观锁\"></a>Mysql实现乐观锁</h1><p>具体参考：</p>\n<p> <a href=\"https://blog.csdn.net/gaopeijiayou/article/details/100152780\">mysql实现乐观锁</a></p>\n<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><h2 id=\"线程池简介\"><a href=\"#线程池简介\" class=\"headerlink\" title=\"线程池简介\"></a>线程池简介</h2><ol>\n<li>线程池的概念：</li>\n</ol>\n<p>​     线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>\n<ol start=\"2\">\n<li>线程池的工作机制</li>\n</ol>\n<p>​     2.1 在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</p>\n<p>​     2.1 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>\n<ol start=\"3\">\n<li>使用线程池的原因：</li>\n</ol>\n<p>​    多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。</p>\n<h2 id=\"四种常见线程池\"><a href=\"#四种常见线程池\" class=\"headerlink\" title=\"四种常见线程池\"></a>四种常见线程池</h2><ol>\n<li>线程池的返回值ExecutorService简介：</li>\n</ol>\n<p>​     ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程</p>\n<ol start=\"2\">\n<li><p>具体的4种常用的线程池实现如下：（返回值都是ExecutorService）</p>\n<p>2.1  Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务</p>\n<p>2.2 Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。</p>\n<p>2.3 Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行</p>\n<p>2.4 Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>\n</li>\n</ol>\n<h2 id=\"缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor\"><a href=\"#缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor\" class=\"headerlink\" title=\"缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor\"></a>缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor</h2><p>\\1. 缓冲队列BlockingQueue简介：</p>\n<p>​     BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。</p>\n<p>\\2. 常用的几种BlockingQueue：</p>\n<ul>\n<li>ArrayBlockingQueue（int i）:规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。</li>\n<li>LinkedBlockingQueue（）或者（int i）:大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。</li>\n<li>PriorityBlockingQueue（）或者（int i）:类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。</li>\n<li>SynchronizedQueue（）:特殊的BlockingQueue，对其的操作必须是放和取交替完成。</li>\n</ul>\n<p>\\3. 自定义线程池（ThreadPoolExecutor和BlockingQueue连用）：</p>\n<p>   <em>自定义线程池，可以用ThreadPoolExecutor类创建，它有多个构造方法来创建线程池。</em></p>\n<p>  <em>常见的构造函数：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)</em></p>\n<p>具体参考：</p>\n<p><a href=\"https://www.cnblogs.com/jiawen010/p/11855768.html\">4种常用线程池介绍</a></p>\n<h1 id=\"访问量大为什么服务会崩溃，崩溃的本质是什么？\"><a href=\"#访问量大为什么服务会崩溃，崩溃的本质是什么？\" class=\"headerlink\" title=\"访问量大为什么服务会崩溃，崩溃的本质是什么？\"></a>访问量大为什么服务会崩溃，崩溃的本质是什么？</h1><p>崩溃是通俗的说法，意思是对外服务不正常了。。但是这个不正常是有语境的，比如我们淘宝买东西，应该几秒钟就提示购买成功，但是如果10秒后才出来，这个就叫负载大，卡了。如果这个时间继续增大到30秒或者1分钟，浏览器就认为超时了，直接显示打不开，那么对外就是宣称服务崩溃了。比如淘宝双11的时候很多页面打不开。但是实际上服务器上程序并没有退出，只是处理不过来了。</p>\n<p>崩溃的原因是：服务器对于请求都是排队的，负载不大的时候感觉不到，因为都是1秒内处理了。。当请求数量上去后，就开始有感觉了。但是继续增大的话，队列也满了，服务器开始丢弃部分请求<br>继续增大网络请求，操作系统的TCP协议栈也开始丢弃请求，对外表现为服务器网络也连不上了。<br>继续增大的话，网卡硬件部分开始满速运行，然后就看操作系统驱动和硬件质量了。</p>\n<h1 id=\"交替打印1-100\"><a href=\"#交替打印1-100\" class=\"headerlink\" title=\"交替打印1-100\"></a>交替打印1-100</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Printonetohundredtwo210505</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">turning</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread even = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;偶数: &quot;</span> + count++);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果还没有结束，则让出当前的锁并休眠</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        Thread odd = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;奇数: &quot;</span> + count++);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果还没有结束，则让出当前的锁并休眠</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        even.start();</span><br><span class=\"line\">        <span class=\"comment\">// 确保偶数线程线先获取到锁</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        odd.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>拓展：如果<strong>有三个线程，要求让它们交替输出 1、2、3</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread thread1,thread2,thread3;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runThread</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>&#123;</span><br><span class=\"line\">        thread1=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Thread1());</span><br><span class=\"line\">        thread2=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Thread2());</span><br><span class=\"line\">        thread3=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Thread3());</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">        thread3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(flag==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;t1=&quot;</span>+i);</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;t2=&quot;</span>+i);</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    flag=<span class=\"number\">2</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread3</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(flag==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;t3=&quot;</span>+i);</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                    flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java的基本数据类型\"><a href=\"#Java的基本数据类型\" class=\"headerlink\" title=\"Java的基本数据类型\"></a>Java的基本数据类型</h1><p>1）四种整数类型(byte、short、int、long)：   byte：8 位，用于表示最小数据单位，如文件中数据，-128<del>127   short：16 位，很少用，-32768 ~ 32767   int：32 位、最常用，-2^31-1</del>2^31 （21 亿）   long：64 位、次常用   注意事项：   int i=5; // 5 叫直接量（或字面量），即 直接写出的常数。   整数字面量默认都为 int 类型，所以在定义的 long 型数据后面加 L或 l。   小于 32 位数的变量，都按 int 结果计算。   强转符比数学运算符优先级高。见常量与变量中的例子。</p>\n<p>2）两种浮点数类型(float、double)：   float：32 位，后缀 F 或 f，1 位符号位，8 位指数，23 位有效尾数。   double：64 位，最常用，后缀 D 或 d，1 位符号位，11 位指数，52 位有效尾   注意事项：   二 进 制 浮 点 数 ： 1010100010=101010001.0<em>2=10101000.10</em>2^10（2次方)=1010100.010<em>2^11(3次方)= . 1010100010</em>2^1010(10次方)   尾数： . 1010100010  指数：1010  基数：2   浮点数字面量默认都为 double 类型，所以在定义的 float 型数据后面加F 或 f；double 类型可不写后缀，但在小数计算中一定要写 D 或 X.X   float 的精度没有 long 高，有效位数（尾数）短。   float 的范围大于 long 指数可以很大。   浮点数是不精确的，不能对浮点数进行精确比较。</p>\n<p>3）一种字符类型(char)：   char：16 位，是整数类型，用单引号括起来的 1 个字符（可以是一个中文字符），使用 Unicode 码代表字符，0~2^16-1（65535） 。   注意事项：   不能为 0个字符。   转义字符：\\n 换行 \\r 回车 \\t Tab 字符 &quot; 双引号 \\ 表示一个\\   两字符 char 中间用“+”连接，内部先把字符转成 int 类型，再进行加法运算，char 本质就是个数！二进制的，显示的时候，经过“处理”显示为字符。</p>\n<p>4）一种布尔类型(boolean)：true 真 和 false 假。</p>\n<h1 id=\"Java中有了基本类型为什么还要有包装类型\"><a href=\"#Java中有了基本类型为什么还要有包装类型\" class=\"headerlink\" title=\"Java中有了基本类型为什么还要有包装类型?\"></a>Java中有了基本类型为什么还要有包装类型?</h1><p>Java中基本数据类型与包装类型有：</p>\n<table>\n<thead>\n<tr>\n<th><strong>基本类型</strong></th>\n<th><strong>包装器类型</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody></table>\n<p>为什么存在这两种类型呢？</p>\n<p>我们都知道在Java语言中，new一个对象存储在堆里，我们通过栈中的引用来使用这些对象；但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在栈中，因此更加高效。</p>\n<p>有了基本类型为什么还要有包装类型呢？</p>\n<p>我们知道Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>\n<p>另外，当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装器类了。</p>\n<p>二者相互转换：</p>\n<p>1、int转Integer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;  </span><br><span class=\"line\">Integer ii = <span class=\"keyword\">new</span> Integer(i);</span><br></pre></td></tr></table></figure>\n\n<p>2、Integer转int</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer ii = <span class=\"keyword\">new</span> Integer(<span class=\"number\">0</span>);  </span><br><span class=\"line\"><span class=\"keyword\">int</span> i = ii.intValue();  </span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>二者的区别：</p>\n<ol>\n<li>声明方式不同：</li>\n</ol>\n<p>基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；</p>\n<ol start=\"2\">\n<li>存储方式及位置不同：</li>\n</ol>\n<p>基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；</p>\n<ol start=\"3\">\n<li>初始值不同：</li>\n</ol>\n<p>基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</p>\n<ol start=\"4\">\n<li>使用方式不同：</li>\n</ol>\n<p>基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</p>\n<p>具体参考：</p>\n<p><a href=\"https://blog.csdn.net/min996358312/article/details/62894674\">java中有了基本类型为什么还要有包装类型?</a></p>\n<h1 id=\"为什么HashMap中String、Integer这样的包装类适合作为K？\"><a href=\"#为什么HashMap中String、Integer这样的包装类适合作为K？\" class=\"headerlink\" title=\"为什么HashMap中String、Integer这样的包装类适合作为K？\"></a><strong>为什么HashMap中String、Integer这样的包装类适合作为K？</strong></h1><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>\n<p>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况<br>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况<br>如果Object作为键，那么需要重写hashCode()和equals()方法</p>\n<p>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞<br>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性</p>\n<h1 id=\"HashMap和Hashtable实现类的区别\"><a href=\"#HashMap和Hashtable实现类的区别\" class=\"headerlink\" title=\"HashMap和Hashtable实现类的区别\"></a>HashMap和Hashtable实现类的区别</h1><p><strong>区别</strong></p>\n<ul>\n<li>Hashtable是线性安全的，HashMap是线性不安全的，所以后者效率更高。</li>\n<li>Hashtable不允许使用null作为key和value，否则会引发异常，而HashMap可以；</li>\n</ul>\n<h1 id=\"HashMap和HashSet实现类的区别\"><a href=\"#HashMap和HashSet实现类的区别\" class=\"headerlink\" title=\"HashMap和HashSet实现类的区别\"></a>HashMap和<strong>HashSet</strong>实现类的区别</h1><ul>\n<li>与HashSet集合不能保证元素顺序一样，HashMap和Hashtable也不能保证键值对的顺序。他们判断两个key相等的标准也是：两个key通过equals方法比较返回true，两个key的hashCode值也相等。而判断value值相等的标准：只要两个对象通过equals方法比较返回true即可。</li>\n<li>不能修改集合中的key，否则程序再也无法准确访问到Map中被修改过的key。</li>\n</ul>\n","tags":["面经"]}]