<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Mynote">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Mynote">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="porridgechou">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mynote</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mynote</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/08/HuaweiMainjing210408/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/08/HuaweiMainjing210408/" class="post-title-link" itemprop="url">华为面经体验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-08 20:13:00" itemprop="dateCreated datePublished" datetime="2021-04-08T20:13:00+08:00">2021-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-10 00:21:12" itemprop="dateModified" datetime="2021-04-10T00:21:12+08:00">2021-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="http-协议如何保证可靠性"><a href="#http-协议如何保证可靠性" class="headerlink" title="http 协议如何保证可靠性"></a>http 协议如何保证可靠性</h1><p><strong>重要的数据，要加密</strong>，比如用户名密码，我们需要加密，这样即使被抓包监听，他们也不知道原始数据是什么（如果简单的md5，是可以暴力破解），所以加密方法越复杂越安全，根据需要，常见的是 md5(不可逆)，aes（可逆），自由组合吧,你还可以加一些特殊字符啊，没有做不到只有想不到， 举例：username = aes(username), pwd = MD5(pwd + username);。。。。。</p>
<p><strong>非重要数据，要签名</strong>，签名的目的是为了防止篡改，比如<a target="_blank" rel="noopener" href="http://www.xxx.com/getnews?id=1%EF%BC%8C%E8%8E%B7%E5%8F%96id%E4%B8%BA1%E7%9A%84%E6%96%B0%E9%97%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E7%AD%BE%E5%90%8D%E9%82%A3%E4%B9%88%E9%80%9A%E8%BF%87id=2,%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%962%E7%9A%84%E5%86%85%E5%AE%B9%E7%AD%89%E7%AD%89%E3%80%82%E6%80%8E%E6%A0%B7%E7%AD%BE%E5%90%8D%E5%91%A2%EF%BC%9F%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8sign%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8E%9F%E9%93%BE%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%E5%8A%A0%E4%B8%80%E4%B8%AAsign%E5%8F%82%E6%95%B0%EF%BC%8Csign=md5(id=1)%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E5%8F%97%E5%88%B0%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%AA%8C%E8%AF%81sign%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8Emd5(id=1)%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%AD%89%E4%BA%8E%E8%AF%B4%E6%98%8E%E6%AD%A3%E5%B8%B8%E8%AF%B7%E6%B1%82%E3%80%82%E8%BF%99%E4%BC%9A%E6%9C%89%E4%B8%AA%E5%BC%8A%E7%AB%AF%EF%BC%8C%E5%81%87%E5%A6%82%E8%A7%84%E5%88%99%E8%A2%AB%E5%8F%91%E7%8E%B0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E4%BC%9A%E8%A2%AB%E4%BC%AA%E9%80%A0%EF%BC%8C%E6%89%80%E4%BB%A5%E9%80%82%E5%BD%93%E5%A4%8D%E6%9D%82%E4%B8%80%E4%BA%9B%EF%BC%8C%E8%BF%98%E6%98%AF%E8%83%BD%E5%A4%9F%E6%8F%90%E9%AB%98%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E3%80%82">http://www.xxx.com/getnews?id=1，获取id为1的新闻，如果不签名那么通过id=2,就可以获取2的内容等等。怎样签名呢？通常使用sign，比如原链接请求的时候加一个sign参数，sign=md5(id=1)，服务器接受到请求，验证sign是否等于md5(id=1)，如果等于说明正常请求。这会有个弊端，假如规则被发现，那么就会被伪造，所以适当复杂一些，还是能够提高安全性的。</a></p>
<p><strong>登录态怎么做，</strong>http是无状态的，也就是服务器没法自己判断两个请求是否有联系，那么登录之后，以后的接口怎么判定是否登录呢，简单的做法，在数据库中存一个token字段（名字随意），当用户调用登陆接口成功的时候，就将该字段设一个值，（比如aes(过期时间)），同时返回给前端，以后每次前端请求带上该值，服务器首先校验是否过期，其次校验是否正确，不通过就让其登陆。（redis 做这个很方便哦，key有过期时间）。</p>
<p>具体可参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/l18848956739/article/details/81011194">如何保证http传输安全性</a> </p>
<p><a href="%5Bhttps://hellogoogle.blog.csdn.net/article/details/94440881?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1329187.12416.16178842483851657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control%5D(https://hellogoogle.blog.csdn.net/article/details/94440881?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1329187.12416.16178842483851657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control)">【Java】【通信安全】怎么保证http请求的安全性</a></p>
<h1 id="多线程相关面试题"><a href="#多线程相关面试题" class="headerlink" title="多线程相关面试题"></a>多线程相关面试题</h1><p>具体可参考：</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/weibanggang/p/9470462.html">多线程面试题</a></p>
<h1 id="如何实现线程同步"><a href="#如何实现线程同步" class="headerlink" title="如何实现线程同步"></a>如何实现线程同步</h1><h2 id="Synchronized-用在普通方法和-static-上的区别"><a href="#Synchronized-用在普通方法和-static-上的区别" class="headerlink" title="Synchronized 用在普通方法和 static 上的区别"></a>Synchronized 用在普通方法和 static 上的区别</h2><p>当使用synchronized修饰静态方法时，线程此时获得的锁对象是类的Class对象（<strong>堆内存中只有唯一一个Class对象，因为Class对象是在类加载时产生的，而类加载只执行一次</strong>），因此会锁住整个类，其他线程无法访问该类的同步静态方法，但是可以访问非同步的方法</p>
<p>回答2：</p>
<p>synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；</p>
<p>synchronized修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p>
<p>具体可参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33819764/article/details/81736729">【多线程】实现线程同步的几种方法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43658899/article/details/107230699">Synchronized关键字加在普通方法上和加在静态方法上有什么区别?</a></p>
<h1 id="Java语言的特点和特性"><a href="#Java语言的特点和特性" class="headerlink" title="Java语言的特点和特性"></a>Java语言的特点和特性</h1><h2 id="1-Java语言的主要特点："><a href="#1-Java语言的主要特点：" class="headerlink" title="1.　　Java语言的主要特点："></a>1.　　<strong>Java</strong>语言的主要特点：</h2><p>　　　1. 跨平台性</p>
<p>　　　所谓的跨平台性，是指软件可以不受计算机硬件和操作系统的约束而在任意计算机环境下正常运行。这是软件发展的趋势和编程人员追求的目标。之所以这样说，是因为计算机硬件的种类繁多，操作系统也各不相同，不同的用户和公司有自己不同的计算机环境偏好，而软件为了能在这些不同的环境里正常运行，就需要独立于这些平台。而在<strong>Java</strong>语言中， <strong>Java</strong>自带的虚拟机很好地实现了跨平台性。 <strong>Java</strong>源程序代码经过编译后生成二进制的字节码是与平台无关的，但是可被<strong>Java</strong>虚拟机识别的一种机器码指令。 <strong>Java</strong>虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得<strong>Java</strong>语言具备跨平台性。</p>
<p>　　　2. 面向对象</p>
<p>　　　面向对象是指以对象为基本粒度，其下包含属性和方法。对象的说明用属性表达，而通过使用方法来操作这个对象。面向对象技术使得应用程序的开发变得简单易用，节省代码。<strong>Java</strong>是一种面向对象<strong>的语言</strong>，也继承了面向对象的诸多好处，如代码扩展、代码复用等。</p>
<p>　　　3. 安全性</p>
<p>　　　安全性可以分为四个层面，即语言级安全性、编译时安全性、运行时安全性、可执行代码安全性。语言级安全性指<strong>Java</strong>的数据结构是完整的对象，这些封装过的数据类型具有安全性。编译时要进行<strong>Java</strong>语言和语义的检查，保证每个变量对应一个相应的值，编译后生成<strong>Java</strong>类。运行时<strong>Java</strong>类需要类加载器载入www jxzxmr net，并经由字节码校验器校验之后才可以运行。 <strong>Java</strong>类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。</p>
<p>　　　4. 多线程</p>
<p>　　　多线程在操作系统中已得到了最成功的应用。多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于支持事务并发和多任务处理。 <strong>Java</strong>除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。</p>
<p>　　　5. 简单易用</p>
<p>　　　<strong>Java</strong>源代码的书写不拘泥于特定的环境，可以用记事本、文本编辑器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。</p>
<h2 id="2-Java语言的几大特性："><a href="#2-Java语言的几大特性：" class="headerlink" title="2.　　Java语言的几大特性："></a>2.　　<strong>Java</strong>语言的几大<strong>特性</strong>：</h2><p>　　　1.封装： </p>
<p>　　　封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在<strong>java</strong>中通过关键字private，protected和public实现封装。什么是封装？封装把对象的所有组成部分组合在一起，封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。</p>
<p>　　　2.继承：</p>
<p>　　　继承是面向对象最显著的一个<strong>特性</strong>。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 <strong>Java</strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。这种技术使得复用以前的代码非常容易，能够大大缩短开发周期，降低开发费用</p>
<p>　　　3.多态： </p>
<p>　　　按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的<strong>特性</strong>以不同的方式运作 多态的话，我觉得是更好的利用了继承这一<strong>特性</strong>，然后为什么能实现多态，因为可以重写父类的方法。说重写可能不清楚，具体来说就是子类父类可以存在分别存在名字相同的属性或者方法，然后可视声明的类去调用相应的方法等。</p>
<p>　　　4.抽象：<br>　　　抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法，我觉得理解成一种方法比较好。就是我们通过对事物的认知，将某一或者一类事物的属性变化成<strong>JAVA</strong>语言能识别的类。</p>
<h1 id="static关键字总结"><a href="#static关键字总结" class="headerlink" title="static关键字总结"></a>static关键字总结</h1><h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a><strong>静态变量和静态方法</strong></h2><p>static关键字最基本的用法是：</p>
<p>1、被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来</p>
<p>2、被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来\</p>
<h2 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a><strong>静态块</strong></h2><p>静态块也是static的重要应用之一。也是用于初始化一个类的时候做操作用的，和静态变量、静态方法一样，<strong>静态块里面的代码只执行一次，且只在初始化类的时候执行</strong>。静态块很简单，不过提三个小细节：</p>
<ol>
<li><p><strong>静态资源的加载顺序是严格按照静态资源的定义顺序来加载的</strong>。</p>
</li>
<li><p><strong>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问</strong>。</p>
</li>
<li><p><strong>静态代码块是严格按照父类静态代码块-&gt;子类静态代码块的顺序加载的，且只加载一次</strong>。</p>
<p>最后一个小例子：</p>
</li>
</ol>
<p>具体可参考：</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/swisszhang/p/9892992.html">static关键字作用总结</a></p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><strong>存储引擎</strong>说白了就是如何存储数据、如何为存储的数据建立<strong>索引</strong>和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以<strong>存储引擎</strong>也可以称为表类型（即存储和操作此表的类型）。</p>
<p>在Oracle 和SQL Server等数据库中只有一种<strong>存储引擎</strong>，所有数据存储管理机制都是一样的。而MySql数据库提供了多种<strong>存储引擎</strong>。用户可以根据不同的需求为数据表选择不同的<strong>存储引擎</strong>，用户也可以根据自己的需要编写自己的<strong>存储引擎</strong>。</p>
<p>\2.   <strong>存储引擎</strong>的类型及特点</p>
<table>
<thead>
<tr>
<th><strong>引擎名称</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺陷</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>MyISAM</strong></td>
<td>独立于操作系统，这说明可以轻松地将其从Windows服务器移植到Linux服务器</td>
<td>不支持事务/行级锁/外键约束</td>
<td>适合管理邮件或Web服务器日志数据</td>
</tr>
<tr>
<td><strong>InnoDB</strong></td>
<td>健壮的事务型<strong>存储引擎</strong>；支持事务/行级锁/外键约束自动灾难恢复/AUTO_INCREMENT</td>
<td></td>
<td>需要事务支持，并且有较高的并发读取频率</td>
</tr>
<tr>
<td><strong>MEMORY</strong></td>
<td>为得到最快的响应时间，采用的逻辑存储介质是系统内存</td>
<td>当mysqld守护进程崩溃时，所有的Memory数据都会丢失；不能使用BLOB和TEXT这样的长度可变的数据类型</td>
<td>临时表</td>
</tr>
<tr>
<td><strong>MERGE</strong></td>
<td>是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表</td>
<td></td>
<td>常应用于日志和数据仓库</td>
</tr>
<tr>
<td><strong>ARCHIVE</strong></td>
<td>归档的意思，支持<strong>索引</strong>，拥有很好的压缩机制</td>
<td>仅支持插入和查询功能</td>
<td>经常被用来当做仓库使用</td>
</tr>
</tbody></table>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是对<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>表中一个或多个列（例如，employee 表的姓名 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</p>
<p>例如这样一个查询：select * from table1 where id=10000。如果没有索引，必须遍历整个表，直到ID等于10000的这一行被找到为止；有了索引之后(必须是在ID这一列上建立的索引)，即可在索引中查找。由于索引是经过某种算法优化过的，因而查找次数要少的多。可见，索引是用来定位的。</p>
<h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a><strong>分类：</strong></h2><p><strong>唯一索引</strong></p>
<p>唯一索引是不允许其中任何两行具有相同索引值的索引。<br>当现有数据中存在重复的键值时，大多数<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>不允许将新创建的唯一索引与表一起保存。<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p>
<p><strong>主键索引</strong></p>
<p><a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。<br>在<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>
<p><strong>聚集索引</strong></p>
<p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。<br>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/11725"><strong>【程序员必读系列】-数据库索引的原理</strong></a></p>
<h1 id="分布式、微服务和集群的初步了解"><a href="#分布式、微服务和集群的初步了解" class="headerlink" title="分布式、微服务和集群的初步了解"></a>分布式、微服务和集群的初步了解</h1><p><strong>微服务</strong></p>
<p>简单来说微服务就是很小的服务，<strong>小到一个服务只对应一个单一的功能，只做一件事</strong>。这个服务可以单独部署运行，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</p>
<p><strong>微服务架构</strong></p>
<p>在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。</p>
<p><strong>分布式</strong></p>
<p>分布式服务顾名思义服务是<strong>分散部署在不同的机器上</strong>，一个服务可能负责几个功能，是一种面向SOA架构的，服务之间也是通过rpc来交互或者是webservice来交互的。</p>
<p>逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署，生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。<br>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难.</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yaoyao-sun/p/10422019.html">分布式、微服务和集群的初步了解</a></p>
<h1 id="Java类加载器与双亲委派模式的详解"><a href="#Java类加载器与双亲委派模式的详解" class="headerlink" title="Java类加载器与双亲委派模式的详解"></a>Java类加载器与双亲委派模式的详解</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38055381/article/details/81382115">Java类加载器与双亲委派模式的详解</a></p>
<h1 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h1><p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p>
<h1 id="B树，B-树的原理及区别"><a href="#B树，B-树的原理及区别" class="headerlink" title="B树，B+树的原理及区别"></a>B树，B+树的原理及区别</h1><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p><img src="/images/pasted-210408Btree.jpg"></p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><pre><code>  1.其定义基本与B-树同，除了：
</code></pre>
<p>​      2.非叶子结点的子树指针与关键字个数相同；</p>
<p>​      3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</p>
<p>​      4.为所有叶子结点增加一个链指针；</p>
<p>​      5.所有关键字都在叶子结点出现；</p>
<p><img src="/images/pasted-210408B+tree.jpg"></p>
<p> B+的特性：</p>
<p>​      1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>
<p>​      2.不可能在非叶子结点命中；</p>
<p>​      3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>
<p>​      4.更适合文件索引系统；</p>
<h2 id="为什么B-树比B树更适合数据库索引？"><a href="#为什么B-树比B树更适合数据库索引？" class="headerlink" title="为什么B+树比B树更适合数据库索引？"></a>为什么B+树比B树更适合数据库索引？</h2><p>1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<p>4、B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p>
<p>具体参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzzi/article/details/90208999">为什么说B+树比B树更适合数据库索引？</a></p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="红黑树规则"><a href="#红黑树规则" class="headerlink" title="红黑树规则"></a>红黑树规则</h2><p>红黑树有必须要遵守的规则，称为红-黑规则：</p>
<p>每个节点不是红色就是黑色的；<br>根节点总是黑色的；<br>红色节点的子节点必须是黑色的（反之不一定）。也就是从每个叶子到根的路径上不能有两个连续的红色节点；<br>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</p>
<h2 id="红黑树性能分析"><a href="#红黑树性能分析" class="headerlink" title="红黑树性能分析"></a>红黑树性能分析</h2><p>红黑树的查找、插入和删除时间复杂度都为O(logN)，额外的开销是每个节点的存储空间都稍微增加了一点，因为一个存储红黑树节点的颜色变量。插入和删除的时间要增加一个常数因子，因为要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是 O(logN)，(时间复杂度的计算要省略常数)，但实际上红黑树的插入和删除比普通的二叉树是要慢的。</p>
<p>红黑树适用于查找的次数比插入和删除的次数大很多的情况，红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。</p>
<p>具体参考：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_Wanderer/article/details/113872720">https://blog.csdn.net/Mr_Wanderer/article/details/113872720</a></p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉搜索树作为一种数据结构，其查找、插入和删除操作的时间复杂度都为O(logn)，底数为2。</p>
<p>但是我们说这个时间复杂度是在平衡的二叉搜索树上体现的，也就是如果插入的数据是随机的，则效率很高，但是如果插入的数据是有序的，比如从小到大的顺序【10,20,30,40,50】插入到二叉搜索树中：从大到小就是全部在左边，这和链表没有任何区别了，这种情况下查找的时间复杂度为O(N)，而不是O(logN)。当然这是在最不平衡的条件下，实际情况下，<strong>二叉搜索树的效率应该在O(N)和O(logN)之间，这取决于树的不平衡程度</strong>。</p>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>查找、插入和删除在平均和最坏情况下都是O（log n）。</p>
<p> 高度为 h 的 AVL 树，节点数 N 最多2^h − 1；</p>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="浅拷贝（Shallow-Copy）："><a href="#浅拷贝（Shallow-Copy）：" class="headerlink" title="浅拷贝（Shallow Copy）："></a><strong>浅拷贝</strong>（Shallow Copy）：</h2><p>①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</p>
<p><img src="https://images2017.cnblogs.com/blog/1218256/201710/1218256-20171011182513121-1029542999.png" alt="img"></p>
<p>浅拷贝的实现方式主要有三种：</p>
<p>一、通过拷贝构造方法实现浅拷贝：</p>
<p>拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。</p>
<p>二、通过重写clone()方法进行浅拷贝：</p>
<p>Object类是类结构的根类，其中有一个方法为protected Object <strong>clone</strong>() throws <a target="_blank" rel="noopener" href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/CloneNotSupportedException.html">CloneNotSupportedException</a>，这个方法就是进行的浅拷贝。有了这个浅拷贝模板，我们可以通过调用clone()方法来实现对象的浅拷贝。但是需要注意：1、Object类虽然有这个方法，但是这个方法是受保护的（被protected修饰），所以我们无法直接使用。2、使用clone方法的类必须实现Cloneable接口，否则会抛出异常CloneNotSupportedException。对于这两点，我们的解决方法是，在要使用clone方法的类中重写clone()方法，通过super.clone()调用Object类中的原clone方法。</p>
<p>基本数据类型是值传递，所以修改值后不会影响另一个对象的该属性值；</p>
<p>引用数据类型是地址传递（引用传递），所以修改值后另一个对象的该属性值会同步被修改。</p>
<h2 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h2><p>首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象图进行拷贝！</p>
<p>简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。</p>
<p>深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。</p>
<p><img src="https://images2017.cnblogs.com/blog/1218256/201710/1218256-20171011190501371-68869476.png" alt="img"></p>
<p>因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>深拷贝的实现方法主要有两种：</p>
<p>一、通过重写clone方法来实现深拷贝</p>
<p>与通过重写clone方法实现浅拷贝的基本思路一样，只需要为对象图的每一层的每一个对象都实现Cloneable接口并重写clone方法，最后在最顶层的类的重写的clone方法中调用所有的clone方法即可实现深拷贝。简单的说就是：每一层的每个对象都进行浅拷贝=深拷贝。</p>
<p>分析结果可以验证：进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。</p>
<p>二、通过对象序列化实现深拷贝</p>
<p>虽然层次调用clone方法可以实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写clone方法太过繁琐。</p>
<p>将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>JVM在进行GC时，并不是对这三个区域统一回收。 大部分时候，回收都是新生代~<br>●新生代<br><strong>●幸存区(form，to)</strong><br>●老年区<br>GC两种类:轻GC (普通的GC)， 重GC (全局GC)<br>GC常见面试题目:<br>●JVM的内存模型和分区~详细到每个区放什么?<br><img src="https://img-blog.csdnimg.cn/20200715153153103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p> 图 JVM内存模型和分区</p>
<p>●堆里面的分区有哪些?<br>Eden, form, to, 老年区,说说他们的特点!<br>●GC的算法有哪些?<br>标记清除法，标记整理,复制算法，引用计数器<br>●轻GC和重GC分别在什么时候发生?</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42671148/article/details/108274558">JVM-狂神学习笔记</a></p>
<h1 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h1><p>在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程<br>　　<strong>第一</strong>：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>　　<strong>第二</strong>：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>　　<strong>第三</strong>：提高线程的可管理性。<br>常用线程池：ExecutorService 是主要的实现类，其中常用的有 :<br>Executors.newSingleThreadPool()</p>
<p>  　　newFixedThreadPool()</p>
<p>  　　newcachedTheadPool()</p>
<p>  　 newScheduledThreadPool()</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zeze/p/6548649.html">线程池的作用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/superfj/p/7544971.html">由浅入深理解Java线程池及线程池的如何使用</a></p>
<h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>局部性通常分为：<strong>时间局部性</strong>和<strong>空间局部性</strong>。</p>
<p>1）时间局部性<br>时间局部性是指被引用过一次的内存位置很可能在不远的将来再被多次引用。</p>
<p>2）空间局部性<br>空间局部性是指如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用其附近的一个内存位置。</p>
<p>3）局部性原理举例</p>
<ul>
<li>在硬件层，局部性原理允许计算机设计者通过引入小而快的高速缓存存储器来保存最近被引用的指令和数据项，从而提高对主存的访问速度。</li>
<li>在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。</li>
<li>类似的，操作系统用主存来缓存磁盘文件系统中最近被使用的磁盘块。</li>
<li>在应用程序的设计，如Web浏览器将最近被请求的文档放在本地磁盘上，利用的就是时间局部性。大容量的Web服务器将最近被请求的文档放在前端磁盘高速缓存中，不需要服务器的干预就可满足对这些文档的请求。</li>
</ul>
<h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<h1 id="Linux下的编译和执行"><a href="#Linux下的编译和执行" class="headerlink" title="Linux下的编译和执行"></a>Linux下的编译和执行</h1><p>具体参考：</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013793399/article/details/51365311">在Linux系统下编译并执行C++程序</a></p>
<h1 id="Spring相关面试题"><a href="#Spring相关面试题" class="headerlink" title="Spring相关面试题"></a>Spring相关面试题</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41701956/article/details/81389067">近5年来的 Spring 相关面试题整理</a></p>
<h1 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h1><p>具体参考：</p>
<p><a href="%5Bhttps://jpeony.blog.csdn.net/article/details/80950336?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control%5D(https://jpeony.blog.csdn.net/article/details/80950336?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control)">【JVM】垃圾回收机制(1)–如何判定对象可以回收</a></p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。</p>
<h2 id="SQL注入攻击的总体思路"><a href="#SQL注入攻击的总体思路" class="headerlink" title="SQL注入攻击的总体思路"></a>SQL注入攻击的总体思路</h2><p>　　1：寻找到SQL注入的位置</p>
<p>　　2：判断服务器类型和后台数据库类型</p>
<p>　　3：针对不同的服务器和数据库特点进行SQL注入攻击</p>
<h1 id="各网络层的协议"><a href="#各网络层的协议" class="headerlink" title="各网络层的协议"></a>各网络层的协议</h1><p>TCP/IP体系结构</p>
<p><img src="https://img-blog.csdnimg.cn/20200823014026904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI4MjA2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>TCP/IP协议各层功能</p>
<p>各层所包含的协议</p>
<p><img src="https://img-blog.csdnimg.cn/20200823014123331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI4MjA2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>协议栈<br>各层的所有协议被称为协 议栈(protocol stack).因特网的协议栈由5个层次组成：物理层，数据链路层，网络层，运输层，应用层。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>(1)应用层(application layer) 应用层是体系结构中的最高层。应用层直接为用户的应用进程提供服务。这里的进程就是指正在运行的程序。在因特网中的应用层协议很多， 如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等等。<br>应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中 的应用程序交换信息分组。我们将这种位于应用层的信息分组称为报文（message）。</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>迈输层提供了在应用程序端点之间传送应用层报文的服务。<br>(2)运输层(transport layer) 运输层的任务就是负责向两个主机中进程之间的通信提 供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多 个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付给上面 应用层中的相应的进程。运输层分组称为报文段。<br>运输层主要使用以下两种协议：<br>① 传输控制协议TCP (Transmission Control Protocol) 面向连接的，数据传输的单位<br>是报文段(segment),能够提供可靠的交付。<br>② 用户数据报协议UDP (User Datagram Protocol) 无连接的，数据传输的单位是用<br>户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付(best-effortdelivery)”<br>TCP与UDP区别<br>协议，即TCP和UDP,利用其中的任何一个都能传输应用层报文。TCP向它的应用程序提供了 面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流童控制(即发送方/接 收方速率匹配)。TCP也将长报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时， 源抑制其传输速率。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务 的服务，不提供可靠性，没有流量控制，也没有拥塞控制。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>(3)因特网的网络层负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主 机。源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址， 就像你向邮政信件提供目的地址一样。在 TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报，或简称为数据报。<br>因特网的网络层包括著名的IP协议，该协议定义了数据报中的各个字段以及端系统和路 由器如何作用于这些字段。仅有一个IP协议，所有具有网络层的因特网组件都必须运行IP协议。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>(4)数据链路层(data link layer) 常简称为链路层。我们知道，两个主机之间的数据 传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间(主机和路由器之 间或两个路由器之间)传送数据是直接传送的(点对点)。这时就需要使用专门的链路层的 协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧 (framing),在两个相邻结点间的链路上“透明”地传送帧(frame)中的数据。每一帧包括数据 和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将 该帧中的一个一个比特从一个节点移动到下一个节点。该层中的协议仍然是链路相关的，并 且进一步与链路（例如，双绞铜线、单模光纤）的实际传输媒体相关。例如，以太网具有许 多物理层协议：关于双绞铜线的，关于同轴电缆的，关于光纤的，等等。在每种情况下，跨 越这些链路移动一个比特的方式不同。</p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>一篇比较好的并查集：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42011541/article/details/83378709">https://blog.csdn.net/qq_42011541/article/details/83378709</a></p>
<p>N个人要坐在桌子上吃饭，但是人们拒绝和陌生人坐在一张桌子上。什么样的不算陌生人呢？主要是朋友的朋友的朋友的…..只要能扯上关系就不算陌生人。能扯上关系就可以坐在一张桌子上。所以至少要准备多少张桌子？</p>
<p>思路：其实就是对并查集进行合并操作，只要俩人认识，就组队。把队组好以后，看最后有多少个组(集合)就行了。最初每个人都自成一组，所以有多少人就有多少组。但是随着他们组队，每两个组合并成一个组，总的组数就会少1。如果组队的时候发现，他俩已经早就‘扯上关系了’，也就表名他俩早就是一组了，那就不用继续合并了，也就不用再 -1 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//代表并查集中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> groups;<span class="comment">//代表并查集中有多少个集合（小组）</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.groups = size;<span class="comment">//因为初始的时候每个人自成一组，所以有多少人就有多少组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>.weight[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (element != parent[element]) &#123;</span><br><span class="line">            parent[element] = parent[parent[element]];</span><br><span class="line">            element = parent[element];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> firstElement, <span class="keyword">int</span> secondElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(firstElement) == find(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> firstElement, <span class="keyword">int</span> secondElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstRoot = find(firstElement);</span><br><span class="line">        <span class="keyword">int</span> secondRoot = find(secondElement);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果已经属于同一个集合了，就不用再合并了。</span></span><br><span class="line">        <span class="keyword">if</span> (firstRoot == secondRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (weight[firstRoot] &gt; weight[secondRoot]) &#123;</span><br><span class="line">            parent[secondRoot] = firstRoot;</span><br><span class="line">            weight[firstRoot] += weight[secondRoot];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//weight[firstRoot] &lt;= weight[secondRoot]</span></span><br><span class="line">            parent[firstRoot] = secondRoot;</span><br><span class="line">            weight[secondRoot] += weight[firstRoot];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//合并 firstElement 和 secondElement 所在的两个组后，就少了一组。</span></span><br><span class="line">        <span class="keyword">this</span>.groups--;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGroups</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.groups;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.Scanner scanner = <span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> times = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = scanner.nextInt();</span><br><span class="line">            UnionFind union = <span class="keyword">new</span> UnionFind(size);</span><br><span class="line">            <span class="keyword">int</span> input = scanner.nextInt();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input; j++) &#123;</span><br><span class="line">                <span class="comment">//因为测试数据是从1开始，而我们的并查集是从数组的第0位开始</span></span><br><span class="line">                <span class="keyword">int</span> first = scanner.nextInt() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> second = scanner.nextInt() - <span class="number">1</span>;</span><br><span class="line">                union.unionElements(first, second);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(union.getGroups());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>

<h1 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h1><p>transient关键字的作用是：被transient修饰的变量不参与序列化和反序列化。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>简要解释：<br>　　序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>　　序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，<br>然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangchunze/p/6728086.html">什么是Java序列化，如何实现java序列化</a></p>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>Java线程可以有优先级的设定，高优先级的线程比低优先级的线程有更高的几率得到执行（不完全正确，请参考下面的“线程优先级的问题“）。</p>
<ol>
<li>记住当线程的优先级没有指定时，所有线程都携带普通优先级。</li>
<li>优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。</li>
<li>记住优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态。</li>
<li>与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。</li>
<li>由调度程序决定哪一个线程被执行。</li>
<li>t.setPriority()用来设定线程的优先级。</li>
<li>记住在线程开始方法被调用之前，线程的优先级应该被设定。</li>
<li>你可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级。</li>
</ol>
<h1 id="Java线程和操作系统线程的关系"><a href="#Java线程和操作系统线程的关系" class="headerlink" title="Java线程和操作系统线程的关系"></a>Java线程和操作系统线程的关系</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CringKong/article/details/79994511">Java线程和操作系统线程的关系</a></p>
<h1 id="final的用法"><a href="#final的用法" class="headerlink" title="final的用法"></a>final的用法</h1><h3 id="1-修饰数据"><a href="#1-修饰数据" class="headerlink" title="1.修饰数据"></a>1.修饰数据</h3><h3 id="2-修饰方法参数"><a href="#2-修饰方法参数" class="headerlink" title="2.修饰方法参数"></a>2.修饰方法参数</h3><h3 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h3><h3 id="4-修饰类"><a href="#4-修饰类" class="headerlink" title="4.修饰类"></a>4.修饰类</h3><p>总结<br>final关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：</p>
<ol>
<li><p>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；</p>
</li>
<li><p>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；</p>
</li>
<li><p>修饰方法，表示该方法无法被重写；</p>
</li>
<li><p>修饰类，表示该类无法被继承。</p>
</li>
</ol>
<p>上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/04/210404Java-jihelei/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/04/210404Java-jihelei/" class="post-title-link" itemprop="url">Java常用集合类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-04 18:56:00 / 修改时间：19:24:21" itemprop="dateCreated datePublished" datetime="2021-04-04T18:56:00+08:00">2021-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>inkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p>
<h2 id="新建队列"><a href="#新建队列" class="headerlink" title="新建队列"></a><strong>新建队列</strong></h2><p>Queue<String> queue=new LinkedList<Steing>;</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h2><p>queue.offer(“a”);</p>
<h2 id="返回第一个元素，并在队列中删除"><a href="#返回第一个元素，并在队列中删除" class="headerlink" title="返回第一个元素，并在队列中删除"></a><strong>返回第一个元素，并在队列中删除</strong></h2><p>queue.poll();</p>
<h2 id="返回第一个元素"><a href="#返回第一个元素" class="headerlink" title="返回第一个元素"></a><strong>返回第一个元素</strong></h2><p>queue.element();</p>
<p>或者</p>
<p>queue.peek();</p>
<h1 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a><strong>Deque</strong></h1><p>双端队列（两端都可进出）</p>
<h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a><strong>新建</strong></h2><p>Deque<String>  deque= new LinkList&lt;&gt;();</p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a><strong>相关函数</strong></h2><p><img src="/images/pasted-210404.jpg"></p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="新建-1"><a href="#新建-1" class="headerlink" title="新建"></a><strong>新建</strong></h2><p>ArrayList<String> arraylist=new ArrayList<String>();</p>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h2><p>arraylist.get(0);//访问第1个元素</p>
<h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a><strong>修改元素</strong></h2><p>arraylist.set(2,”wiki”);</p>
<h2 id="计算大小"><a href="#计算大小" class="headerlink" title="计算大小"></a><strong>计算大小</strong></h2><p>arraylist.size();</p>
<h2 id="ArrayList排序"><a href="#ArrayList排序" class="headerlink" title="ArrayList排序"></a><strong>ArrayList排序</strong></h2><p>Collections.sort(arraylist);</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h1><h2 id="与ArrayList的使用对比"><a href="#与ArrayList的使用对比" class="headerlink" title="与ArrayList的使用对比"></a><strong>与ArrayList的使用对比</strong></h2><p>以下情况使用 ArrayList :</p>
<p>频繁访问列表中的某一个元素。</p>
<p>只需要在列表末尾进行添加和删除元素操作。</p>
<p>以下情况使用 LinkedList :</p>
<p>你需要通过循环迭代来访问列表中的某些元素。</p>
<p>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a><strong>创建</strong></h2><p>LinkList<E> list=new LinkList<E>();</p>
<h2 id="开头添加-移除-获取元素"><a href="#开头添加-移除-获取元素" class="headerlink" title="开头添加/移除/获取元素"></a><strong>开头添加/移除/获取元素</strong></h2><p>list.addFirst(“Wiki”);</p>
<p>list.removeFirst();</p>
<p>list.getFirst();</p>
<h2 id="结尾添加元素"><a href="#结尾添加元素" class="headerlink" title="结尾添加元素"></a><strong>结尾添加元素</strong></h2><p>list.addLast(“hello”);</p>
<p>list.removeLast();</p>
<p>list.getLast();</p>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>
<p>HashSet 允许有 null 值。</p>
<p>HashSet 是无序的，即不会记录插入的顺序。</p>
<p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p>
<p>HashSet 实现了 Set 接口。</p>
<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a><strong>创建</strong></h2><p>HashSet<String> hashset=new HashSet<String>();</p>
<h2 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h2><p>hashset.add(“Google”);</p>
<p>注意，重复的元素不会被添加。</p>
<h2 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a><strong>判断元素是否存在</strong></h2><p>hashset.contains(“TaoBao”);</p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h2><p>hashset.remove(“TaoBao”);</p>
<h2 id="计算大小-1"><a href="#计算大小-1" class="headerlink" title="计算大小"></a><strong>计算大小</strong></h2><p>hashset.size();</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h1><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>
<p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p>
<p>HashMap 是无序的，即不会记录插入的顺序。</p>
<p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p>
<h2 id="新建-2"><a href="#新建-2" class="headerlink" title="新建"></a><strong>新建</strong></h2><p>HashMap&lt;Integer,String&gt; Sites=new HashMap&lt;Integer,String&gt;();</p>
<h2 id="添加元素-2"><a href="#添加元素-2" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h2><p>Sites.put(1,”Google”);</p>
<h2 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h2><p>Sites.get(1);</p>
<p>使用get方法来获取key对应的value</p>
<h2 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h2><p>Sites.remove(1);</p>
<p>使用 remove(key) 方法来删除 key 对应的键值对(key-value)</p>
<p>删除所有键值对可以使用clear方法</p>
<p>Sites.clear();</p>
<h2 id="计算大小-2"><a href="#计算大小-2" class="headerlink" title="计算大小"></a><strong>计算大小</strong></h2><p>Sites.size();</p>
<h2 id="存在key-value"><a href="#存在key-value" class="headerlink" title="存在key/value"></a><strong>存在key/value</strong></h2><p>Sites.containsKey(1);</p>
<p>Sites.containsValue(“Google”);</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代HashMap:如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。</p>
<h2 id="返回或者默认值"><a href="#返回或者默认值" class="headerlink" title="返回或者默认值"></a>返回或者默认值</h2><p>获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值：getOrDefault()</p>
<h1 id="Java-Stack"><a href="#Java-Stack" class="headerlink" title="Java Stack"></a><strong>Java Stack</strong></h1><h2 id="新建-3"><a href="#新建-3" class="headerlink" title="新建"></a><strong>新建</strong></h2><p>Stack<Integer> st=new Stack<Integer>();</p>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p><img src="/images/pasted-210404stack.jpg"></p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>length()</p>
<h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><p>concat()</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>charAt(int index) ：返回指定索引处的 char 值。</p>
<p>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html"> int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p>
<h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">public delete(int start, int end) 移除此序列的子字符串中的字符。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/29/210329jjworldfupan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/210329jjworldfupan/" class="post-title-link" itemprop="url">竞技世界面试复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 19:27:00" itemprop="dateCreated datePublished" datetime="2021-03-29T19:27:00+08:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-01 14:31:51" itemprop="dateModified" datetime="2021-04-01T14:31:51+08:00">2021-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RAM和ROM"><a href="#RAM和ROM" class="headerlink" title="RAM和ROM"></a>RAM和ROM</h1><p>RAM（random access memory）即随机存储内存，这种存储器在断电时将丢失其存储内容，故主要用于存储短时间使用的程序。ROM（Read-Only Memory）即只读内存，是一种只能读出事先所存数据的固态半导体存储器。</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存是操作系统内核为了对进程地址空间进行管理（process address space management）而精心设计的一个逻辑意义上的内存空间概念。</p>
<p>用户编制程序时使用的地址称为<strong>虚地址或逻辑地址</strong>，其对应的存储空间称为虚存空间或逻辑地址空间；而计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。</p>
<p><strong>引入虚拟存储技术的好处</strong>：<br>可在较小的可用内存中执行较大的用户程序；<br>可在内存中容纳更多程序并发执行；<br>不必影响编程时的程序结构（与覆盖技术比较）；</p>
<p>提供给用户可用的虚拟内存空间通常大于物理内存。</p>
<h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><p>理论上<em>SMTP</em>可以通过TCP,UDP或某些第三方协议来处理</p>
<p>DHCP 用的是UDP</p>
<h1 id="数据库主键"><a href="#数据库主键" class="headerlink" title="数据库主键"></a>数据库主键</h1><p><em>主键</em>只有一个,但是可以设置为多个字段为<em>主键</em>,也即联合<em>主键</em>。</p>
<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quicksort(<span class="keyword">int</span> []arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">int</span> start = low;</span><br><span class="line">    <span class="keyword">int</span> end = high;</span><br><span class="line">    <span class="keyword">int</span> key = arr[start];</span><br><span class="line">    <span class="keyword">while</span>(end &gt; start)&#123;</span><br><span class="line">        <span class="keyword">while</span>(end &gt; start&amp;&amp;arr[end]&gt;=key)&#123;</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[end]&lt;=key)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=arr[end];</span><br><span class="line">            arr[end]=arr[start];</span><br><span class="line">            arr[start]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end&gt;start&amp;&amp;arr[start]&lt;=key)&#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[start]&gt;=key)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=arr[start];</span><br><span class="line">            arr[start]=arr[end];</span><br><span class="line">            arr[end]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>使用哈夫曼编码来编码字符串”aaaabbcd”时，得到的编码长度为多少?</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43247186/article/details/87855415">https://blog.csdn.net/weixin_43247186/article/details/87855415</a></p>
<h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><p><em>字节是</em>一个存储单位 1个二进制位等于1Bit 8个Bit等于<em>1Byte</em>(字节)</p>
<p>C语言会自动在在双引号””括起来的内容的末尾补上”\0”代表结束，ASCII中的0号位也占用一个字符。</p>
<p>注意，了解了sizeof的真正含义后。类似如下的代码就很low了。</p>
<h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><p><strong>（数据看成字符串）</strong>大端——高尾端，小端——低尾端</p>
<p>我们的电脑通常是小端存储</p>
<h2 id="大小端各自的优点"><a href="#大小端各自的优点" class="headerlink" title="大小端各自的优点"></a>大小端各自的优点</h2><p>大端：符号位在所表示的内存的低地址，用于快速判断数据的正负和大小<br>小端：CPU做数值运算的时候是从内存中依次从低位到高位取数据进行运算，这样运算效率更高。</p>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>并发是指一个处理器同时处理多个任务。<br>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。<br>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。<br>来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。</p>
<p>当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。</p>
<p>当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]并发并行的区别<a target="_blank" rel="noopener" href="https://blog.csdn.net/java_zero2one/article/details/51477791">https://blog.csdn.net/java_zero2one/article/details/51477791</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/28/Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/28/Git/" class="post-title-link" itemprop="url">Git</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-28 14:11:00" itemprop="dateCreated datePublished" datetime="2021-03-28T14:11:00+08:00">2021-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 21:09:02" itemprop="dateModified" datetime="2021-03-29T21:09:02+08:00">2021-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>学习git之前，我们需要先明白一个概念</p>
<p><strong>版本控制！</strong></p>
<h2 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
<ul>
<li>实现跨区域多人协同开发</li>
<li>追踪和记载一个或者多个文件的历史记录</li>
<li>组织和保护你的源代码和文档</li>
<li>统计工作量</li>
<li>并行开发、提高开发效率</li>
<li>跟踪记录整个软件的开发过程</li>
<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>
</ul>
<p>简单说就是用于管理多人协同开发项目的技术。</p>
<p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p>
<p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0C4qeLxMgoTg9B154ibahsUaibiaV7DgH9GTFQZj3Kyhf5fxrj6G2U5HFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>多人开发就必须要使用版本控制！</p>
<h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><p>我们学习的东西，一定是当下最流行的！</p>
<p>主流的版本控制器有如下这些：</p>
<ul>
<li><strong>Git</strong></li>
<li><strong>SVN</strong>（Subversion）</li>
<li><strong>CVS</strong>（Concurrent Versions System）</li>
<li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li>
<li><strong>TFS</strong>（Team Foundation Server）</li>
<li>Visual Studio Online</li>
</ul>
<p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p>
<h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><h3 id="1、本地版本控制"><a href="#1、本地版本控制" class="headerlink" title="1、本地版本控制"></a><strong>1、本地版本控制</strong></h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Dg3fHrbPqbNEOMO9GTjFhVaukMZWx54icS7eS2x8A7BEu0VB9ibwEhzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="2、集中版本控制-SVN"><a href="#2、集中版本控制-SVN" class="headerlink" title="2、集中版本控制  SVN"></a><strong>2、集中版本控制  SVN</strong></h3><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p>
<h3 id="3、分布式版本控制-Git"><a href="#3、分布式版本控制-Git" class="headerlink" title="3、分布式版本控制     Git"></a><strong>3、分布式版本控制     Git</strong></h3><p>每个人都拥有全部的代码！安全隐患！</p>
<p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>
<p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="Git与SVN的主要区别"><a href="#Git与SVN的主要区别" class="headerlink" title="Git与SVN的主要区别"></a>Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<h1 id="聊一聊Git的历史"><a href="#聊一聊Git的历史" class="headerlink" title="聊一聊Git的历史"></a>聊一聊Git的历史</h1><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p>
<h1 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h1><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p>打开 [git官网] <a target="_blank" rel="noopener" href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p>
<p>所有东西下载慢的话就可以去找镜像！</p>
<p>官网下载太慢，我们可以使用淘宝镜像下载：<a target="_blank" rel="noopener" href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210328143055320.png" alt="image-20210328143055320"></p>
<p>下载对应的版本即可安装！</p>
<p>安装：无脑下一步即可！安装完毕就可以使用了！</p>
<h2 id="启动Git"><a href="#启动Git" class="headerlink" title="启动Git"></a>启动Git</h2><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p>
<p><strong>Git CMD：</strong>Windows风格的命令行</p>
<p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p>
<h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p>
<p>1）、cd : (Change Directory)改变目录。</p>
<p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p>
<p>3）、pwd : (print work directory)显示当前所在的目录路径。</p>
<p>4）、ls(ll):  (list)都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p>
<p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p>
<p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p>
<p>7）、mkdir: (Make Directory) 新建一个目录,就是新建一个文件夹。</p>
<p>8）、rm -r : (Remove Directory) 删除一个文件夹, rm -r src 删除src目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！</span><br></pre></td></tr></table></figure>

<p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p>
<p>10）、reset 重新初始化终端/清屏。</p>
<p>11）、clear 清屏。</p>
<p>12）、history 查看命令历史。</p>
<p>13）、help 帮助。</p>
<p>14）、exit 退出。</p>
<p>15）、#表示注释</p>
<h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>所有的配置文件，其实都保存在本地！</p>
<p>查看配置 git config -l</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>查看不同级别的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看系统config</span><br><span class="line">git config --system --list　　</span><br><span class="line">#查看当前用户（global）配置</span><br><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure>

<p><strong>Git相关的配置文件：</strong></p>
<p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p>
<p>2）、C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p>
<h2 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;名称&quot;  #名称</span><br><span class="line">git config --global user.email 邮箱   #邮箱</span><br></pre></td></tr></table></figure>

<p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p>
<p>可以查看当前用户（global）配置<br>git config –global  –list</p>
<h1 id="Git基本原理"><a href="#Git基本原理" class="headerlink" title="Git基本原理"></a>Git基本原理</h1><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li>Workspace：工作区，就是你平时存放项目代码的地方</li>
<li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>git的工作流程一般是这样的：</p>
<p>１、在工作目录中添加、修改文件；</p>
<p>２、将需要进行版本管理的文件放入暂存区域；</p>
<p>３、将暂存区域的文件提交到git仓库。</p>
<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>
<p>日常使用只要记住下图6个命令：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>
<p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p>
<h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]  </span><br></pre></td></tr></table></figure>

<p>2、去 gitee 或者 github 上克隆一个测试！</p>
<h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li>
<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li>
<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li>
<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>
</ul>
<h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line">#查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"># git add .                  添加所有文件到暂存区# git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>



<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>
<p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p>
<ol>
<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">&#x2F;temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build&#x2F;       #忽略build&#x2F;目录下的所有文件</span><br><span class="line">doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure>

<h2 id="码云的使用"><a href="#码云的使用" class="headerlink" title="码云的使用"></a>码云的使用</h2><p>这个其实可以作为大家未来找工作的一个重要信息！</p>
<p>1、注册登录码云，完善个人信息</p>
<p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入 C:\Users\Administrator\.ssh 目录</span><br><span class="line"># 生成公钥</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、将公钥信息public key 添加到码云账户中即可！</p>
<p>4、使用码云创建一个自己的仓库！</p>
<h1 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h1><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p>
<p>git分支中常用指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line">#远程提交</span><br><span class="line">git push -u origin &lt;你要推送的分支名&gt;</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>

<p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p>
<p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/26/210326datastructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/210326datastructure/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 19:21:00" itemprop="dateCreated datePublished" datetime="2021-03-26T19:21:00+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 21:08:17" itemprop="dateModified" datetime="2021-03-29T21:08:17+08:00">2021-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树查找的时间复杂度"><a href="#二叉树查找的时间复杂度" class="headerlink" title="二叉树查找的时间复杂度"></a>二叉树查找的时间复杂度</h2><p>如果<strong>二叉排序树是平衡</strong>的，则n个节点的二叉排序树的高度为Log2(n+1),其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。</p>
<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printIn(root);</span><br><span class="line">    PreOrder(root.left);</span><br><span class="line">    PreOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Stack&lt;TreeNode&gt; stack =<span class="keyword">new</span> Stack &lt;&gt;();</span><br><span class="line">	stack.push(root);</span><br><span class="line">	<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">		TreeNode node =stack.pop();</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ret.add(node.val);</span><br><span class="line">		stack.push(node.right);<span class="comment">//先右后左，保证左子树先出来</span></span><br><span class="line">		stack.push(node.left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">    visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret.add(node.val);</span><br><span class="line">        stack.push(node.left);</span><br><span class="line">        stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    visit(root);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        ret.add(node.val);</span><br><span class="line">        cur = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/26/210326cjdatabase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/210326cjdatabase/" class="post-title-link" itemprop="url">常见数据结构时间复杂度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 19:18:38" itemprop="dateCreated datePublished" datetime="2021-03-26T19:18:38+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 21:07:48" itemprop="dateModified" datetime="2021-03-29T21:07:48+08:00">2021-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>添加：O(1)</li>
<li>删除：O(n）</li>
<li>修改：O(1)</li>
<li>查询：O(n)</li>
<li>尺寸：O(1)</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>插入：O(1)，如果需要查找再插入则O(n)</li>
<li>删除：O(1)，如果需要查找再删除则O(n)</li>
<li>搜索：O(n)</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>推：O（1）</li>
<li>Pop：O（1）</li>
<li>上：O（1）</li>
<li>搜索（像查找，像一个特殊的操作）：O（n）</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>插入：O（1）</li>
<li>删除：O（1）</li>
<li>尺寸：O（1）</li>
</ul>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul>
<li>查找：O（1）</li>
<li>插入：O（1）</li>
<li>删除：可根据链表输入长度决定，在最坏情况下，链表长度为n，时间复杂度就为O（n）</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><table>
<thead>
<tr>
<th>算法</th>
<th>最佳</th>
<th>平均</th>
<th>最差</th>
<th>最差情况下的空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n*n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n)</td>
<td>O(n*n)</td>
<td>O(n*n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n)</td>
<td>O(n*n)</td>
<td>O(n*n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n*n)</td>
<td>O(n*n)</td>
<td>O(n*n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n*n)</td>
<td>O(nk)</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(nk)</td>
<td>O(nk)</td>
<td>O(nk)</td>
<td>O(n+k)</td>
</tr>
</tbody></table>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><table>
<thead>
<tr>
<th>算法</th>
<th>平均</th>
<th>最差</th>
<th>最差空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>深度优先搜索(DFS)</td>
<td>-</td>
<td>O(E+V)</td>
<td>O(V)</td>
</tr>
<tr>
<td>广度优先搜索(BFS)</td>
<td>-</td>
<td>O(E+V)</td>
<td>O(V)</td>
</tr>
<tr>
<td>二分查找</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/99ae14b48c0f">https://www.jianshu.com/p/99ae14b48c0f</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/24/210324Javabase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/210324Javabase/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 20:22:00" itemprop="dateCreated datePublished" datetime="2021-03-24T20:22:00+08:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 09:16:59" itemprop="dateModified" datetime="2021-03-25T09:16:59+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a><strong>StringBuilder</strong> <strong>和</strong> <strong>StringBuffer</strong></h1><p><strong>StringBuffer</strong> 是线程安全的 <strong>StringBuilder</strong> 是不安全的</p>
<h1 id="Java实现连续空间的内存分配"><a href="#Java实现连续空间的内存分配" class="headerlink" title="Java实现连续空间的内存分配?"></a>Java实现连续空间的内存分配?</h1><p>基本数据类型的数组，存放在栈内存里，连续分配对象数组,在栈内存里的引用是连续分配的，实际数据分配在堆内存，不是连续分配的。</p>
<h1 id="创建对象的方式有哪几种？"><a href="#创建对象的方式有哪几种？" class="headerlink" title="创建对象的方式有哪几种？"></a>创建对象的方式有哪几种？</h1><h1 id="接口和抽象类有什么区别"><a href="#接口和抽象类有什么区别" class="headerlink" title="接口和抽象类有什么区别"></a>接口和抽象类有什么区别</h1><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。</p>
<p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。</p>
<p>人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.</p>
<p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p>
<p>第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。<br>第二点． 接口可以多继承，抽象类不行<br>第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。<br>第四点． 接口中基本数据类型为static 而抽类象不是的。</p>
<p>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>
<h1 id="浅拷贝与深拷贝的区别"><a href="#浅拷贝与深拷贝的区别" class="headerlink" title="浅拷贝与深拷贝的区别"></a>浅拷贝与深拷贝的区别</h1><p><strong>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</strong></p>
<p><strong>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</strong></p>
<p>ps:Java中的拷贝需要实现java.lang.Cloneable接口，然后重写clone()方法，这个无论深、浅拷贝都需要这样做</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><strong>编译时多态</strong><br>方法重载 都是编译时多态。根据实际参数的数据类型、个数和次序，Java 在编译时能够确定执行重载方法中的哪一个。</p>
<p>方法覆盖 表现出两种多态性，当对象引用本类实例时，为编译时多态，否则为运行时多态。</p>
<p><strong>运行时多态</strong><br>通过父类对象引用变量引用子类对象来实现。当父类对象引用子类实例时。通过接口类型变量引用实现接口的类的对象来实现 。运行时多态主要是通过继承和接口实现的。</p>
<h1 id="Java注解的理解"><a href="#Java注解的理解" class="headerlink" title="Java注解的理解"></a>Java注解的理解</h1><p>Java 语言中的类、方法、变量、参数和包等都可以注解标记，程序运行期间我们可以获取到相应的注解以及注解中定义的内容，这样可以帮助我们做一些事情。</p>
<h1 id="Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？"><a href="#Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？" class="headerlink" title="Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？"></a>Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</h1><p>反射介绍：</p>
<p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及 动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<p>反射的优缺点如下：</p>
<ul>
<li><p>优点：运行期类型的判断，动态加载类，提高代码灵活度。</p>
</li>
<li><p>缺点：</p>
</li>
</ul>
<ol>
<li><p>性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。</p>
</li>
<li><p>安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</p>
</li>
</ol>
<h1 id="为什么框架需要反射技术"><a href="#为什么框架需要反射技术" class="headerlink" title="为什么框架需要反射技术"></a>为什么框架需要反射技术</h1><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机 制没有用，实际上有很多设计、开发都与反射机制有关。动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>我们在使用 JDBC 连接数据库时使用 Class.forName() 通过反射加载数据库的驱动程序；<br>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；<br>动态配置实例的属性；</p>
<h1 id="获取Class对象的两种方式"><a href="#获取Class对象的两种方式" class="headerlink" title="获取Class对象的两种方式"></a>获取Class对象的两种方式</h1><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了两种方式获取 Class 对象:</p>
<p>知道具体类的情况下可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;      </span><br></pre></td></tr></table></figure>


<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象</p>
<p>通过 Class.forName() 传入类的路径获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>); </span><br></pre></td></tr></table></figure>

<h1 id="内存泄露和内存溢出的场景"><a href="#内存泄露和内存溢出的场景" class="headerlink" title="内存泄露和内存溢出的场景"></a>内存泄露和内存溢出的场景</h1><p>内存泄漏：内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不 到及时释放，从而造成内存空间的浪费称为内存泄漏。</p>
<p>Java 内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。</p>
<p>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生 于 OLD 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况。</p>
<p>内存溢出场景：</p>
<ul>
<li>JVM Heap（堆）溢出：OutOfMemoryError: Java heap space： 发生这种问题的原因是 java 虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已 经用满了。JVM 在启动的时候会自动设置 JVM Heap 的值， 可以利用 JVM 提供的-Xmn -Xms -Xmx 等选项可进行设置。Heap的大小是新生代和老年代之和。</li>
</ul>
<p>解决方法：</p>
<ol>
<li><p>手动设置 JVM Heap（堆）的大小。</p>
</li>
<li><p>检查程序，看是否有死循环或不必要地重复创建大量对象。</p>
</li>
</ol>
<ul>
<li>Metaspace溢出：java.lang.OutOfMemoryError: Metaspace 程序中使用了大量的 jar 或 class，使 java 虚拟机装载类的空间不够，与 metaspace 大小有关。方法区用于存放 Java 类型的相关信息。在类装载器加载 class 文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的 内存占用又已经达到 -XX:MaxMetaspaceSize 设置的最大值，将会抛出 OutOfMemoryError 异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</li>
</ul>
<p>解决方法:</p>
<ol>
<li>通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。</li>
</ol>
<ul>
<li>栈溢出： java.lang.StackOverflowError : Thread Stack space：线程的方法嵌套调用层次太多(如递归调用)，以致于把栈区溢出了。</li>
</ul>
<p>解决方法：</p>
<ol>
<li>修改程序。</li>
<li>通过 -Xss: 来设置每个线程的 Stack 大小即可。</li>
</ol>
<h1 id="强引用，弱引用，软引用，虚引用"><a href="#强引用，弱引用，软引用，虚引用" class="headerlink" title="强引用，弱引用，软引用，虚引用"></a>强引用，弱引用，软引用，虚引用</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>大部分引用实际上都是，最普遍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">String str = <span class="string">&quot;StrongReference&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个对象具有强引用，那就类似于<strong>必不可少的</strong>物品，不会被垃圾回收器回收。<strong>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</strong></p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是用来描述一些<strong>有用但并不是必需</strong>的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。<br>软引用在实际中有重要的应用，例如浏览器的后退按钮，这个后退时显示的网页内容可以重新进行请求或者从缓存中取出：</p>
<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p>
<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出这时候就可以使用软引用</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用也是用来描述<strong>非必需对象</strong>的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<u>所以被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</u></p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用和前面的软引用、弱引用不同，它并<strong>不影响对象的生命周期</strong>。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，<strong>在任何时候都可能被垃圾回收器回收</strong>。虚引用主要用来跟踪对象被垃圾回收的活动。</p>
<p><strong>虚引用必须和引用队列关联使用</strong>，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>引用类型</th>
<th>被回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时</td>
<td>对象缓存</td>
<td>内存不足时</td>
</tr>
<tr>
<td>弱引用</td>
<td>jvm垃圾回收时</td>
<td>对象缓存</td>
<td>gc运行后</td>
</tr>
<tr>
<td>虚引用</td>
<td>未知</td>
<td>未知</td>
<td>未知</td>
</tr>
</tbody></table>
<h1 id="讲一下-Java-的-BIO-NIO-AIO"><a href="#讲一下-Java-的-BIO-NIO-AIO" class="headerlink" title="讲一下 Java 的 BIO,NIO,AIO?"></a>讲一下 Java 的 BIO,NIO,AIO?</h1><h2 id="BIO-Blocking-I-O-："><a href="#BIO-Blocking-I-O-：" class="headerlink" title="BIO (Blocking I/O)："></a>BIO (Blocking I/O)：</h2><p>同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<h2 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O):"></a>NIO (Non-blocking/New I/O):</h2><p>NIO 是一种同步非阻塞的 I/O 模型，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。Java NIO使我们可以进行非阻塞IO操作。比如说， 单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后， 线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一 些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。JDK 的 NIO 底层由 epoll 实现。</p>
<p>通常来说 NIO 中的所有 IO 都是从 Channel（通道） 开始的。</p>
<p>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</p>
<p>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</p>
<h2 id="AIO-Asynchronous-I-O-："><a href="#AIO-Asynchronous-I-O-：" class="headerlink" title="AIO (Asynchronous I/O)："></a>AIO (Asynchronous I/O)：</h2><p>异步非阻塞IO模型，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的 线程进行后续的操作。AIO 的应用还不是很广泛。</p>
<h1 id="Java中finalize-方法的使用"><a href="#Java中finalize-方法的使用" class="headerlink" title="Java中finalize()方法的使用"></a>Java中finalize()方法的使用</h1><p>finalize()是 Object的protected 方法，子类可以覆盖该方法以实现资源清理工作，GC 在回收对象之前调用该方法。</p>
<p><strong>finalize()方法中一般用于释放非 Java 资源（如打开的文件资源、数据库连接等），或是调用非Java方法（native方法）时分配的内存（比如 C 语言的 malloc()系列函数）。</strong></p>
<p>避免使用的原因：</p>
<p>首先，由于 finalize()方法的调用时机具有不确定性，从一个对象变得不可到达开始，到 finalize()方法被执行，所花费的时间这段时间是任意长的。我们并不能依赖 finalize()方法能 及时的回收占用的资源，可能出现的情况是在我们耗尽资源之前，gc 却仍未触发，因而通常的做法是提供显示的 close()方法供客户端手动调用。另外，重写 finalize()方法意味着延长了回收对象时需要进行更多的操作，从而延长了对象回收的时间。</p>
<h1 id="什么是GC-Root"><a href="#什么是GC-Root" class="headerlink" title="什么是GC Root"></a>什么是GC Root</h1><p>首先我们知道标记算法，JVM的标记算法我们可以了解为一个可达性算法，所以所有的可达性算法都会有起点，那么这个起点就是GC Root。也就是需要通过GC Root 找出所有活的对象，那么剩下所有的没有标记的对象就是需要回收的对象。</p>
<h2 id="GC-Root的对象"><a href="#GC-Root的对象" class="headerlink" title="GC Root的对象"></a>GC Root的对象</h2><ul>
<li>方法区中的静态变量和常量引用的对象</li>
<li>虚拟机栈中引用对象</li>
<li>本地方法栈中引用对象</li>
</ul>
<h1 id="单例模型"><a href="#单例模型" class="headerlink" title="单例模型"></a>单例模型</h1><p>下述内容来源于<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/singleton-pattern.html">菜鸟教程</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1、懒汉式，线程不安全</span></span><br><span class="line"><span class="comment">是否 Lazy 初始化：是</span></span><br><span class="line"><span class="comment">是否多线程安全：否</span></span><br><span class="line"><span class="comment">实现难度：易</span></span><br><span class="line"><span class="comment">描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span></span><br><span class="line"><span class="comment">这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2、懒汉式，线程安全</span></span><br><span class="line"><span class="comment">是否 Lazy 初始化：是</span></span><br><span class="line"><span class="comment">是否多线程安全：是</span></span><br><span class="line"><span class="comment">实现难度：易</span></span><br><span class="line"><span class="comment">描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</span></span><br><span class="line"><span class="comment">优点：第一次调用才初始化，避免内存浪费。</span></span><br><span class="line"><span class="comment">缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</span></span><br><span class="line"><span class="comment">getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3、饿汉式</span></span><br><span class="line"><span class="comment">是否 Lazy 初始化：否</span></span><br><span class="line"><span class="comment">是否多线程安全：是</span></span><br><span class="line"><span class="comment">实现难度：易</span></span><br><span class="line"><span class="comment">描述：这种方式比较常用，但容易产生垃圾对象。</span></span><br><span class="line"><span class="comment">优点：没有加锁，执行效率会提高。</span></span><br><span class="line"><span class="comment">缺点：类加载时就初始化，浪费内存。</span></span><br><span class="line"><span class="comment">它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4、双检锁/双重校验锁（DCL，即 double-checked locking）</span></span><br><span class="line"><span class="comment">JDK 版本：JDK1.5 起</span></span><br><span class="line"><span class="comment">是否 Lazy 初始化：是</span></span><br><span class="line"><span class="comment">是否多线程安全：是</span></span><br><span class="line"><span class="comment">实现难度：较复杂</span></span><br><span class="line"><span class="comment">描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</span></span><br><span class="line"><span class="comment">getInstance() 的性能对应用程序很关键。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5、登记式/静态内部类</span></span><br><span class="line"><span class="comment">是否 Lazy 初始化：是</span></span><br><span class="line"><span class="comment">是否多线程安全：是</span></span><br><span class="line"><span class="comment">实现难度：一般</span></span><br><span class="line"><span class="comment">描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</span></span><br><span class="line"><span class="comment">这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6、枚举</span></span><br><span class="line"><span class="comment">JDK 版本：JDK1.5 起</span></span><br><span class="line"><span class="comment">是否 Lazy 初始化：否</span></span><br><span class="line"><span class="comment">是否多线程安全：是</span></span><br><span class="line"><span class="comment">实现难度：易</span></span><br><span class="line"><span class="comment">描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</span></span><br><span class="line"><span class="comment">这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</span></span><br><span class="line"><span class="comment">不能通过 reflection attack 来调用私有构造方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;       </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Java中-gt-gt-和-gt-gt-gt-的区别"><a href="#Java中-gt-gt-和-gt-gt-gt-的区别" class="headerlink" title="Java中&gt;&gt;和&gt;&gt;&gt;的区别"></a>Java中&gt;&gt;和&gt;&gt;&gt;的区别</h1><p>Java 中的位运算符：</p>
<p>‘&gt;&gt;’表示带符号右移，如：int i=15; i&gt;&gt;2 的结果是 3，移出的部分将被抛弃。<br>转为二进制的形式可能更好理解，0000 1111(15)右移 2 位的结果是 0000 0011(3)，0001 1010(18)右移 3 位的结果是 0000 0011(3)。</p>
<p>‘&gt;&gt;&gt;’无符号右移：<br>按二进制形式把所有的数字向右移动对应巍峨位数，低位移出（舍弃），高位的空位补零。对于正数来说和带符号右移相同，对于负数来说不同。<br>其他结构和&gt;&gt;相似。</p>
<h1 id="讲一下volatile关键字的作用"><a href="#讲一下volatile关键字的作用" class="headerlink" title="讲一下volatile关键字的作用"></a>讲一下volatile关键字的作用</h1><p>volatile可以保证可见性，有序性，但不能保证原子性.</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a><strong>可见性</strong></h2><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</strong></p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a><strong>有序性</strong></h2><p>有序性即程序执行的顺序按照代码的先后顺序执行</p>
<h1 id="synchronized-作用，讲一讲底层实现"><a href="#synchronized-作用，讲一讲底层实现" class="headerlink" title="synchronized 作用，讲一讲底层实现"></a>synchronized 作用，讲一讲底层实现</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h2><p><strong>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong></p>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。但是像i++、i+=1等操作字符就不是原子性的，它们是分成<strong>读取、计算、赋值</strong>几步操作，原值在这些步骤还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。</p>
<p>被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。</p>
<p><strong>注意！面试时经常会问比较synchronized和volatile，它们俩特性上最大的区别就在于原子性，volatile不具备原子性。</strong></p>
<h2 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h2><p><strong>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</strong></p>
<p>synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</p>
<p>而volatile的实现类似，被volatile修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性。</p>
<h2 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h2><p><strong>有序性值程序执行的顺序按照代码先后执行。</strong></p>
<p>synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</p>
<h2 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h2><p>synchronized和ReentrantLock都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</p>
<h1 id="说说-synchronized关键字和-volatile关键字的区别"><a href="#说说-synchronized关键字和-volatile关键字的区别" class="headerlink" title="说说 synchronized关键字和 volatile关键字的区别"></a>说说 synchronized关键字和 volatile关键字的区别</h1><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键 字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代 码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁 带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提 升，实际开发中使用 synchronized 关键字的场景还是更多一些。</p>
<p>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字 两者都能保证。</p>
<p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39192827/article/details/85611873">https://blog.csdn.net/qq_39192827/article/details/85611873</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9d573539022c">深入理解synchronized底层原理，一篇文章就够了！</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/24/210324datasstructure%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/210324datasstructure%20/" class="post-title-link" itemprop="url">数据结构面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 20:17:00" itemprop="dateCreated datePublished" datetime="2021-03-24T20:17:00+08:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-10 15:04:39" itemprop="dateModified" datetime="2021-04-10T15:04:39+08:00">2021-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>性质 1：节点非红即黑。</p>
<p>性质 2：根节点永远是黑色的。</p>
<p>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</p>
<p>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p>
<p>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>
<p>红黑树最重要的性质：从根到叶子的最长的可能路径小于等于最短的可能路径的两倍长。 红黑树并不是真正意义上的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。(对于AVL树，任何一个节点的两个子树高度差不会超过 1；对于红黑树，则是不会相差两倍以上)对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。对于红黑树，插入，删除，查找的复杂度都是 O(log N)。任何不平衡都会在3次旋转之内解决。</p>
<h2 id="红黑树插入问题"><a href="#红黑树插入问题" class="headerlink" title="红黑树插入问题"></a>红黑树插入问题</h2><p>假设我们插入的新节点为 X</p>
<ol>
<li>将新插入的节点标记为红色</li>
<li>如果 X 是根结点(root)，则标记为黑色</li>
<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>
</ol>
<ul>
<li><p>3.1 如果 X 的 uncle (叔叔) 是红色</p>
</li>
<li><ul>
<li>3.1.1 将 parent 和 uncle 标记为黑色</li>
<li>3.1.2 将 grand parent (祖父) 标记为红色</li>
<li>3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li>
</ul>
</li>
</ul>
<p>话不多说，看下图</p>
<p><img src="https://pic4.zhimg.com/80/v2-1d35b926316397d82c267593042f8c3f_720w.jpg" alt="img"></p>
<p>跟着上面的公式走:</p>
<ol>
<li>将新插入的 X 节点标记为红色</li>
<li>发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」</li>
<li>发现 X 的 uncle (U) 同样为红色</li>
<li>将 P 和 U 标记为黑色</li>
<li>将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3</li>
<li>发现 G 是根结点，标记为黑色</li>
<li>结束</li>
</ol>
<p>刚刚说了 X 的 uncle 是红色的情况，接下来要说是<strong>黑色</strong>的情况</p>
<ol>
<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>
</ol>
<ul>
<li><p>3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理</p>
</li>
<li><ul>
<li>3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)</li>
<li>3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)</li>
<li>3.2.3 右右 (和 3.2.1 镜像过来，恰好相反)</li>
<li>3.2.4 右左 (和 3.2.2 镜像过来，恰好相 【】【反)</li>
</ul>
</li>
</ul>
<p>当出现 uncle 是黑色的时候我们第一步要考虑的是 <strong>旋转</strong> ，这里先请小伙伴<strong>不要关注红黑树的第 4 条规则</strong>，主要是为了演示如何旋转的，来一点点看，不要看图就慌，有解释的 :</p>
<p><img src="https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg" alt="img"></p>
<h3 id="左左"><a href="#左左" class="headerlink" title="左左"></a>左左</h3><p>这种情况很简单，想象这是一根绳子，手提起 P 节点，然后变色即可</p>
<p><img src="https://pic1.zhimg.com/80/v2-9e139a0f8b4a5e00ca8e643e2130403c_720w.jpg" alt="img"></p>
<h3 id="左右"><a href="#左右" class="headerlink" title="左右"></a>左右</h3><p>左旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的左孩子，然后再应用 <strong>左左情况</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-3fb33fbb3a42e34ed8a058a047a44cc3_720w.jpg" alt="img"></p>
<h3 id="右右"><a href="#右右" class="headerlink" title="右右"></a>右右</h3><p>与左左情况一样，想象成一根绳子</p>
<p><img src="https://pic4.zhimg.com/80/v2-62a42ada09cb4547191aa4b9051c7c23_720w.jpg" alt="img"></p>
<h3 id="右左"><a href="#右左" class="headerlink" title="右左"></a>右左</h3><p>右旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的右孩子，然后再应用 <strong>右右情况</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg" alt="img"></p>
<h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h1><p>ArrayList扩容发生在add()方法调用的时候，下面是add()方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//扩容</span></span><br><span class="line"> ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">//Increments modCount!!</span></span><br><span class="line"> elementData[size++] = e; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line"> &#125;         </span><br></pre></td></tr></table></figure>

<p>ArrayList扩容的关键方法grow():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到ArrayList中elementData数组的内存空间长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容至原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//若预设值大于默认的最大值检查是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间</span></span><br><span class="line">    <span class="comment">// 并将elementData的数据复制到新的内存空间</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;          </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="HashMap-的底层实现、JDK-1-8-的时候为啥将链表转换成红黑树？HashMap-的负载因子"><a href="#HashMap-的底层实现、JDK-1-8-的时候为啥将链表转换成红黑树？HashMap-的负载因子" class="headerlink" title="HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子"></a>HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子</h1><p>HashMap是用<strong>数组+链表+红黑树</strong>进行实现的，当添加一个元素（key-value）时，就首先计 算元素key的hash值，并根据hash值来确定插入数组中的位置，但是可能存在其他元素已经 被放在数组同一位置了，这个时候便使用链表来解决哈希冲突，当链表长度太长的时候，便 将链表转换为红黑树来提高搜索的效率。</p>
<p>HashMap是基于拉链法实现的一个散列表，内部由数组和链表和红黑树实现。</p>
<ol>
<li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。</li>
<li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造传入。</li>
<li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（&gt;=8）， 会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（&lt;=6），又会将红黑树转换回单向链表提高性能，这里是一个平衡点。</li>
</ol>
<h1 id="有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？-线程安全的集合类"><a href="#有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？-线程安全的集合类" class="headerlink" title="有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？ 线程安全的集合类."></a>有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？ 线程安全的集合类.</h1><p>Vector Stack Hashtable</p>
<p>java.util.concurrent包下所有的集合类（ConcurrentHashMap，CopyOnWriteArrayList和CopyOnWriteArraySet等）</p>
<h1 id="HashMap-多线程操作导致死循环问题异常"><a href="#HashMap-多线程操作导致死循环问题异常" class="headerlink" title="HashMap 多线程操作导致死循环问题异常"></a>HashMap 多线程操作导致死循环问题异常</h1><p>主要原因在于并发下的 rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/24/210324weiyunsuan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/210324weiyunsuan/" class="post-title-link" itemprop="url">位运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-24 14:14:00 / 修改时间：16:54:11" itemprop="dateCreated datePublished" datetime="2021-03-24T14:14:00+08:00">2021-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>0s 表示一串 0，1s 表示一串 1。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x ^ 0s = x      x &amp; 0s = 0      x | 0s = x</span><br><span class="line">x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s</span><br><span class="line">x ^ x = 0       x &amp; x = x       x | x = x</span><br></pre></td></tr></table></figure>

<p>利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1^1^2 = 2</span><br></pre></td></tr></table></figure>

<p>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01011011 &amp;</span><br><span class="line">00111100</span><br><span class="line">--------</span><br><span class="line">00011000</span><br></pre></td></tr></table></figure>

<p>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01011011 |</span><br><span class="line">00111100</span><br><span class="line">--------</span><br><span class="line">01111111</span><br></pre></td></tr></table></figure>

<p><strong>位与运算技巧</strong></p>
<p>n&amp;(n-1) 去除 n 的位级表示中<strong>最低</strong>的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01011011 &amp;</span><br><span class="line">01011010</span><br><span class="line">--------</span><br><span class="line">01011010</span><br></pre></td></tr></table></figure>

<p>n&amp;(-n) 得到 n 的位级表示中<strong>最低</strong>的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10110100 &amp;</span><br><span class="line">01001100</span><br><span class="line">--------</span><br><span class="line">00000100</span><br></pre></td></tr></table></figure>

<p>n-(n&amp;(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&amp;(n-1) 效果一样。</p>
<p><strong>移位运算</strong></p>
<p>&gt;&gt; n 为算术右移，相当于除以 2n，例如 -7 &gt;&gt; 2 = -2。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111001  &gt;&gt; 2</span><br><span class="line">--------</span><br><span class="line">11111111111111111111111111111110</span><br></pre></td></tr></table></figure>

<p>&gt;&gt;&gt; n 为无符号右移，左边会补上 0。例如 -7 &gt;&gt;&gt; 2 = 1073741822。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111001  &gt;&gt;&gt; 2</span><br><span class="line">--------</span><br><span class="line">00111111111111111111111111111111</span><br></pre></td></tr></table></figure>

<p>&lt;&lt; n 为算术左移，相当于乘以 2n。-7 &lt;&lt; 2 = -28。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111001  &lt;&lt; 2</span><br><span class="line">--------</span><br><span class="line">11111111111111111111111111100100</span><br></pre></td></tr></table></figure>

<p><strong>mask 计算</strong></p>
<p>要获取 111111111，将 0 取反即可，~0。</p>
<p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p>
<p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111。</p>
<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p>
<p><strong>Java 中的位操作</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int Integer.bitCount();           // 统计 1 的数量</span><br><span class="line">static int Integer.highestOneBit();      // 获得最高位</span><br><span class="line">static String toBinaryString(int i);     // 转换为二进制表示的字符串</span><br></pre></td></tr></table></figure>

<h1 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">461.汉明距离</a></p>
<p>两个整数之间的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> z=x^y;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(z!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((z&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            z=z &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:采取异或的方法看有哪几位是不同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> z=x^y;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(z!=<span class="number">0</span>)&#123;</span><br><span class="line">            z&amp;=(z-<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ps：通过z&amp;(z-1)来清除最低位的1。</p>
<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136.只出现一次的数字</a></p>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            ret=ret^num;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="只出现一次的数字III"><a href="#只出现一次的数字III" class="headerlink" title="只出现一次的数字III"></a>只出现一次的数字III</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-iii/">260.只出现一次的数字III</a></p>
<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> div=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            div^=num;</span><br><span class="line">        &#125;</span><br><span class="line">        div&amp;=-div;</span><br><span class="line">        <span class="keyword">int</span>[] ans=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((div&amp;num)==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[<span class="number">0</span>]=ans[<span class="number">0</span>]^num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[<span class="number">1</span>]=ans[<span class="number">1</span>]^num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps：通过z&amp;(-z)获得中<strong>最低</strong>的那一位</p>
<h1 id="丢失的数字"><a href="#丢失的数字" class="headerlink" title="丢失的数字"></a>丢失的数字</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/">268.丢失的数字</a></p>
<p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> target=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.length ;i++ ) &#123;</span><br><span class="line">            target=target^i^nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:采用的就是x^x=0的思想</p>
<h1 id="颠倒二进制位"><a href="#颠倒二进制位" class="headerlink" title="颠倒二进制位"></a>颠倒二进制位</h1><p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            ret=ret&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            ret |=(n&amp;<span class="number">1</span>);</span><br><span class="line">            n=n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:借助n&amp;1是最后一位，然后进行操作。</p>
<h1 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h1><p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-two/">231. 2的幂</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; (n&amp;(n-<span class="number">1</span>))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:使用n&amp;(n-1)为去除最低的1。</p>
<h1 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h1><p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ret=<span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">            ret[i]=ret[i&amp;(i-<span class="number">1</span>)]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:还是采用了i&amp;(i-1)为最低位的1思想。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/24/210324javaList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/210324javaList/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-24 13:36:00 / 修改时间：19:59:37" itemprop="dateCreated datePublished" datetime="2021-03-24T13:36:00+08:00">2021-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2.两数相加</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    	ListNode head=<span class="keyword">null</span>;</span><br><span class="line">    	ListNode temp=<span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    		<span class="keyword">int</span> n1 = l1!=<span class="keyword">null</span> ? l1.val: <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2!=<span class="keyword">null</span> ? l2.val: <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = n1 + n2 + flag;</span><br><span class="line">    		<span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">    			head=temp=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			temp.next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">    			temp=temp.next;</span><br><span class="line">    		&#125;</span><br><span class="line">    		flag=sum/<span class="number">10</span>;</span><br><span class="line">    		</span><br><span class="line">    		<span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    			l1=l1.next;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    			l2=l2.next;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(flag&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    		temp.next=<span class="keyword">new</span> ListNode(flag);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:注意空指针问题！</p>
<h1 id="找出两个链表的交点"><a href="#找出两个链表的交点" class="headerlink" title="找出两个链表的交点"></a>找出两个链表的交点</h1><p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode l1=headA;</span><br><span class="line">        ListNode l2=headB;</span><br><span class="line">        <span class="keyword">while</span>(l1!=l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">                l1=headB;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                l2=headA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></p>
<p>反转一个单链表。</p>
<p><img src="https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        ListNode cur=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp=pre.next;</span><br><span class="line">            pre.next=cur;</span><br><span class="line">            cur=pre;</span><br><span class="line">            pre=temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur=reverseList(head.next);</span><br><span class="line">        head.next.next=head;</span><br><span class="line">        head.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode nhead =<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode temp=nhead;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">                temp.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp.next=l2;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="porridgechou"
      src="/images/clx.jpg">
  <p class="site-author-name" itemprop="name">porridgechou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">porridgechou</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
