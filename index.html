<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Mynote">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Mynote">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="porridgechou">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mynote</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mynote</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/30/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/30/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99-1/" class="post-title-link" itemprop="url">常用网站</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-30 17:11:00 / 修改时间：17:11:54" itemprop="dateCreated datePublished" datetime="2021-11-30T17:11:00+08:00">2021-11-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/spring_mvc/">Spring MVC框架入门教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/24/meituanmianjing210524/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/24/meituanmianjing210524/" class="post-title-link" itemprop="url">美团面经准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-24 08:31:00 / 修改时间：08:32:29" itemprop="dateCreated datePublished" datetime="2021-05-24T08:31:00+08:00">2021-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><p>含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p>
<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p>
<p>下面比较一下两者的语法区别：</p>
<ol>
<li><p>抽象类可以有构造方法，接口中不能有构造方法。</p>
</li>
<li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
</li>
<li><p>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
</li>
<li><p>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</p>
</li>
<li><p>抽象类中可以包含静态方法，接口中不能包含静态方法</p>
</li>
<li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</p>
</li>
<li><p>一个类可以实现多个接口，但只能继承一个抽象类。</p>
</li>
</ol>
<p>具体参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41933748/article/details/82670072">抽象类和接口的区别（面试题）</a></p>
<h1 id="为什么volatile-可以保证可见性-但不能保证原子性"><a href="#为什么volatile-可以保证可见性-但不能保证原子性" class="headerlink" title="为什么volatile 可以保证可见性,但不能保证原子性"></a>为什么volatile 可以保证可见性,但不能保证原子性</h1><h2 id="保证可见性："><a href="#保证可见性：" class="headerlink" title="保证可见性："></a>保证可见性：</h2><p>内存屏障（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Memory_barrier">memory barrier</a>） 是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障， 相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会 把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p>
<p>内存屏障和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在<strong>写操作后</strong>插入一个写屏障 指令，在<strong>读操作前</strong>插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将 会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。 </p>
<p>明白了内存屏障这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但<strong>中间的几步（从Load到Store）</strong>是不安全的，中间如果其他的CPU修改了值将会丢失。</p>
<p>所以volatile不能保证i++操作的原子性</p>
<h2 id="不能保证原子性："><a href="#不能保证原子性：" class="headerlink" title="不能保证原子性："></a>不能保证原子性：</h2><p>当需要使用被volatile修饰的变量时，线程会从主内存中重新获取该变量的值，但当该线程修改完该变量的值写入主内存的时候，并没有判断主内存内该变量是否已经变化，故可能出现非预期的结果。如主内存内有被volatile修饰变量 a，值为3，某线程使用该变量时，重新从主存内读取该变量的值，为3，然后对其进行+1操作，此时该线程内a变量的副本值为4。但此时该线程的时间片时间到了，等该线程再次获得时间片的时候，主存内a的值已经是另外的值，如5，但是该线程并不知道，该线程继续完成其未完成的工作，将线程内的a副本的值4写入主存，这时，主存内a的值就是4了。这样，之前修改a的值为5的操作就相当于没有发生了，a的值出现了意料之外的结果。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32534441/article/details/88596268">volatile 可以保证可见性，但不能保证原子性</a></p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35583772/article/details/90167214">从原始到最新的垃圾回收器</a></p>
<h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><h2 id="1-集合类的作用"><a href="#1-集合类的作用" class="headerlink" title="(1).集合类的作用"></a><strong>(1).集合类的作用</strong></h2><p>集合类也叫做容器类，和数组一样，用于存储数据，但数组类型单一，并且长度固定，限制性很大，而集合类可以动态增加长度。</p>
<p>集合存储的元素都是对象(引用地址)，所以集合可以存储不同的数据类型，但如果是需要比较元素来排序的集合，则需要类型一致。</p>
<p>集合中提供了统一的增删改查方法，使用方便。</p>
<p>支持泛型，避免数据不一致和转换异常，还对常用的数据结构进行了封装。</p>
<p>所有的集合类的都在java.util包下。</p>
<h2 id="2-集合框架体系的组成"><a href="#2-集合框架体系的组成" class="headerlink" title="(2)集合框架体系的组成"></a><strong>(2)集合框架体系的组成</strong></h2><p>集合框架体系是由Collection、Map(映射关系)和Iterator(迭代器)组成，各部分的作用如下所示。</p>
<h3 id="1-Collection体系中有三种集合：Set、List、Queue"><a href="#1-Collection体系中有三种集合：Set、List、Queue" class="headerlink" title="[1]Collection体系中有三种集合：Set、List、Queue"></a><strong>[1]Collection体系中有三种集合：Set、List、Queue</strong></h3><p> Set(集)： 元素是无序的且不可重复。</p>
<p> List(列表)：元素是有序的且可重复。</p>
<p> Queue(队列)：封装了数据结构中的队列。</p>
<h3 id="2-Map体系"><a href="#2-Map体系" class="headerlink" title="[2]Map体系"></a><strong>[2]Map体系</strong></h3><p> Map用于保存具有映射关系的数据，即key-value(键值对)。Map集合的key是唯一的，不可重复，而value可以重复。所以一个value可以对应多个key。</p>
<p> Map体系除了常用类之外，还有Properties（属性类）也属于Map体系。</p>
<h3 id="3-Iterator-迭代器"><a href="#3-Iterator-迭代器" class="headerlink" title="[3]Iterator(迭代器)"></a><strong>[3]Iterator(迭代器)</strong></h3><p>请查看上面! </p>
<h1 id="hashmap的hash函数"><a href="#hashmap的hash函数" class="headerlink" title="hashmap的hash函数"></a>hashmap的hash函数</h1><p>hash() 方法对 hashCode 分别无符号右移 （&gt;&gt;&gt;） 7 位和 4 位，再与自身进行异或（^）处理。</p>
<p>推荐看一下：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q5706503/article/details/85114159">深入理解 hashcode() 和 HashMap 中的hash 算法</a></p>
<h1 id="BIO与NIO、AIO的区别"><a href="#BIO与NIO、AIO的区别" class="headerlink" title="BIO与NIO、AIO的区别"></a>BIO与NIO、AIO的区别</h1><p>Java对BIO、NIO、AIO的支持：</p>
<ul>
<li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
<li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li>
<li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li>
</ul>
<p>BIO、NIO、AIO适用场景分析:</p>
<ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h1 id="JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰"><a href="#JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰" class="headerlink" title="JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰"></a>JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tianjindong0804/article/details/81710268">JDK8之前，匿名内部类访问的局部变量为什么必须要用final修饰</a></p>
<h1 id="cookie和session常见面试题"><a href="#cookie和session常见面试题" class="headerlink" title="cookie和session常见面试题"></a>cookie和session常见面试题</h1><p>1、cookie和session原理及区别   </p>
<p>cookie采用的是客户端的会话状态的一种储存机制。它是服务器在本地机器上存储的小段文本或者是内存中的一段数据，并随每一个请求发送至同一个服务器。</p>
<p>session是一种服务器端的信息管理机制，它把这些文件信息以文件的形式存放在服务器的硬盘空间上（这是默认情况，可以用memcache把这种数据放到内存里面）当客户端向服务器发出请求时，要求服务器端产生一个session时，服务器端会先检查一下，客户端的cookie里面有没有session_id，是否过期。如果有这样的session_id的话，服务器端会根据cookie里的session_id把服务器的session检索出来。如果没有这样的session_id的话，服务器端会重新建立一个。PHPSESSID是一串加了密的字符串，它的生成按照一定的规则来执行。同一客户端启动二次session_start的话，session_id是不一样的。 </p>
<p>区别：Cookie保存在客户端浏览器中，而Session保存在服务器上。Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>
<hr>
<p>2、  session产生的session_id放在cookie里面，如果用户把cookie禁止掉，是不是session也不能用了呢？</p>
<p>禁止掉cookie后，session当然可以用，不过通过其他的方式来获得这个sessionid，比如，可以跟在url的后面，或者以表单的形势提交到服务器端。从而使服务器端了解客户端的状态。</p>
<hr>
<p>3、  为什么说session 比cookie更安全？</p>
<p>真正的cookie存在于客户端硬盘上的一个文本文件，如果两者一样的话，只要cookie就好了，让客户端来分提服务器的负担，并且对于用户来说又是透明的。但实际上不是。</p>
<p>session的sessionID是放在cookie里，要想功破session的话，得分两步：</p>
<p>第一要得到sessionID。攻破cookie后，你要得到sessionID,sessionID是要有人登录，或者启动session_start才会有，你不知道什么时候会有人登录。</p>
<p>第二取有效sessionID。sessionID是加密的，第二次session_start的时候，前一次的sessionID就没有用了，session过期时sessionid也会失效，想在短时间内功破加了密的 sessionID很难。session是针对某一次通信而言，会话结束session也就随着消失了。<br>使session失效的方法：<br>1.关闭tomcat  2.重启web应用  3.session时间到  4.无效的session</p>
<hr>
<p>cookie和session的区别：</p>
<p>①存在的位置：</p>
<p>cookie 存在于客户端，临时文件夹中；  session存在于服务器的内存中，一个session域对象为一个用户浏览器服务</p>
<p>②安全性<br>cookie是以明文的方式存放在客户端的，安全性低，可以通过一个加密算法进行加密后存放；  session存放于服务器的内存中，所以安全性好</p>
<p>③网络传输量<br>cookie会传递消息给服务器；  session本身存放于服务器，不会有传送流量</p>
<p>④生命周期(以20分钟为例)<br>cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束；<br>session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁。但是，如果在20分钟内（如在第19分钟时）访问过session，那么，将重新计算session的生命周期。关机会造成session生命周期的结束，但是对cookie没有影响</p>
<p>⑤访问范围<br>cookie为多个用户浏览器共享；  session为一个用户浏览器独享<br>————————————————<br>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuhuagu_wuhuaguo/article/details/78552633">cookie和session常见面试题</a></p>
<h1 id="Java匿名内部类"><a href="#Java匿名内部类" class="headerlink" title="Java匿名内部类"></a>Java匿名内部类</h1><p>具体参考：</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhenzhidu/p/anonymous.html">JAVA匿名内部类(Anonymous Classes)</a></p>
<h1 id="post能不能把数据放到url里面"><a href="#post能不能把数据放到url里面" class="headerlink" title="post能不能把数据放到url里面"></a>post能不能把数据放到url里面</h1><p>应该能，但放在url里能访问的数据太少，可能不够</p>
<h1 id="进程通信方式（详解）"><a href="#进程通信方式（详解）" class="headerlink" title="进程通信方式（详解）"></a>进程通信方式（详解）</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ol>
<li>管道为空时，读操作会被阻塞；管道满时，写操作会被阻塞 </li>
<li>可以有多个进程读写，只是不能同时写。    </li>
<li>匿名管道只能单向，命名管道可以双向。    </li>
<li>管道是在内存中。</li>
</ol>
<h3 id="匿名管道："><a href="#匿名管道：" class="headerlink" title="匿名管道："></a>匿名管道：</h3><p>管道是IPC最基本的一种实现机制。我们都知道在Linux下“一切皆文件”，其实这里的管道就是一个文件。管道实现进程通信就是让两个进程都能访问该文件。<br>管道的特征：<br>①只提供单向通信，也就是说，两个进程都能访问这个文件，假设进程1往文件内写东西，那么进程2 就只能读取文件的内容。<br>②只能用于具有血缘关系的进程间通信，通常用于父子进程建通信<br>③管道是基于字节流来通信的<br>④依赖于文件系统，它的生命周期随进程的结束结束（随进程）<br>⑤其本身自带同步互斥效果</p>
<h3 id="命名管道（FIFO）"><a href="#命名管道（FIFO）" class="headerlink" title="命名管道（FIFO）"></a>命名管道（FIFO）</h3><p>上述管道虽然实现了进程间通信，但是它具有一定的局限性：首先，这个管道只能是具有血缘关系的进程之间通信；第二，它只能实现一个进程写另一个进程读，而如果需要两者同时进行时，就得重新打开一个管道。<br>为了使任意两个进程之间能够通信，就提出了命名管道（named pipe 或 FIFO）。<br>1、与管道的区别：提供了一个路径名与之关联，以FIFO文件的形式存储于文件系统中，能够实现任何两个进程之间通信。而匿名管道对于文件系统是不可见的，它仅限于在父子进程之间的通信。<br>2、FIFO是一个设备文件，在文件系统中以文件名的形式存在，因此即使进程与创建FIFO的进程不存在血缘关系也依然可以通信，前提是可以访问该路径。<br>3、FIFO(first input first output)总是遵循先进先出的原则，即第一个进来的数据会第一个被读走。</p>
<p>那么知道什么是命名管道后我们如何通过一个命名管道实现两个进程之间通信呢？？？？同上一样，我们先给出函数：</p>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><p>命名管道与匿名管道使用的区别：<br>命名管道创建完成后就可以使用，其使用方法与管道一样，区别在于：命名管道使用之前需要使用open()打开。这是因为：命名管道是设备文件，它是存储在硬盘上的，而管道是存在内存中的特殊文件。但是需要注意的是，命名管道调用open()打开有可能会阻塞，但是如果以读写方式（O_RDWR）打开则一定不会阻塞；以只读（O_RDONLY）方式打开时，调用open()的函数会被阻塞直到有数据可读；如果以只写方式（O_WRONLY）打开时同样也会被阻塞，知道有以读方式打开该管道。</p>
<h2 id="信号（Signal）"><a href="#信号（Signal）" class="headerlink" title="信号（Signal）"></a>信号（Signal）</h2><p>信号是比较复杂的通信方式，用于通知接受进程有某种事件发生。</p>
<p><strong>SIGINT</strong>：ctrl+c 终止信号</p>
<p>SIGTSTP:ctrl+z 暂停信号</p>
<p>SIGCHLD：子进程状态改变，父进程收到信号</p>
<p>SIGKILL：杀死信号</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>
<p>解耦</p>
<p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p>
<p><img src="https://pic3.zhimg.com/v2-176cf95bae99a81c9531733d7e36f5e6_b.jpg" alt="img"></p>
<p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p>
<p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p>
<p><img src="https://pic4.zhimg.com/v2-6b109327d85feeb52144a4398faf4ae7_b.jpg" alt="img"></p>
<p><strong>总结</strong>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p>
<p><strong>面试技巧</strong>：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</p>
<p>异步</p>
<p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p>
<p><img src="https://pic4.zhimg.com/v2-a0de9e2326358225d2ab542881862dbb_b.jpg" alt="img"></p>
<p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p>
<p>如果<strong>使用 MQ</strong>，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p>
<p><img src="https://pic1.zhimg.com/v2-212009a1822e7b38ad1f42a00f6a7294_b.jpg" alt="img"></p>
<p>削峰</p>
<p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p>
<p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p>
<p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p>
<p><img src="https://pic2.zhimg.com/v2-5daf297f23003c6a5cfcd87aa7c9ed99_b.jpg" alt="img"></p>
<p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p>
<p><img src="https://pic4.zhimg.com/v2-ebe47086a4494ce5b4963f1d05e7984b_b.jpg" alt="img"></p>
<p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p>
<p>消息队列有什么优缺点</p>
<p>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>
<p>缺点有以下几个：</p>
<ul>
<li>系统可用性降低</li>
<li>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以点击这里查看。</li>
<li>系统复杂度提高</li>
<li>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li>
<li>一致性问题</li>
<li>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p>
<p> 在java语言中，基本上没有说起共享内存这个概念。</p>
<p>在jdk1.4中提供的类MappedByteBuffer为咱们实现共享内存提供了较好的方法。该缓冲区其实是一个磁盘文件的内存映像。两者的变化将保持同步，即内存数据发生变化会马上反映到磁盘文件中，这样会有效的保证共享内存的实现。</p>
<h2 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h2><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p>
<p>如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p>
<h2 id="套接口（Socket）"><a href="#套接口（Socket）" class="headerlink" title="套接口（Socket）"></a>套接口（Socket）</h2><p>套接口（Socket）：更为一般的进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。可用于不同机器之间的进程间通信。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Longtermevolution/article/details/107243574">java进程间通信的几种方式？对比总结</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jdliyao/article/details/79836882">java 管道</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33951180/article/details/68959819">匿名管道和命名管道</a></p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/carsonwuu/p/10399527.html">Java消息队列</a></p>
<h1 id="临界区，互斥量，信号量"><a href="#临界区，互斥量，信号量" class="headerlink" title="临界区，互斥量，信号量"></a>临界区，互斥量，信号量</h1><p>四种进程或线程同步互斥的控制方法<br>1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。<br>2、互斥量:为协调共同对一个共享资源的单独访问而设计的。<br>3、信号量:为控制一个具有有限数量用户资源而设计。<br>4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>
<p>1.临界区（Critical Section）<br>       保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。<br>      临界区包含两个操作原语： </p>
<p>EnterCriticalSection（） 进入临界区<br>LeaveCriticalSection（） 离开临界区<br>EnterCriticalSection（） 语句执行后代码将进入临界区以后无论发生什么，必须确保与之匹配的 LeaveCriticalSection（）都能够被执行到。否则临界区保护的共享资源将永远不会被释放。虽然临界区同步速度很快，但却只能用来同步本 进程内的线程，而不可用来同步多个进程中的线程。 </p>
<p>​        </p>
<p>2.互斥量（Mutex）<br>       互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。 </p>
<p>互斥量包含的几个操作原语：<br>CreateMutex（） 创建一个互斥量<br>OpenMutex（） 打开一个互斥量<br>ReleaseMutex（） 释放互斥量<br>WaitForMultipleObjects（） 等待互斥量对象 </p>
<ol start="3">
<li><p>信号量（Semaphores）</p>
<p>信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源 ，这与操作系统中的PV操作相同。它指出了同时访问共享 资源的线程 最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。在用CreateSemaphore（）创建信号量 时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数 就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目， 不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可 用资源计数加1。在任何时候当前可用资源计数决不可能大于最大资源计数。 </p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36582604/article/details/82078249">java并发编程——临界区，互斥量，信号量</a></p>
</li>
</ol>
<h1 id="“-”和equals的差别"><a href="#“-”和equals的差别" class="headerlink" title="“==”和equals的差别"></a>“==”和equals的差别</h1><p><strong>一、java当中的数据类型和“==”的含义：</strong></p>
<ul>
<li>基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。</li>
<li>引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是<strong>堆内存</strong>地址）。</li>
</ul>
<p>注：对于第二种类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。</p>
<p><strong>二、equals()方法介绍：</strong></p>
<p>JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    &#x2F;&#x2F;this - s1</span><br><span class="line">    &#x2F;&#x2F;obj - s2</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。<br>所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。</p>
<p>我们对上面的两段内容做个总结吧：</p>
<p> <strong>== 的作用：</strong><br>　　基本类型：比较的就是值是否相同<br>　　引用类型：比较的就是地址值是否相同<br><strong>equals 的作用:</strong><br>　　引用类型：默认情况下，比较的是地址值。<br>注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同</p>
<p><strong>三、String类的equals()方法：</strong></p>
<p>现在我们拿String类来举例：</p>
<p>我们去\src\java\lang目录中找到String类，发现equals方法被重写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>         <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line"> <span class="number">3</span>             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> <span class="number">4</span>         &#125;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"> <span class="number">6</span>             String anotherString = (String)anObject;</span><br><span class="line"> <span class="number">7</span>             <span class="keyword">int</span> n = value.length;</span><br><span class="line"> <span class="number">8</span>             <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line"> <span class="number">9</span>                 <span class="keyword">char</span> v1[] = value;</span><br><span class="line"><span class="number">10</span>                 <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"><span class="number">11</span>                 <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="number">12</span>                 <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">13</span>                     <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line"><span class="number">14</span>                         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">15</span>                     i++;</span><br><span class="line"><span class="number">16</span>                 &#125;</span><br><span class="line"><span class="number">17</span>                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="number">18</span>             &#125;</span><br><span class="line"><span class="number">19</span>         &#125;</span><br><span class="line"><span class="number">20</span>         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="number">21</span>     &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以看出，String类中被复写的equals()方法其实是比较两个字符串的内容。下面我们通过实际代码来看看String类的比较。</p>
<p>1、举例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>         String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="number">4</span>         String s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="number">5</span>         System.out.println(s1 == s2);   <span class="comment">// true</span></span><br><span class="line"><span class="number">6</span>     &#125;</span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上方代码中，用“==”比较s1和s2，返回的结果是true。</p>
<p>2、稍微改动一下程序，会有奇怪的发现：</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span>         String str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"> <span class="number">4</span>         String str2 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"> <span class="number">5</span>         String str3 = str2; <span class="comment">// 引用传递</span></span><br><span class="line"> <span class="number">6</span>         System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line"> <span class="number">7</span>         System.out.println(str1 == str3); <span class="comment">// false</span></span><br><span class="line"> <span class="number">8</span>         System.out.println(str2 == str3); <span class="comment">// true</span></span><br><span class="line"> <span class="number">9</span>         System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line"><span class="number">10</span>         System.out.println(str1.equals(str3)); <span class="comment">// true</span></span><br><span class="line"><span class="number">11</span>         System.out.println(str2.equals(str3)); <span class="comment">// true</span></span><br><span class="line"><span class="number">12</span>     &#125;</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p> 上方第4行代码中，我们new了一个对象，用“==”比较s1和s2，返回的结果却是false；而用用“equals”比较s1和s2，返回的结果是true。 </p>
<p>为了分析上面的代码，我们必须首先分析堆内存空间和栈内存空间，这一点非常重要：</p>
<p><img src="https://images0.cnblogs.com/blog/641601/201408/221553240496054.png" alt="img"></p>
<p>看完上面的图，再结合上面的代码，就一目了然了。现在我们可以给自己出一道面试题：</p>
<p><strong>面试题：请解释字符串比较之中“==”和equals()的区别？</strong></p>
<ul>
<li> ==：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；</li>
<li> equals()：比较的是两个字符串的内容，属于内容比较。</li>
</ul>
<p><strong>以后进行字符串相等判断的时候都使用equals()。</strong></p>
<p>3、再次更改程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span></span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>         String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="number">4</span>         String s2 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="number">5</span>         s2 = s2.intern();</span><br><span class="line"><span class="number">6</span>         System.out.println(s1 == s2);       <span class="comment">//  true</span></span><br><span class="line"><span class="number">7</span>         System.out.println(s1.equals(s2));  <span class="comment">//  true</span></span><br><span class="line"><span class="number">8</span>     &#125;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>



<p>上述代码的第5行中，java.lang.String的intern()方法”abc”.intern()方法的返回值还是字符串”abc”，表面上看起来好像这个方法没什么用处。但实际上，它做了个小动作：检查字符串池里是否存在”abc”这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把”abc”添加到字符串池中，然后再返回它的引用。</p>
<h1 id="Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。"><a href="#Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。" class="headerlink" title="Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。"></a><strong>Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。</strong></h1><p>　总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。</p>
<p>  于是，Java采用了哈希表的原理。哈希算法也称为散列算法，当集合要添加新的元素时，将对象通过哈希算法计算得到哈希值（正整数），然后将哈希值和集合（数组）长度进行&amp;运算，得到该对象在该数组存放的位置索引。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就表示发生冲突了，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。</p>
<p>  这样一来，实际调用equals方法比较的次数就大大降低了，几乎只需要一两次。</p>
<p>  <strong>简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！</strong></p>
<h1 id="Java-对象的equal方法和hashCode方法的关系"><a href="#Java-对象的equal方法和hashCode方法的关系" class="headerlink" title="Java  对象的equal方法和hashCode方法的关系"></a><strong>Java  对象的equal方法和hashCode方法的关系</strong></h1><p><strong>首先，Java对象相同指的是两个对象通过eqauls方法判断的结果为true</strong></p>
<p>Java对象的eqauls方法和hashCode方法是这样规定的：</p>
<p><strong>1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。</strong></p>
<p><strong>2、如果两个对象的hashCode相同，它们并不一定相同。</strong></p>
<p>关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？</p>
<p> 想象一下，假如两个Java对象A和B，A和B相等（eqauls结果为true），但A和B的哈希码不同，则A和B存入HashMap时的哈希码计算得到的HashMap内部数组位置索引可能不同，那么A和B很有可能允许同时存入HashMap，显然相等/相同的元素是不允许同时存入HashMap，HashMap不允许存放重复元素。</p>
<p> <strong>关于第二点，两个对象的hashCode相同，它们并不一定相同</strong></p>
<p> 也就是说，不同对象的hashCode可能相同；假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41125219/article/details/81981805">HashMap中实现原理及hashcode方法</a></p>
<h1 id="HashMap怎么解决hash冲突"><a href="#HashMap怎么解决hash冲突" class="headerlink" title="HashMap怎么解决hash冲突"></a>HashMap怎么解决hash冲突</h1><p>HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。当程序执行 map.put(String,Obect)方法 时，系统将调用String的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置。</p>
<p>源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);  </span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">            Object k;  </span><br><span class="line">            <span class="comment">//判断当前确定的索引位置是否存在相同hashcode和相同key的元素，如果存在相同的hashcode和相同的key的元素，那么新值覆盖原来的旧值，并返回旧值。  </span></span><br><span class="line">            <span class="comment">//如果存在相同的hashcode，那么他们确定的索引位置就相同，这时判断他们的key是否相同，如果不相同，这时就是产生了hash冲突。  </span></span><br><span class="line">            <span class="comment">//Hash冲突后，那么HashMap的单个bucket里存储的不是一个 Entry，而是一个 Entry 链。  </span></span><br><span class="line">            <span class="comment">//系统只能必须按顺序遍历每个 Entry，直到找到想搜索的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry 是最早放入该 bucket 中），  </span></span><br><span class="line">            <span class="comment">//那系统必须循环到最后才能找到该元素。  </span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">                V oldValue = e.value;  </span><br><span class="line">                e.value = value;  </span><br><span class="line">                <span class="keyword">return</span> oldValue;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        modCount++;  </span><br><span class="line">        addEntry(hash, key, value, i);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>当创建 HashMap 时，有一个默认的负载因子（load factor），其默认值为 0.75，这是时间和空间成本上一种折衷：增大负载因子可以减少 Hash 表（就是那个 Entry 数组）所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的的操作（HashMap 的 get() 与 put() 方法都要用到查询）；减小负载因子会提高数据查询的性能，但会增加 Hash 表所占用的内存空间。<br>其中loadFactor加载因子是表示Hsah表中元素的填满的程度.</p>
<p>若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.链表长度会越来越长,查找效率降低。反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏（很多空间还没用，就开始扩容了）</p>
<p>冲突的机会越大,则查找的成本越高.</p>
<p>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的”时-空”矛盾的平衡与折衷.</p>
<p>如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lanzhupi/article/details/109616944">16面试常问：你能谈谈HashMap怎样解决hash冲突吗</a></p>
<h1 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5972220efc9a">java泛型你需要知道的一切</a></p>
<h1 id="阻塞队列详解"><a href="#阻塞队列详解" class="headerlink" title="阻塞队列详解"></a>阻塞队列详解</h1><p>具体参考：</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/tjudzj/p/4454490.html">BlockingQueue（阻塞队列）详解</a></p>
<h1 id="浏览器输入网址之后发生了什么？——url全过程"><a href="#浏览器输入网址之后发生了什么？——url全过程" class="headerlink" title="浏览器输入网址之后发生了什么？——url全过程"></a>浏览器输入网址之后发生了什么？——url全过程</h1><p>浏览器输入网址之后发生了什么<br>一、DNS域名解析<br>域名系统（英文：Domain Name System，缩写：DNS）</p>
<p>1、浏览器自己的DNS缓存中找，没有就下一步</p>
<p>2、在操作系统的DNS缓存中找</p>
<p>3、操作系统本地自己的host文件中找</p>
<p>4、操作系统就向本地域名服务器发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果找不到，运营商DNS服务器会代我们向根域名服务器发起迭代查询请求，得到顶级域名服务器的IP，根向顶级域名服务器得到权限域名服务器IP，顶级域名服务器向权限域名服务器发请求得到IP，得到了这个IP后，本地域名服务器返回IP给操作系统，同时将IP缓存下来，操作系统在还给浏览器，同时缓存IP</p>
<p>二、与服务器建立连接<br>TCP连接的建立</p>
<p><img src="https://img-blog.csdnimg.cn/20200923143246516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE4NTgyNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020092314331484.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE4NTgyNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</li>
<li>Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</li>
<li>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</li>
</ol>
<p>三、发起HTTP连接<br><strong>Http是什么？</strong></p>
<p>http协议是超文本传输，通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。</p>
<p>四个基于：</p>
<p><strong>请求与响应：</strong>客户端发送请求，服务器端响应数据</p>
<p><strong>无状态的：</strong>协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。</p>
<p><strong>应用层</strong>： Http是属于应用层的协议，配合TCP/IP使用。</p>
<p><strong>TCP/IP</strong>： Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。</p>
<p><strong>HTTP请求报文结构</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200923143437600.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE4NTgyNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>1.请求行：</p>
<p>例如：POST /chapter17/user.html HTTP/1.1</p>
<p>格式：请求方式 资源路径 协议/版本</p>
<p>2.请求方法</p>
<p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p>
<p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p>
<p>网络体系（OSI七层、TCP/IP四层、五层）</p>
<p>3.协议版本</p>
<p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p>
<p>四、服务器响应HTTP请求，浏览器得到html代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">··[状态码]()</span><br><span class="line">1xx: 信息性状态码</span><br><span class="line">  100, 101</span><br><span class="line">2xx: 成功状态码</span><br><span class="line">  200：OK</span><br><span class="line">3xx: 重定向状态码</span><br><span class="line">  301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;</span><br><span class="line">  302: 临时重定向，显式重定向, Location响应首部的值为新的URL</span><br><span class="line">  304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可。</span><br><span class="line">4xx: 客户端错误状态码</span><br><span class="line">  404: Not Found  请求的URL资源并不存在</span><br><span class="line">5xx: 服务器端错误状态码</span><br><span class="line">  500: Internal Server Error  服务器内部错误</span><br><span class="line">  502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现</span><br><span class="line">  504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应</span><br></pre></td></tr></table></figure>

<p>五、浏览器解析html代码，并请求html代码中的资源<br>六、 浏览器对页面进行渲染呈现给用户<br>七、TCP断开连接<br>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41185826/article/details/108752571">浏览器输入网址之后发生了什么？</a></p>
<h1 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h1><p>第一范式： 所有字段值都是不可分解的原子值 。例如有一个列是电话号码一个人可能有一个办公电话一个移动电话。第一范式就需要拆开成两个属性。<br>第二范式：非主属性完全函数依赖于候选键。如PersonID，ProductID，ProductName，PersonName可以看到，OrderID和ProductID是联合主键，但是ProductName是依赖于ProductID的，只依赖了部分主键，没有依赖全部主键。需要拆分成三个表：PersonID, PersonName, ProductID, ProductName和PersonID, ProductID<br>第三范式： 每一列数据都和主键直接相关，而不能间接相关<br>如OrderID，ProductID，ProductName，OrderID是主键，但是ProductID依赖了OrderID，而ProductName依赖了ProductID，等于说是间接依赖了OrderID，所以需要拆分为两个表：OrderID, ProductID和ProductID, ProductName</p>
<p><strong>这里需要指明范式不是最好的，我们需要混合使用范式和反范式</strong></p>
<ul>
<li>范式的优点：因为相对来说有较少的重复数据，范式化的更新操作要比反范式快。同时范式化需要更少的distinct和order by</li>
<li>范式化缺点：通常需要关联，不仅代价昂贵，也可能会使的一些索引无效</li>
</ul>
<p>常用的反范式方法：</p>
<ul>
<li>复制：在两个表中根据实际业务情况存储<strong>部分</strong>相同的字段列，即有利于查询，也不会把表搞的太大</li>
<li>缓存：对于需要多次join查询的表，可以在一个表中加入一个缓存列，用来缓存所join表的部分常用数据，如count等，我们需要实时更新该缓存</li>
</ul>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43968895/article/details/107052903">MySql面试题总结</a></p>
<h1 id="网络分层及常用网络设备所在的层"><a href="#网络分层及常用网络设备所在的层" class="headerlink" title="网络分层及常用网络设备所在的层"></a>网络分层及常用网络设备所在的层</h1><table>
<thead>
<tr>
<th align="left">TCP/IP</th>
<th align="left">OSI</th>
</tr>
</thead>
<tbody><tr>
<td align="left">应用层</td>
<td align="left">应用层  表示层  会话层</td>
</tr>
<tr>
<td align="left">主机到主机层（TCP）（又称传输层）</td>
<td align="left">传输层</td>
</tr>
<tr>
<td align="left">网络层（IP）(又称互联层)</td>
<td align="left">网络层</td>
</tr>
<tr>
<td align="left">网络接口层（又称链路层）</td>
<td align="left">数据链路层</td>
</tr>
<tr>
<td align="left">物理层</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>物理层设备：中继器，集线器</p>
<p>数据链路层设备：网桥，交换机</p>
<p>网路层设备：三层交换机，路由器</p>
<p><img src="https://iknow-pic.cdn.bcebos.com/b151f8198618367a54183fc324738bd4b31ce51f?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="img"></p>
<p><img src="https://iknow-pic.cdn.bcebos.com/0d338744ebf81a4c9c98acd7dd2a6059252da602?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="img"></p>
<h1 id="HashMap的时间复杂度分析"><a href="#HashMap的时间复杂度分析" class="headerlink" title="HashMap的时间复杂度分析"></a>HashMap的时间复杂度分析</h1><p>不管插入还是查找，由key获取hash值然后定位到桶的时间复杂度都是O（1），那么真正决定时间复杂度的实际上是桶里面链表/红黑树的情况</p>
<p>如果桶里面没有元素，那么直接将元素插入/或者直接返回未查找到，时间复杂度就是O（1），如果里面有元素，那么就沿着链表进行遍历，时间复杂度就是O（n），链表越短时间复杂度越低，如果是红黑树的话那就是O（logn）</p>
<p>所以平均复杂度很难说，只能说在最优的情况下是O（1）</p>
<h1 id="mysql怎么实现主从复制"><a href="#mysql怎么实现主从复制" class="headerlink" title="mysql怎么实现主从复制"></a>mysql怎么实现主从复制</h1><ol>
<li>Master开启bin-log功能，服务器配置二进制日志（binlog日志），只保留update等的数据。</li>
<li>需要开启三个线程，Master：I/O线程；Slave：I/O线程，SQL线程。</li>
<li>从数据库会请求主数据库的binlog日志，将bin-log日志内容写入到relay-log中继日志，创建一个master.info文件，然后按日志执行</li>
<li>Slave已经开启了sql线程，由sql线程实时监测relay-log日志内容是否有更新，如果有更新，则解析文件中的sql语句，并在Slave数据库中执行相同的操作语句。</li>
</ol>
<h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><h2 id="备份方式"><a href="#备份方式" class="headerlink" title="备份方式"></a>备份方式</h2><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><p>SQL级别的备份机制，其将数据表导成SQL脚本文件，然后相当于在另一台服务器上执行一遍备份的SQL语句。</p>
<ul>
<li><p><strong>操作语句：</strong> 使用<code>mysqldump</code>语句来实现，具体语句为：</p>
<p><code>mysqldump -h主机名 -P端口 -u用户名 -p密码 --database 数据库名 &gt; 文件名.sql</code></p>
</li>
<li><p><strong>优点：</strong> 恢复简单、与存储引擎无关，消除了底层数据存储的不同，有助于避免数据损坏</p>
</li>
<li><p><strong>缺点：</strong> 必须有数据库完成逻辑工作，需要更多地CPU周期，且逻辑备份还原慢</p>
</li>
</ul>
<h3 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h3><p>是基于文件的物理备份，比较类似于拷贝数据库的文件，然后复制到另一台服务器加载。</p>
<ul>
<li><strong>优点：</strong> 容易跨平台、跨操作系统和MySQL版本，且恢复起来很快</li>
<li><strong>缺点：</strong> 文件比较大，不总是可以跨平台、操作系统和MySQL版本</li>
</ul>
<h1 id="LRU的实现方案"><a href="#LRU的实现方案" class="headerlink" title="LRU的实现方案"></a>LRU的实现方案</h1><ol>
<li>用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。</li>
<li>利用一个链表来实现，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。</li>
<li>利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。</li>
</ol>
<h1 id="Java包装类、拆箱和装箱详解"><a href="#Java包装类、拆箱和装箱详解" class="headerlink" title="Java包装类、拆箱和装箱详解"></a>Java包装类、拆箱和装箱详解</h1><p>Java为每种基本数据类型分别设计了对应的类，称之为包装类(Wrapper Classes)，也有教材称为外覆类或数据类型类。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>对应的包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>每个包装类的对象可以封装一个相应的基本类型的数据，并提供了其它一些有用的方法。包装类对象一经创建，其内容（所封装的基本类型数据值）不可改变。</p>
<p>基本类型和对应的包装类可以相互装换：<br>• 由基本类型向对应的包装类转换称为装箱，例如把 int 包装成 Integer 类的对象；<br>• 包装类向对应的基本类型转换称为拆箱，例如把 Integer 类的对象重新简化为 int。</p>
<h3 id="1-包装类的特点"><a href="#1-包装类的特点" class="headerlink" title="1.包装类的特点"></a>1.包装类的特点</h3><p>(1)所有的包装类都是final类型，因此不能创建它们的子类。<br>(2)包装类是不可变类，一个包装类的对象创建后，它所包含的基本数据类型就不能被改变。</p>
<h2 id="自动拆箱和装箱"><a href="#自动拆箱和装箱" class="headerlink" title="自动拆箱和装箱"></a>自动拆箱和装箱</h2><p>上面的例子都需要手动实例化一个包装类，称为手动拆箱装箱。Java 1.5(5.0) 之前必须手动拆箱装箱。</p>
<p>Java 1.5 之后可以自动拆箱装箱，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y396397735/article/details/79394637"> Java包装类、拆箱和装箱详解</a></p>
<h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><p>1.Object类的简单介绍<br>1）Java中的类都会默认继承Object类。Object类是所有类的父类。因此所有类的对象都可以用Object类进行接收。<br>            2）所有Java类都继承了Object类的方法，包括wait()、notify()、equals()和toString().<br>            3）如果一个类希望接收所有的数据类型，那么考虑使用Object类。</p>
<p>2.Object类的方法<br>2.1 构造方法</p>
<p>  public Object(){}//方法体为空<br>2.2 其它方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span><span class="comment">//比较两个对象是否相等</span></span></span><br><span class="line"><span class="function">2 <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//从等待池中唤醒另一个线程，把它转移到锁池。</span></span></span><br><span class="line"><span class="function">3 <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//从等待池中唤醒所有的线程，把它转移到锁池。</span></span></span><br><span class="line"><span class="function">4 <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">//使当前线程进入等待状态，直到别的线程调用notify()或notifyAll()方法唤醒它。</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span><span class="comment">//返回对象的哈希码。</span></span></span><br><span class="line"><span class="function">6 <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回当前对象的字符串表示。格式为“类名@对象的十六进制哈希码&quot;</span></span></span><br><span class="line"><span class="function">7 <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable<span class="comment">//对于一个不被任何变量引用的对象，当垃圾回收器准备回收该对象所占用的内存时，将自动调用该对象的finalize()方法。</span></span></span><br></pre></td></tr></table></figure>


<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/smell201611010513/article/details/89886448">Java之Object类与包装类</a></p>
<h1 id="为什么要有object类"><a href="#为什么要有object类" class="headerlink" title="为什么要有object类"></a>为什么要有object类</h1><p>（1）可以使不同对象之间可以统一、互转。我觉得其中还包括 toString(),wait()…等公共方法的统一定义</p>
<p>（2）对父类的逻辑处理统一，不需要根据有没有父类分两种实现，</p>
<h1 id="java的根类Object详细分析"><a href="#java的根类Object详细分析" class="headerlink" title="java的根类Object详细分析"></a>java的根类Object详细分析</h1><p> hashCode()方法返回一个整形数值，表示该对象的哈希码值。</p>
<p> <strong>hashCode()具有如下约定：</strong></p>
<p> 1).在Java应用程序程序执行期间，对于同一对象<strong>多次调用hashCode()方法时，其返回的哈希码是相同的</strong>，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致；</p>
<p>2).如果<strong>两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等</strong>；</p>
<p>3).反之，两个对象调用h<strong>asCode()返回的哈希码相等，这两个对象不一定相等。</strong></p>
<p>​    即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt;  equals()相等  =&gt; hashCode()相等。因此，<strong>重写equlas()方法必须重写hashCode()方法，以保证此逻辑严格成立</strong>，同时可以推理出：<strong>hasCode()不相等 =&gt; equals（）不相等 &lt;=&gt; 两个对象不相等。</strong></p>
<h3 id="注意：先用hasCode-方法去判断再用equals方法判断"><a href="#注意：先用hasCode-方法去判断再用equals方法判断" class="headerlink" title="注意：先用hasCode()方法去判断再用equals方法判断"></a>注意：先用hasCode()方法去判断再用equals方法判断</h3><p>可能有人在此产生疑问：既然比较两个对象是否相等的唯一条件（也是冲要条件）是equals，那么为什么还要弄出一个hashCode()，并且进行如此约定，弄得这么麻烦？</p>
<p><strong>其实，*<em>这主要体现在hashCode()方法的作用上，其主要用于增强哈希表的性能。*</em></strong></p>
<p>   以集合类中，以Set为例，当新加一个对象时，需要判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。（注：Set的底层用的是Map的原理实现）</p>
<p>  在此需要纠正一个理解上的误区：<strong>对象的hashCode()返回的不是对象所在的物理内存地址。甚至也不一定是对象的逻辑地址，hashCode()相同的两个对象，不一定相等，换言之，不相等的两个对象，hashCode()返回的哈希码可能相同。</strong></p>
<p>因此，在上述代码中，重写了equals()方法后，需要重写hashCode()方法。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jianchilu/article/details/83627621?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control">java的根类Object详细分析</a></p>
<h1 id="TCP滑动窗口控制流量的原理"><a href="#TCP滑动窗口控制流量的原理" class="headerlink" title="TCP滑动窗口控制流量的原理"></a>TCP滑动窗口控制流量的原理</h1><p>TCP的滑动窗口机制<br>   TCP这个协议是网络中使用的比较广泛，他是一个面向连接的可靠的传输协议。既然是一个可靠的传输协议就需要对数据进行确认。TCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。</p>
<p>​    TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。</p>
<p>具体参考：</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoquan/p/4886345.html">TCP滑动窗口控制流量的原理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/zijiemianjing210510/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/zijiemianjing210510/" class="post-title-link" itemprop="url">字节面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-10 21:43:00 / 修改时间：21:45:03" itemprop="dateCreated datePublished" datetime="2021-05-10T21:43:00+08:00">2021-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字节一面凉经"><a href="#字节一面凉经" class="headerlink" title="字节一面凉经"></a>字节一面凉经</h2><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/23f8249886c6">JVM垃圾回收机制</a></p>
<h2 id="你所使用的垃圾回收器"><a href="#你所使用的垃圾回收器" class="headerlink" title="你所使用的垃圾回收器"></a>你所使用的垃圾回收器</h2><h3 id="Java垃圾收集器的历史"><a href="#Java垃圾收集器的历史" class="headerlink" title="Java垃圾收集器的历史"></a>Java垃圾收集器的历史</h3><p>第一阶段，Serial（串行）收集器</p>
<p>在jdk1.3.1之前，java虚拟机仅仅能使用Serial收集器。 Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p>PS：开启Serial收集器的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>

<p>第二阶段，Parallel（并行）收集器</p>
<p>Parallel收集器也称吞吐量收集器，相比Serial收集器，Parallel最主要的优势在于使用多线程去完成垃圾清理工作，这样可以充分利用多核的特性，大幅降低gc时间。</p>
<p>PS:开启Parallel收集器的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC -XX:+UseParallelOldGC</span><br></pre></td></tr></table></figure>

<p>第三阶段，CMS（并发）收集器</p>
<p>CMS收集器在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。</p>
<p>PS:开启CMS收集器的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure>

<p>第四阶段，G1（并发）收集器</p>
<p>G1收集器（或者垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4GB）时产生的停顿。相对于CMS的优势而言是内存碎片的产生率大大降低。</p>
<p>PS:开启G1收集器的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure>

<h2 id="你常用Java的数据结构"><a href="#你常用Java的数据结构" class="headerlink" title="你常用Java的数据结构"></a>你常用Java的数据结构</h2><p>一、线性表（重点）</p>
<p>线性表是由N个元素组成的有序序列，也是最常见的一种数据结构。重点有两个数组和链表。</p>
<p>1、数组</p>
<p>数组是一种存储单元连续，用来存储固定大小元素的线性表。java中对应的集合实现，比如ArrayList。</p>
<p>2、链表</p>
<p>链表又分单链表和双链表，是在物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。java中对应的集合实现，比如LinkedList。</p>
<p>二、栈与队列</p>
<p>1、栈</p>
<p><a target="_blank" rel="noopener" href="http://file.elecfans.com/web1/M00/A3/63/o4YBAF1VEn2ATJNmAAArq7iRv5U807.jpg"><img src="http://file.elecfans.com/web1/M00/A3/63/o4YBAF1VEn2ATJNmAAArq7iRv5U807.jpg" alt="img"></a></p>
<p>栈，是一种运算受限的线性表，重点掌握其后进先出的特点。表的末端叫栈顶，基本操作有push（进栈）和pop（出栈）。java中stack就是简单的栈实现。</p>
<p>2、队列</p>
<p>队列也是一种操作受限制的线性表，重点掌握其先进先出的特点。表的前端只允许进行删除操作，表的后端进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。java中很多Queue的实现，消息中间件的队列本质也是基于此的。</p>
<p>三、树（重点）</p>
<p>在非线性结构里面，树是非常非常重要的一种数据结构。基于其本身的结构优势，尤其在查找领域，应用广泛，其中又以二叉树最为重要。树的话我们这里只重点说一下二叉树。</p>
<p>1、二叉搜索树</p>
<p>二叉搜索树又叫二叉查找树，又叫二叉排序树。性质如下：（1） 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2） 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3） 左、右子树也分别为二叉排序树；（4） 没有键值相等的结点。</p>
<p>2、平衡二叉树</p>
<p>平衡二叉树又叫AVL树。性质如下：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</p>
<p>3、红黑树</p>
<p><a target="_blank" rel="noopener" href="http://file.elecfans.com/web1/M00/A3/B6/pIYBAF1VEsOAap9mAAAlCFfvgWs929.jpg"><img src="http://file.elecfans.com/web1/M00/A3/B6/pIYBAF1VEsOAap9mAAAlCFfvgWs929.jpg" alt="img"></a></p>
<p>红黑树是一种特殊的平衡二叉树，它保证在最坏情况下基本动态集合操作的事件复杂度为O（log n）。</p>
<p>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p>
<p>四、图</p>
<p>图是比线性表和树更复杂的数据结构，面试中基本不太会问到，大家有兴建的可以自己去了解下。</p>
<h2 id="LinkedHashMap是怎么实现，HashMap是怎么实现的（HashMap、LinkedHashMap、TreeMap）的区别"><a href="#LinkedHashMap是怎么实现，HashMap是怎么实现的（HashMap、LinkedHashMap、TreeMap）的区别" class="headerlink" title="LinkedHashMap是怎么实现，HashMap是怎么实现的（HashMap、LinkedHashMap、TreeMap）的区别"></a>LinkedHashMap是怎么实现，HashMap是怎么实现的（HashMap、LinkedHashMap、TreeMap）的区别</h2><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>
<p><img src="https://img-blog.csdn.net/20170512155609530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>　与HashMap相比，LinkedHashMap增加了两个属性用于保证迭代顺序，分别是 <strong>双向链表头结点header</strong> 和 <strong>标志位accessOrder</strong> (值为true时，表示按照访问顺序迭代；值为false时，表示按照插入顺序迭代)。</p>
<p>基本元素 Entry</p>
<p>　　LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 before 和 after，它们分别用于维护双向链接列表。特别需要注意的是，next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的，源代码如下：</p>
<p>private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; {</p>
<pre><code>// These fields comprise the doubly linked list used for iteration.
Entry&lt;K,V&gt; before, after;

Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;
    super(hash, key, value, next);
&#125;
...
</code></pre>
<p>}</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</p>
<p>SortedMap接口：（TreeMap继承自SortedMap）它用来保持键的有序顺序。SortedMap接口为映像的视图(子集)，包括两个端点提供了访问方法。除了排序是作用于映射的键以外，处理SortedMap和处理SortedSet一样。添加到SortedMap实现类的元素必须实现Comparable接口，否则您必须给它的构造函数提供一个Comparator接口的实现。TreeMap类是它的唯一一份实现。</p>
<p>TreeMap：基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</p>
<h2 id="ConcurrentHashMap是怎么实现的"><a href="#ConcurrentHashMap是怎么实现的" class="headerlink" title="ConcurrentHashMap是怎么实现的"></a>ConcurrentHashMap是怎么实现的</h2><p> Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。这样对每个segment中的数据需要同步操作的话都是使用每个segment容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的segment。这种做法，就称之为“分离锁”。</p>
<h2 id="线程安全的相关Map有哪些，讲一下是怎么实现的"><a href="#线程安全的相关Map有哪些，讲一下是怎么实现的" class="headerlink" title="线程安全的相关Map有哪些，讲一下是怎么实现的"></a>线程安全的相关Map有哪些，讲一下是怎么实现的</h2><p>HashMap在多线程环境下是不安全的，jdk1.7中是因为采用的是头插法，在多线程环境下两个线程同时扩容时会出现环链导致死循环；而jdk1.8中改用尾插法，避免了这个情况，但是其put操作在多线程环境下会发生覆盖，导致线程不安全。那在多线程环境下我们应该怎么做呢？</p>
<ul>
<li>使用HashTable类</li>
<li>使用Collections.synchronizedMap(<strong>Map</strong>)创建线程安全的map</li>
<li>使用ConcurrentHashMap类</li>
</ul>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>说HashTable是<strong>线程安全的</strong>是因为HashTable使用了synchronized关键字来保证线程同步。</p>
<p>我们都知道使用synchronized属于独占式的悲观锁，加上的是重量级锁，当一个线程访问HashTable的同步方法时候，其它的线程只能是阻塞或轮询状态，所以HashTable的并发性是比较差的，效率比较低。翻阅源码还可以得到以下结论：</p>
<h2 id="synchronizedMap"><a href="#synchronizedMap" class="headerlink" title="synchronizedMap"></a>synchronizedMap</h2><p>因此在jdk1.2中引入了Collections.synchronizedMap(<strong>Map</strong>)，这种相对较灵活的方式来保证<strong>Map</strong>的线程安全。</p>
<p>内部类SynchronizedMap类维护了一个final类型的<strong>Map</strong>对象，以及一个互斥锁mutex。SynchronizedMap类有两个构造方法，一个只是把<strong>Map</strong>作为参数，那么就将排斥锁mutex赋值为该<strong>Map</strong>。如果再传入一个mutex参数，那么将对象排斥锁赋值为传入的对象，也就是说通过该参数，对<strong>Map</strong>方法的锁定将仅在该Object(mutex)上进行，因此，其灵活性要优于Hashtable，可以特定的为某个对象上锁。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h2><p>1.7版本</p>
<p>通过源码我们可以看出每个Segment都继承ReentranLock(可重入锁)并单独加锁，因此每次进行加锁操作时锁住的就是一个Segment，这样我们只要保证每个Segment都是<strong>线程安全的</strong>，就能保证全局的线程安全。</p>
<p>从上面的源码我们可以看出，jdk1.7中是如何保证segment中的<strong>线程安全的</strong>：首次进入该方法时先尝试获取该segment的锁，若获取失败，则调用 scanAndLockForPut(key, hash, value)方法来尝试自旋获取锁，如果自旋的次数达到了MAX_SCAN_RETRIES(最大自旋次数)，就会变成阻塞获取，确保可以成功获取锁；</p>
<p>我们可以得出，get()方法不用加锁，而且ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。第一次Hash定位到Segment，第二次Hash定位到元素所在的具体位置上。</p>
<h3 id="JDK1-8中的ConcurrentHashMap类"><a href="#JDK1-8中的ConcurrentHashMap类" class="headerlink" title="JDK1.8中的ConcurrentHashMap类"></a><strong>JDK1.8中的ConcurrentHashMap类</strong></h3><p>在JDK1.8中舍弃了Segment的概念，直接用Node数组+链表+红黑树的数据结构来实现，了解过JDK1.8中HashMap结构的同学，应该可以看出在JDK1.8中 ConcurrentHashMap结构基本上和HashMap一样，而且它们确实是有着有很多相同之处：</p>
<ol>
<li><p>数组的默认容量是16，最大容量是1&lt;&lt;30</p>
</li>
<li><p>当添加元素的时候，将列表转成树的阈值是8</p>
</li>
<li><p>在对数组扩容的时候，当树中元素个数小于或等于6时，将树转成链表</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/42c96d3ef1ed5fd8a01e18adfab0d27b.png" alt="42c96d3ef1ed5fd8a01e18adfab0d27b.png">而且我们从源码中也可以看出，其value值和next使用volatile修饰，保证了内存可见性，以及禁止指令重排。</p>
</li>
</ol>
<p>首先ConcurrentHashMap中Node数组被volatile数组修饰，保证了内存可见性，以及禁止指令重排。</p>
<p>再使用CAS+Synchronized结合来实现赋值的操作，用以确保当前线程操作只锁住该线程操作的节点所在的链表或红黑树，来保证线程安全。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ol>
<li>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构，提高了遍历的效率，从遍历链表的O(n)，到遍历红黑树的O(logN)。</li>
<li>保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</li>
<li>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁(Node)。</li>
</ol>
<h2 id="你使用过哪些锁"><a href="#你使用过哪些锁" class="headerlink" title="你使用过哪些锁"></a>你使用过哪些锁</h2><p>过</p>
<h2 id="volatile能完全替代锁吗-其变量存在哪里"><a href="#volatile能完全替代锁吗-其变量存在哪里" class="headerlink" title="volatile能完全替代锁吗,其变量存在哪里"></a>volatile能完全替代锁吗,其变量存在哪里</h2><p>新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</p>
<ul>
<li>volatile 修饰的变量，是直接拿的主内存的值，就是说这个值永远是最新的，对其他线程是可见的。</li>
<li>而访问非 <code>volatile</code> 变量时，每个线程都会从系统内存（主内存）拷贝变量到工作内存中，然后修改工作内存中的变量值，操控的变量可能不同。</li>
</ul>
<h2 id="synchronized跟lock的区别"><a href="#synchronized跟lock的区别" class="headerlink" title="synchronized跟lock的区别"></a>synchronized跟lock的区别</h2><p>过</p>
<h2 id="基于什么样的规则选择哪些锁"><a href="#基于什么样的规则选择哪些锁" class="headerlink" title="基于什么样的规则选择哪些锁"></a>基于什么样的规则选择哪些锁</h2><h2 id="讲一下synchronized是怎么实现的"><a href="#讲一下synchronized是怎么实现的" class="headerlink" title="讲一下synchronized是怎么实现的"></a>讲一下synchronized是怎么实现的</h2><h3 id="synchronized使用场景"><a href="#synchronized使用场景" class="headerlink" title="synchronized使用场景"></a>synchronized使用场景</h3><p>使用在静态方法上，<code>synchronized</code>锁住的是类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 使用在静态方法上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am test1 method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用在实例方法上，<code>synchronized</code>锁住的是实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 使用在实例方法上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">syncOnMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;a developer name Jimoer&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized用在代码块上</p>
<p><code>synchronized</code>的同步代码块用在类实例的对象上，锁住的是当前的类的实例。<br>即执行buildName的时候，整个对象都会被锁住，直到执行完成buildName后释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带姓氏的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstName 姓氏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">(String firstName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.setName(firstName+<span class="keyword">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized的同步代码块用在类对象上，锁住的是该类的类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> String myName = <span class="string">&quot;Jimoer&quot;</span>;    <span class="comment">/**     * 带姓氏的名称     * <span class="doctag">@param</span> firstName 姓氏     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">(String firstName)</span></span>&#123;        <span class="keyword">synchronized</span>(SynchronizedTest.class)&#123;            System.out.println(firstName+myName);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized的同步代码块用在任意实例对象上，锁住的就是配置的实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;    <span class="keyword">private</span> String lastName;    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> lastName;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;        <span class="keyword">this</span>.lastName = lastName;    &#125;    <span class="comment">/**     * 带姓氏的名称     * <span class="doctag">@param</span> firstName 姓氏     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">(String firstName)</span></span>&#123;        <span class="keyword">synchronized</span>(lastName)&#123;            System.out.println(firstName+lastName);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h3><p>先进行反编译:</p>
<ul>
<li>在执行<code>monitorenter</code>指令的时候，首先要去尝试获取对象的锁（<strong>获取对象锁的过程，其实是获取monitor对象的所有权的过程</strong>）。</li>
<li>如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一。</li>
<li>而在执行<code>monitorexit</code>指令时会将锁计数器减一。一旦计数器的值为零，锁随即就被释放了。</li>
<li>如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</li>
</ul>
<h3 id="monitor对象"><a href="#monitor对象" class="headerlink" title="monitor对象"></a>monitor对象</h3><p>我在上面说了，获取对象锁的过程，其实是获取monitor对象的所有权的过程。哪个线程持有了monitor对象，那么哪个线程就获得了锁，获得了锁的对象可以重复的来获取monitor对象，但是同一个线程每获取一次monitor对象所有权锁计数就加一，在解锁的时候也是需要将锁计数减成0才算真的释放了锁。<br>monitor对象，我们其实在Java的反编译文件中并没有看到。这个对象是存放在对象头中的。</p>
<p>这里要说明一下，锁升级的过程是不可逆的。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>上面在介绍对象头的时候，说到了对象头中包含的内容了，其中有一个就是偏向锁的线程ID，它代表的意思就是说，如果当一个线程获取到了锁之后，锁的标志计数器就会+1，并且把这个线程的id存储在锁住的这个对象的对象头上面。<br><strong>这个过程是通过CAS来实现的，每次线程进入都是无锁的，当执行CAS成功后，直接将锁的标志计数+1（持有偏向锁的线程以后每次进入锁时不做任何操作，标志计数直接+1），这个时候其他线程再进来时，执行CAS就会失败，也就是获取锁失败。</strong></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁还是和对象头的第一部分（Mark Word）相关。</p>
<ul>
<li>在代码即将进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用户存储锁对象目前的Mark Word的拷贝。</li>
<li>然后JVM将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，说明线程获取锁成功，并执行后面的同步操作。</li>
<li>如果这个更新动作失败了，说明锁对象已经被其他线程抢占了，那轻量级锁不在有效，必须膨胀为重量级锁。此时被锁住的对象的标志变为重量级锁的标志。</li>
</ul>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>当轻量级锁获取失败后，就会升级为重量级锁，但是重量级锁之前也介绍了是很耗资源的，JVM开发团队注意到许多程序上，共享数据的二锁定状态只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得。<br><strong>所以想到了一个策略，那就是当线程请求一个已经被锁住的对象时，可以让未获取锁的线程“稍等一会”，但不放弃处理器执行时间，只需要让线程执行一个忙循环（自旋），这就是所谓的自旋锁。</strong><br>自旋锁在JDK1.4.2中引入，默认关闭，可以通过-XX:UserSpinning参数来开启，默认自旋次数是10次，用户可以自定义次数，配置参数是-XX:PreBockSpin。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Synchronized减重的过程，通常被称为锁膨胀或是锁升级的过程。<br>主要步骤是：</p>
<ul>
<li>先是通过偏向锁来获取锁，解决了虽然有同步但无竞争的场景下锁的消耗。</li>
<li>再是通过对象头的Mark Word来实现的轻量级锁，通过轻量级锁如果还有竞争，那么继续升级。</li>
<li>升级为自旋锁，如果达到最大自旋次数了，那么就直接升级为重量级锁，所有未获取锁的线程都阻塞等待。</li>
</ul>
<h2 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h2><p>过</p>
<h2 id="对索引有什么了解"><a href="#对索引有什么了解" class="headerlink" title="对索引有什么了解"></a>对索引有什么了解</h2><p>索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。</p>
<p>索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。</p>
<p>索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。</p>
<h2 id="建立索引的策略"><a href="#建立索引的策略" class="headerlink" title="建立索引的策略"></a>建立索引的策略</h2><h3 id="适合建索引的字段："><a href="#适合建索引的字段：" class="headerlink" title="适合建索引的字段："></a>适合建索引的字段：</h3><ol>
<li>经常被查询的字段，即在where子句中出现的字段</li>
<li>在分组的字段，即在group by子句中出现的字段</li>
<li>存在依赖关系的子表和父表之间的联合查询，即主键或外键字段</li>
<li>设置唯一完整性约束的字段</li>
</ol>
<h3 id="不适合建索引字段："><a href="#不适合建索引字段：" class="headerlink" title="不适合建索引字段："></a>不适合建索引字段：</h3><ol>
<li>在查询中很少被使用的字段</li>
<li>拥有许多重复值的字段</li>
</ol>
<h2 id="索引有哪些类型"><a href="#索引有哪些类型" class="headerlink" title="索引有哪些类型"></a>索引有哪些类型</h2><p>索引类型<br>Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。</p>
<h3 id="FULLTEXT"><a href="#FULLTEXT" class="headerlink" title="FULLTEXT"></a>FULLTEXT</h3><p>即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。</p>
<p>全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%”这类针对文本的模糊查询效率较低的问题。</p>
<h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><p>由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。</p>
<p>HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</p>
<p><strong>哈希索引的限制：</strong></p>
<p>1.哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引的值来避免读取行</p>
<p>2.哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序</p>
<p>3.哈希索引不支持部分索引匹配查找(因为哈希索引始终是使用索引列的全部内容来计算哈希值的)</p>
<p>4.哈希索引只支持等值查询，包括= ，in</p>
<p>5.当出现哈希冲突(不同的索引列值却有相同的哈希值)时，存储引擎必须遍历链表中所有的行指针，逐个比较直至找到符合条件的行</p>
<p>6.如果哈希冲突很多，则索引维护操作的代价会很高</p>
<h3 id="BTREE"><a href="#BTREE" class="headerlink" title="BTREE"></a>BTREE</h3><p>BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</p>
<h3 id="RTREE"><a href="#RTREE" class="headerlink" title="RTREE"></a>RTREE</h3><p>RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。</p>
<p>//myisam支持空间索引，可以用作地理数据存储，R-tree无须前缀索引。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。</p>
<p>相对于BTREE，RTREE的优势在于范围查找。</p>
<h2 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h2><ul>
<li>普通索引：仅加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>
<li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索</li>
</ul>
<h2 id="什么时候用聚集索引"><a href="#什么时候用聚集索引" class="headerlink" title="什么时候用聚集索引"></a>什么时候用聚集索引</h2><p><strong>最左前缀原则：</strong></p>
<p>顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上，</p>
<p>注：如果第一个字段是范围查询需要单独建一个索引</p>
<p>注：在创建联合索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。这样的话扩展性较好，比如 userid 经常需要作为查询条件，而 mobile 不常常用，则需要把 userid 放在联合索引的第一位置，即最左边</p>
<p><strong>联合索引本质：</strong></p>
<p>当创建(a,b,c)联合索引时，相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引</p>
<p>想要索引生效的话,只能使用 a，和a,b，和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！</p>
<p><strong>联合索引总结：</strong></p>
<p>需要加索引的字段，要在where条件中；</p>
<p>数据量少的字段不需要加索引（因为建索引有开销，速度反而慢）；</p>
<p>如果where条件中是or关系，加索引不起作用；</p>
<p>联合索引比每个列分别建索引更有优势，因为建索引有开销，顺序也要注意，一般不超过7，8个，应该将严格的索引放在前面，这样筛选力度会更大，效率更高。</p>
<h2 id="说一下每个层的主要协议"><a href="#说一下每个层的主要协议" class="headerlink" title="说一下每个层的主要协议"></a>说一下每个层的主要协议</h2><p>协议分别有：</p>
<p>1、物理层协议有：EIA/TIA-232， EIA/TIA-499，V.35， V.24，RJ45， Ethernet， 802.3 </p>
<p>2、数据链路层协议有：Frame Relay，HDLC，PPP， IEEE 802.3/802.2</p>
<p>3、网络层协议有：IP，IPX，AppleTalk DDP </p>
<p>4、传输层协议有：TCP，UDP，SPX</p>
<p>5、会话层协议有：RPC，SQL，NFS，NetBIOS，names，AppleTalk</p>
<p>6、表示层协议有：TIFF，GIF，JPEG，PICT，ASCII，EBCDIC，encryption</p>
<p>7、应用层协议有：FTP，WWW，Telnet，NFS，SMTP，Gateway，SNMP1</p>
<p><img src="https://iknow-pic.cdn.bcebos.com/472309f790529822a5d75652daca7bcb0b46d4bf?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="img"></p>
<h2 id="Socket属于哪一层"><a href="#Socket属于哪一层" class="headerlink" title="Socket属于哪一层"></a>Socket属于哪一层</h2><p>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<h2 id="TCP与UDP的区别，使用场景"><a href="#TCP与UDP的区别，使用场景" class="headerlink" title="TCP与UDP的区别，使用场景"></a>TCP与UDP的区别，使用场景</h2><p>过</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/10/Alimianjing210510/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/Alimianjing210510/" class="post-title-link" itemprop="url">阿里面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-10 21:41:00 / 修改时间：21:43:39" itemprop="dateCreated datePublished" datetime="2021-05-10T21:41:00+08:00">2021-05-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="阿里一面"><a href="#阿里一面" class="headerlink" title="阿里一面"></a>阿里一面</h2><h2 id="图的数据结构，讲一下遍历方式"><a href="#图的数据结构，讲一下遍历方式" class="headerlink" title="图的数据结构，讲一下遍历方式"></a>图的数据结构，讲一下遍历方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无向简单图的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hoaven</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    List&lt;GraphNode&lt;T&gt;&gt; neighborList;</span><br><span class="line">    <span class="keyword">boolean</span> visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        neighborList = <span class="keyword">new</span> ArrayList&lt;GraphNode&lt;T&gt;&gt;();</span><br><span class="line">        visited = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(GraphNode&lt;T&gt; node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.equals(node.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还原图中所有节点为未访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreVisited</span><span class="params">()</span></span>&#123;</span><br><span class="line">        restoreVisited(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还原node的图所有节点为未访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreVisited</span><span class="params">(GraphNode&lt;T&gt; node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.visited)&#123;</span><br><span class="line">            node.visited = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;GraphNode&lt;T&gt;&gt; neighbors = node.neighborList;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; neighbors.size(); i++)&#123;</span><br><span class="line">            restoreVisited(neighbors.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体见：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hehuanchun0311/article/details/80168109">数据结构–图(Java版)</a></p>
<h2 id="常用的排序方式（稳定，时间复杂度，空间复杂度）"><a href="#常用的排序方式（稳定，时间复杂度，空间复杂度）" class="headerlink" title="常用的排序方式（稳定，时间复杂度，空间复杂度）"></a>常用的排序方式（稳定，时间复杂度，空间复杂度）</h2><p><img src="https://pic.leetcode-cn.com/1607322938-FExsoY-20201207142419.png" alt="image-20201207142404505"></p>
<p>1）当 n 较大，则应采用时间复杂度为 O(nlog2n)的排序方法：快速排序、堆排序或归并排序。</p>
<p>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分 布时，快速排序的平均时间最短；</p>
<p>堆排序 ：堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，也就是排序效率稳定。</p>
<p>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的 序列，然后再合并，在效率上将有所提高。</p>
<p>2）当 n 较大，内存空间允许，且要求稳定性 =&gt; 归并排序</p>
<p>3） 当 n 较小，可采用直接插入或直接选择排序。</p>
<h2 id="什么时候用到堆排序，快排"><a href="#什么时候用到堆排序，快排" class="headerlink" title="什么时候用到堆排序，快排"></a>什么时候用到堆排序，快排</h2><pre><code> 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
</code></pre>
<p>  　堆排序(优先队列)所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。</p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><ol>
<li><p>开放定址法：</p>
<ul>
<li>线性探测再散列 di = 1 , 2 , 3 , … , m-1</li>
<li>平方探测再散列 di = 1 , -1 , 2, -2 , 3 , -3 , … , k , -k(取相应数的平方)</li>
<li>随机探测再散列 di 是一组伪随机数列</li>
</ul>
</li>
<li><p>链接法：</p>
<p>将所有哈希地址相同的记录都链接在同一链表中。</p>
</li>
<li><p>再哈希法：</p>
<p>再次进行另一个哈希函数计算，直到冲突不发生。</p>
</li>
<li><p>建立公共溢出区</p>
<p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>
</li>
</ol>
<h2 id="了解动态规划吗"><a href="#了解动态规划吗" class="headerlink" title="了解动态规划吗"></a>了解动态规划吗</h2><p>动态规划与分治方法类似，都是通过组合子问题的解来来求解原问题的。再来了解一下什么是分治方法，以及这两者之间的差别，分治方法将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。而动态规划与之相反，动态规划应用与子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治方法会做许多不必要的工作，他会反复求解那些公共子子问题。而动态规划对于每一个子子问题只求解一次，将其解保存在一个表格里面，从而无需每次求解一个子子问题时都重新计算，避免了不必要的计算工作。<br>  动态规划的应用场景：<br>动态规划方法一般用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望找到具有最优值的解，我们称这样的解为问题的一个最优解，而不是最优解，因为可能有多个解都达到最优值。<br>   我们解决动态规划问题一般分为四步：<br>1、定义一个状态，这是一个最优解的结构特征<br>2、进行状态递推，得到递推公式<br>3、进行初始化<br>4、返回结果</p>
<h2 id="讲一下数据库索引，数据库索引用什么实现，为什么不用B树，不用hashmap"><a href="#讲一下数据库索引，数据库索引用什么实现，为什么不用B树，不用hashmap" class="headerlink" title="讲一下数据库索引，数据库索引用什么实现，为什么不用B树，不用hashmap"></a>讲一下数据库索引，数据库索引用什么实现，为什么不用B树，不用hashmap</h2><p>过</p>
<h2 id="建立abc的联合索引，b-1能命中索引吗"><a href="#建立abc的联合索引，b-1能命中索引吗" class="headerlink" title="建立abc的联合索引，b=1能命中索引吗"></a>建立abc的联合索引，b=1能命中索引吗</h2><p>为什么要用联合索引？</p>
<p>对于查询语句“SELECT T.* FROM T WHERE T.c1=1 AND T.c3=2”涉及到两列，这个时候我们一般采用一个联合索引(c1, c3)；而不用两个单列索引，这是因为一条查询语句往往应为mysql优化器的关系只用一个索引，就算你有两个索引，他也只用一个；在只用一个的基础之上，联合索引是会比单列索引要快的；</p>
<p>下面讲讲联合索引的使用规则和哪些情况会命中不了联合索引</p>
<p>示例如下。首先创建表： CREATE TABLE T (c1 INT, c2 VARCHAR(9), c3 INT, PRIMARY KEY(c1, c3)); 这样就建立了一个联合索引：c1,c3</p>
<p>触发联合索引是有条件的： 1、使用联合索引的全部索引键，可触发索引的使用。 例如：SELECT T.* FROM T WHERE T.c1=1 AND T.c3=2</p>
<p>2、使用联合索引的前缀部分索引键，如“key_part_1 常量”，可触发索引的使用。 例如：SELECT T.* FROM T WHERE T.c1=1</p>
<p>3、使用部分索引键，但不是联合索引的前缀部分，如“key_part_2 常量”，不可触发索引的使用。 例如：SELECT T.* FROM T WHERE T.c3=1</p>
<p>4、使用联合索引的全部索引键，但索引键不是AND操作，不可触发索引的使用。 例如：SELECT T.* FROM T WHERE T.c3=2 OR T.c1=1</p>
<h2 id="索引的命中规则知道吗"><a href="#索引的命中规则知道吗" class="headerlink" title="索引的命中规则知道吗"></a>索引的命中规则知道吗</h2><p><strong>索引****命中规则</strong>详解：</p>
<p>t这张表 a,b,c 三个字段组成组合<strong>索引</strong></p>
<ol>
<li> <strong>索引****命中规则</strong>详解：</li>
<li> t这张表 a,b,c 三个字段组成组合<strong>索引</strong></li>
<li> select * from t where a=? and b=? and c=? 全命中</li>
<li> select * from t where c=? and b=? and a=? 全命中 解析MySQL<strong>的</strong>查询优化器会自动调整where子句<strong>的</strong>条件顺序以使用适合<strong>的****索引</strong></li>
<li> select * from t where a=? 命中a 解析:最左前缀匹配</li>
<li> select * from t where a=? and b=? 命中a和b 解析:最左前缀匹配</li>
<li> select * from t where a=? or b=? 一个没命中 解析or无法命中</li>
<li> select * from t where a=? and c=? 命中a 解析:最左前缀匹配，中间没有则无法使用<strong>索引</strong></li>
<li> select * from t where a=? and b in ( x, y, z) and c=? 全部命中 in精确匹配可以使用<strong>索引</strong></li>
<li> select * from t where b=? 一个没命中 解析:最左前缀匹配原则</li>
<li> select * from t where b=? and c=? 一个没命中 解析:最左前缀匹配原则</li>
<li> select * from t where a=? and b like ‘xxx%’ 命中a</li>
<li> select * from t where a=? and b like ‘%xxx’ 命中a和b</li>
<li> select * from t where a&lt;? and b=? 命中a 解析这个是范围查找</li>
<li> select * from t where a between ? and ? and b=? 命中a和b 解析BETWEEN相当于in操作是精确匹配</li>
<li> select * from t where a between ? and ? and b=? and c and between ? and ? 全部命解析中同上</li>
<li> select * from where a-1=? 函数和表达式无法命中<strong>索引</strong></li>
</ol>
<h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><p>事务就是一个对数据库操作的序列，是一个不可分割的工作单位，要不这个序列里面的操作全部执行，要不全部不执行。<br><strong>特性：</strong>原子性 （Atomicity） 持久性（Durability） 一致性（Consistency） 隔离性（Isolation）</p>
<h2 id="什么叫不可重复读"><a href="#什么叫不可重复读" class="headerlink" title="什么叫不可重复读"></a>什么叫不可重复读</h2><p>就是在一个事务范围内，两次相同的查询会返回两个不同的数据,是因为在此间隔内有其他事务对数据进行了修改。如下图：</p>
<p><img src="https://img-blog.csdn.net/20180805160649484?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDQ3NDE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类加载的过程<br>我们编写的java文件都是保存着业务逻辑代码。java编译器将 .java 文件编译成扩展名为 .class 的文件。.class 文件中保存着java转换后，虚拟机将要执行的指令。当需要某个类的时候，java虚拟机会加载 .class 文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为类的加载。</p>
<p>加载<br>类加载过程的一个阶段，ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象。</p>
<p>验证<br>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。</p>
<p>准备<br>为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。</p>
<p>解析<br>这里主要的任务是把常量池中的符号引用替换成直接引用</p>
<p>初始化<br>这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）<br>具体参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40236948/article/details/88072698">Java类加载机制</a></p>
<h2 id="为什么使用双亲委派机制"><a href="#为什么使用双亲委派机制" class="headerlink" title="为什么使用双亲委派机制"></a>为什么使用双亲委派机制</h2><p>过</p>
<h2 id="forName和loaderClass区别"><a href="#forName和loaderClass区别" class="headerlink" title="forName和loaderClass区别"></a>forName和loaderClass区别</h2><ul>
<li>Class.forName()得到的class是已经初始化完成的。</li>
<li>Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。</li>
</ul>
<h2 id="如何破坏双亲委派机制"><a href="#如何破坏双亲委派机制" class="headerlink" title="如何破坏双亲委派机制"></a>如何破坏双亲委派机制</h2><ol>
<li>自定义类加载器，重写ClassLoader类的loadClass()方法</li>
<li>使用线程上下文类加载器；</li>
</ol>
<h2 id="写代码中出现的异常能都说一下吗"><a href="#写代码中出现的异常能都说一下吗" class="headerlink" title="写代码中出现的异常能都说一下吗"></a>写代码中出现的异常能都说一下吗</h2><p>过</p>
<h2 id="有写过web项目"><a href="#有写过web项目" class="headerlink" title="有写过web项目"></a>有写过web项目</h2><p>过</p>
<h2 id="对Java并发了解吗"><a href="#对Java并发了解吗" class="headerlink" title="对Java并发了解吗"></a>对Java并发了解吗</h2><p>了解</p>
<h2 id="线程池有哪几种，分别在哪些场景能使用"><a href="#线程池有哪几种，分别在哪些场景能使用" class="headerlink" title="线程池有哪几种，分别在哪些场景能使用"></a>线程池有哪几种，分别在哪些场景能使用</h2><p>4种。</p>
<p>newCachedThreadPool：</p>
<ul>
<li>底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</li>
<li>通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</li>
<li>适用：执行很多短期异步的小程序或者负载较轻的服务器</li>
</ul>
<p>newFixedThreadPool：</p>
<ul>
<li>底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列</li>
<li>通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</li>
<li>适用：执行长期的任务，性能好很多</li>
</ul>
<p>newSingleThreadExecutor:</p>
<ul>
<li>底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列</li>
<li>通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</li>
<li>适用：一个任务一个任务执行的场景</li>
</ul>
<p>NewScheduledThreadPool:</p>
<ul>
<li>底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列</li>
<li>通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构</li>
<li>适用：周期性执行任务的场景</li>
</ul>
<p>线程池任务执行流程：</p>
<ol>
<li>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li>
<li>当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行</li>
<li>当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务</li>
<li>当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理</li>
<li>当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程</li>
<li>当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</li>
</ol>
<h2 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h2><p>为了减少创建和销毁线程的次数，让每个线程可以多次使用,可根据系统情况<strong>调整执行</strong>的线程数量，防止消耗过多内存,所以我们可以使用线程池.</p>
<h2 id="线程建很多是不是就能解决一切问题"><a href="#线程建很多是不是就能解决一切问题" class="headerlink" title="线程建很多是不是就能解决一切问题"></a>线程建很多是不是就能解决一切问题</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pangzhaowen/article/details/106141365">面试总被问，创建多少个线程合适？真的越多越好吗</a></p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>过</p>
<h2 id="讲一下BIO-AIO-NIO"><a href="#讲一下BIO-AIO-NIO" class="headerlink" title="讲一下BIO,AIO,NIO"></a>讲一下BIO,AIO,NIO</h2><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h2 id="什么情况用BIO，AIO-NIO"><a href="#什么情况用BIO，AIO-NIO" class="headerlink" title="什么情况用BIO，AIO,NIO"></a>什么情况用BIO，AIO,NIO</h2><h1 id="阿里二面"><a href="#阿里二面" class="headerlink" title="阿里二面"></a>阿里二面</h1><h2 id="讲一下对于socket的了解，瓶颈是什么"><a href="#讲一下对于socket的了解，瓶颈是什么" class="headerlink" title="讲一下对于socket的了解，瓶颈是什么"></a>讲一下对于socket的了解，瓶颈是什么</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41563161/article/details/104779605">Socket详解</a></p>
<h2 id="怎么设计数据库的表结构（数据库的反向设计）"><a href="#怎么设计数据库的表结构（数据库的反向设计）" class="headerlink" title="怎么设计数据库的表结构（数据库的反向设计）"></a>怎么设计数据库的表结构（数据库的反向设计）</h2><p>真就不清楚</p>
<h2 id="客户端特别多连接服务端会发生什么，崩溃的原因是什么"><a href="#客户端特别多连接服务端会发生什么，崩溃的原因是什么" class="headerlink" title="客户端特别多连接服务端会发生什么，崩溃的原因是什么"></a>客户端特别多连接服务端会发生什么，崩溃的原因是什么</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/10/datastrcture210410/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/datastrcture210410/" class="post-title-link" itemprop="url">数据结构面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-10 15:09:00 / 修改时间：15:15:20" itemprop="dateCreated datePublished" datetime="2021-04-10T15:09:00+08:00">2021-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>性质 1：节点非红即黑。</p>
<p>性质 2：根节点永远是黑色的。</p>
<p>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</p>
<p>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</p>
<p>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>
<p>红黑树最重要的性质：从根到叶子的最长的可能路径小于等于最短的可能路径的两倍长。 红黑树并不是真正意义上的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。(对于AVL树，任何一个节点的两个子树高度差不会超过 1；对于红黑树，则是不会相差两倍以上)对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。对于红黑树，插入，删除，查找的复杂度都是 O(log N)。任何不平衡都会在3次旋转之内解决。</p>
<h2 id="红黑树插入问题"><a href="#红黑树插入问题" class="headerlink" title="红黑树插入问题"></a>红黑树插入问题</h2><p>假设我们插入的新节点为 X</p>
<ol>
<li>将新插入的节点标记为红色</li>
<li>如果 X 是根结点(root)，则标记为黑色</li>
<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>
</ol>
<ul>
<li><p>3.1 如果 X 的 uncle (叔叔) 是红色</p>
</li>
<li><ul>
<li>3.1.1 将 parent 和 uncle 标记为黑色</li>
<li>3.1.2 将 grand parent (祖父) 标记为红色</li>
<li>3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li>
</ul>
</li>
</ul>
<p>话不多说，看下图</p>
<p><img src="https://pic4.zhimg.com/80/v2-1d35b926316397d82c267593042f8c3f_720w.jpg" alt="img"></p>
<p>跟着上面的公式走:</p>
<ol>
<li>将新插入的 X 节点标记为红色</li>
<li>发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」</li>
<li>发现 X 的 uncle (U) 同样为红色</li>
<li>将 P 和 U 标记为黑色</li>
<li>将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3</li>
<li>发现 G 是根结点，标记为黑色</li>
<li>结束</li>
</ol>
<p>刚刚说了 X 的 uncle 是红色的情况，接下来要说是<strong>黑色</strong>的情况</p>
<ol>
<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>
</ol>
<ul>
<li><p>3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理</p>
</li>
<li><ul>
<li>3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)</li>
<li>3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)</li>
<li>3.2.3 右右 (和 3.2.1 镜像过来，恰好相反)</li>
<li>3.2.4 右左 (和 3.2.2 镜像过来，恰好相 【】【反)</li>
</ul>
</li>
</ul>
<p>当出现 uncle 是黑色的时候我们第一步要考虑的是 <strong>旋转</strong> ，这里先请小伙伴<strong>不要关注红黑树的第 4 条规则</strong>，主要是为了演示如何旋转的，来一点点看，不要看图就慌，有解释的 :</p>
<p><img src="https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg" alt="img"></p>
<h3 id="左左"><a href="#左左" class="headerlink" title="左左"></a>左左</h3><p>这种情况很简单，想象这是一根绳子，手提起 P 节点，然后变色即可</p>
<p><img src="https://pic1.zhimg.com/80/v2-9e139a0f8b4a5e00ca8e643e2130403c_720w.jpg" alt="img"></p>
<h3 id="左右"><a href="#左右" class="headerlink" title="左右"></a>左右</h3><p>左旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的左孩子，然后再应用 <strong>左左情况</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-3fb33fbb3a42e34ed8a058a047a44cc3_720w.jpg" alt="img"></p>
<h3 id="右右"><a href="#右右" class="headerlink" title="右右"></a>右右</h3><p>与左左情况一样，想象成一根绳子</p>
<p><img src="https://pic4.zhimg.com/80/v2-62a42ada09cb4547191aa4b9051c7c23_720w.jpg" alt="img"></p>
<h3 id="右左"><a href="#右左" class="headerlink" title="右左"></a>右左</h3><p>右旋: 使 X 的父节点 P 被 X 取代，同时父节点 P 成为 X 的右孩子，然后再应用 <strong>右右情况</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-210d1400ea1b098dfe1582589a6064c3_720w.jpg" alt="img"></p>
<h1 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h1><p>ArrayList扩容发生在add()方法调用的时候，下面是add()方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//扩容</span></span><br><span class="line"> ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">//Increments modCount!!</span></span><br><span class="line"> elementData[size++] = e; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line"> &#125;         </span><br></pre></td></tr></table></figure>

<p>ArrayList扩容的关键方法grow():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到ArrayList中elementData数组的内存空间长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容至原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//若预设值大于默认的最大值检查是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间</span></span><br><span class="line">    <span class="comment">// 并将elementData的数据复制到新的内存空间</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;          </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="HashMap-的底层实现、JDK-1-8-的时候为啥将链表转换成红黑树？HashMap-的负载因子"><a href="#HashMap-的底层实现、JDK-1-8-的时候为啥将链表转换成红黑树？HashMap-的负载因子" class="headerlink" title="HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子"></a>HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子</h1><p>HashMap是用<strong>数组+链表+红黑树</strong>进行实现的，当添加一个元素（key-value）时，就首先计 算元素key的hash值，并根据hash值来确定插入数组中的位置，但是可能存在其他元素已经 被放在数组同一位置了，这个时候便使用链表来解决哈希冲突，当链表长度太长的时候，便 将链表转换为红黑树来提高搜索的效率。</p>
<p>HashMap是基于拉链法实现的一个散列表，内部由数组和链表和红黑树实现。</p>
<ol>
<li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。</li>
<li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造传入。</li>
<li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（&gt;=8）， 会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（&lt;=6），又会将红黑树转换回单向链表提高性能，这里是一个平衡点。</li>
</ol>
<h1 id="有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？-线程安全的集合类"><a href="#有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？-线程安全的集合类" class="headerlink" title="有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？ 线程安全的集合类."></a>有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？ 线程安全的集合类.</h1><p>Vector Stack Hashtable</p>
<p>java.util.concurrent包下所有的集合类（ConcurrentHashMap，CopyOnWriteArrayList和CopyOnWriteArraySet等）</p>
<h1 id="HashMap-多线程操作导致死循环问题异常"><a href="#HashMap-多线程操作导致死循环问题异常" class="headerlink" title="HashMap 多线程操作导致死循环问题异常"></a>HashMap 多线程操作导致死循环问题异常</h1><p>主要原因在于并发下的 rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/08/HuaweiMainjing210408/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/08/HuaweiMainjing210408/" class="post-title-link" itemprop="url">华为面经体验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-08 20:13:00" itemprop="dateCreated datePublished" datetime="2021-04-08T20:13:00+08:00">2021-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-11 22:32:42" itemprop="dateModified" datetime="2021-05-11T22:32:42+08:00">2021-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="http-协议如何保证可靠性"><a href="#http-协议如何保证可靠性" class="headerlink" title="http 协议如何保证可靠性"></a>http 协议如何保证可靠性</h1><p><strong>重要的数据，要加密</strong>，比如用户名密码，我们需要加密，这样即使被抓包监听，他们也不知道原始数据是什么（如果简单的md5，是可以暴力破解），所以加密方法越复杂越安全，根据需要，常见的是 md5(不可逆)，aes（可逆），自由组合吧,你还可以加一些特殊字符啊，没有做不到只有想不到， 举例：username = aes(username), pwd = MD5(pwd + username);。。。。。</p>
<p><strong>非重要数据，要签名</strong>，签名的目的是为了防止篡改，比如<a target="_blank" rel="noopener" href="http://www.xxx.com/getnews?id=1%EF%BC%8C%E8%8E%B7%E5%8F%96id%E4%B8%BA1%E7%9A%84%E6%96%B0%E9%97%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E7%AD%BE%E5%90%8D%E9%82%A3%E4%B9%88%E9%80%9A%E8%BF%87id=2,%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%962%E7%9A%84%E5%86%85%E5%AE%B9%E7%AD%89%E7%AD%89%E3%80%82%E6%80%8E%E6%A0%B7%E7%AD%BE%E5%90%8D%E5%91%A2%EF%BC%9F%E9%80%9A%E5%B8%B8%E4%BD%BF%E7%94%A8sign%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8E%9F%E9%93%BE%E6%8E%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%E5%8A%A0%E4%B8%80%E4%B8%AAsign%E5%8F%82%E6%95%B0%EF%BC%8Csign=md5(id=1)%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E5%8F%97%E5%88%B0%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%AA%8C%E8%AF%81sign%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8Emd5(id=1)%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%AD%89%E4%BA%8E%E8%AF%B4%E6%98%8E%E6%AD%A3%E5%B8%B8%E8%AF%B7%E6%B1%82%E3%80%82%E8%BF%99%E4%BC%9A%E6%9C%89%E4%B8%AA%E5%BC%8A%E7%AB%AF%EF%BC%8C%E5%81%87%E5%A6%82%E8%A7%84%E5%88%99%E8%A2%AB%E5%8F%91%E7%8E%B0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E4%BC%9A%E8%A2%AB%E4%BC%AA%E9%80%A0%EF%BC%8C%E6%89%80%E4%BB%A5%E9%80%82%E5%BD%93%E5%A4%8D%E6%9D%82%E4%B8%80%E4%BA%9B%EF%BC%8C%E8%BF%98%E6%98%AF%E8%83%BD%E5%A4%9F%E6%8F%90%E9%AB%98%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E3%80%82">http://www.xxx.com/getnews?id=1，获取id为1的新闻，如果不签名那么通过id=2,就可以获取2的内容等等。怎样签名呢？通常使用sign，比如原链接请求的时候加一个sign参数，sign=md5(id=1)，服务器接受到请求，验证sign是否等于md5(id=1)，如果等于说明正常请求。这会有个弊端，假如规则被发现，那么就会被伪造，所以适当复杂一些，还是能够提高安全性的。</a></p>
<p><strong>登录态怎么做，</strong>http是无状态的，也就是服务器没法自己判断两个请求是否有联系，那么登录之后，以后的接口怎么判定是否登录呢，简单的做法，在数据库中存一个token字段（名字随意），当用户调用登陆接口成功的时候，就将该字段设一个值，（比如aes(过期时间)），同时返回给前端，以后每次前端请求带上该值，服务器首先校验是否过期，其次校验是否正确，不通过就让其登陆。（redis 做这个很方便哦，key有过期时间）。</p>
<p>具体可参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/l18848956739/article/details/81011194">如何保证http传输安全性</a> </p>
<p><a href="%5Bhttps://hellogoogle.blog.csdn.net/article/details/94440881?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1329187.12416.16178842483851657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control%5D(https://hellogoogle.blog.csdn.net/article/details/94440881?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control&dist_request_id=1329187.12416.16178842483851657&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.control)">【Java】【通信安全】怎么保证http请求的安全性</a></p>
<h1 id="IP-TCP-UDP首部详解"><a href="#IP-TCP-UDP首部详解" class="headerlink" title="IP,TCP,UDP首部详解"></a>IP,TCP,UDP首部详解</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><img src="https://img-blog.csdn.net/20160916110056051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="https://img-blog.csdn.net/20160916110125505?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="https://img-blog.csdn.net/20160916110144427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39584315/article/details/79387811?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">IP、TCP、UDP首部详解</a></p>
<h1 id="多线程相关面试题"><a href="#多线程相关面试题" class="headerlink" title="多线程相关面试题"></a>多线程相关面试题</h1><p>具体可参考：</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/weibanggang/p/9470462.html">多线程面试题</a></p>
<h1 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h1><p>何时使用多线程技术,何时避免用它,是我们需要掌握的重要课题。多线程技术是一把双刃剑,在使用时需要充分考虑它的优缺点。<br>多线程处理可以同时运行多个线程。由于多线程应用程序将程序划分成多个独立的任务,因此可以在以下方面显著提高性能:<br>(1)多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态;</p>
<p>(2)当前没有进行处理的任务时可以将处理器时间让给其它任务;</p>
<p>(3)占用大量处理时间的任务可以定期将处理器时间让给其它任务;</p>
<p>(4)可以随时停止任务;</p>
<p>(5)可以分别设置各个任务的优先级以优化性能。</p>
<p> 是否需要创建多个线程取决于各种因素。在以下情况下,最适合采用多线程处理:<br>(1)耗时或大量占用处理器的任务阻塞用户界面操作;</p>
<p>(2)各个任务必须等待外部资源 (如远程文件或 Internet连接)。</p>
<p>同样的 ,多线程也存在许多缺点 ,在考虑多线程时需要进行充分的考虑。多线程的主要缺点包括:<br>(1)等候使用共享资源时造成程序的运行速度变慢。这些共享资源主要是独占性的资源 ,如打印机等。</p>
<p>(2)对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担超过一定程度时,多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。</p>
<p>(3)线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。</p>
<p>(4)对公有变量的同时读或写。当多个线程需要对公有变量进行写操作时,后一个线程往往会修改掉前一个线程存放的数据,从而使前一个线程的参数被修改;另外 ,当公用变量的读写操作是非原子性时,在不同的机器上,中断时间的不确定性,会导致数据在一个线程内的操作产生错误,从而产生莫名其妙的错误,而这种错误是程序员无法预知的。</p>
<h1 id="IPv4和-IPv6的地址长度分别是多少位？"><a href="#IPv4和-IPv6的地址长度分别是多少位？" class="headerlink" title="IPv4和 IPv6的地址长度分别是多少位？"></a>IPv4和 IPv6的地址长度分别是多少位？</h1><p>ipv4的地址是32位，用点分十进制表示，每八位划分，也就是四个0~255的十进制数，这是很常见的。</p>
<p>ipv6的地址是128位，一般用点分十六进制表示，每八位划分，也就是十六个0x00~0xff的十六进制数。</p>
<p>IPv6的地址空间更大。IPv4中规定IP地址长度为32,即有2^32-1个地址；而IPv6中IP地址的长度为128,即有2^128-1个地址。夸张点说就是，如果IPV6被广泛应用以后，全世界的每一粒沙子都会有相对应的一个IP地址。</p>
<h1 id="ArrayList和LinkedList的区别，以及应用场景"><a href="#ArrayList和LinkedList的区别，以及应用场景" class="headerlink" title="ArrayList和LinkedList的区别，以及应用场景"></a>ArrayList和LinkedList的区别，以及应用场景</h1><ol>
<li>ArrayList是基于数组实现的，其构造函数为：</li>
</ol>
<p>private transient Object[] elementData;</p>
<p>private int size;</p>
<p>ArryList初始化时，elementData数组大小默认为10；</p>
<p>每次add（）时，先调用ensureCapacity（）保证数组不会溢出，如果此时已满，会扩展为数组length的1.5倍+1，然后用array.copy的方法，将原数组拷贝到新的数组中；</p>
<p>ArrayList线程不安全，Vector方法是同步的，线程安全；</p>
<ol start="2">
<li>LinkedList是基于双链表实现的：</li>
</ol>
<p>Object element;</p>
<p>Entry next,previous;</p>
<p>初始化时，有个header Entry，值为null；</p>
<p>使用header的优点是：在任何一个条目（包括第一个和最后一个）都有一个前置条目和一个后置条目，因此在LinkedList对象的开始或者末尾进行插入操作没有特殊的地方；</p>
<p><strong>使用场景：</strong></p>
<p>如果应用程序对各个索引位置的元素进行大量的存取或删除操作，ArrayList对象要远优于LinkedList对象；<br>如果应用程序主要是对列表进行循环，并且循环时候进行插入或者删除操作，LinkedList对象要远优于ArrayList对象；</p>
<p>ArrayList 与 LinkedList 有什么区别 ?</p>
<p>存储结构上 ArrayList 底层使用数组进行元素的存储，LinkedList 使用双向链表作为存储结构。<br>两者均与允许存储 null 也允许存储重复元素。<br>在性能上 ArrayList 在存储大量元素时候的增删效率 平均低于 LinkedList，因为 ArrayList 在增删的是需要拷贝元素到新的数组，而 LinkedList 只需要将节点前后指针指向改变。<br>在根据角标获取元素的时间效率上ArrayList优于 LinkedList，因为数组本身有存储连续，有 index 角标，而 LinkedList 存储元素离散，需要遍历链表。<br>不要使用 for 循环去遍历 LinkedList 因为效率很低。<br>两者都是线程不安全的，都可以使用 Collections.synchronizedList(List<E> list) 方法生成一个线程安全的 List。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_37130188/article/details/96508345">ArrayList和LinkedList的区别，以及应用场景</a></p>
<h1 id="如何实现线程同步"><a href="#如何实现线程同步" class="headerlink" title="如何实现线程同步"></a>如何实现线程同步</h1><h2 id="Synchronized-用在普通方法和-static-上的区别"><a href="#Synchronized-用在普通方法和-static-上的区别" class="headerlink" title="Synchronized 用在普通方法和 static 上的区别"></a>Synchronized 用在普通方法和 static 上的区别</h2><p>当使用synchronized修饰静态方法时，线程此时获得的锁对象是类的Class对象（<strong>堆内存中只有唯一一个Class对象，因为Class对象是在类加载时产生的，而类加载只执行一次</strong>），因此会锁住整个类，其他线程无法访问该类的同步静态方法，但是可以访问非同步的方法</p>
<p>回答2：</p>
<p>synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；</p>
<p>synchronized修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p>
<p>具体可参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33819764/article/details/81736729">【多线程】实现线程同步的几种方法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43658899/article/details/107230699">Synchronized关键字加在普通方法上和加在静态方法上有什么区别?</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/suger43894/p/12171341.html">synchronized底层原理</a></p>
<h1 id="如何实现线程安全"><a href="#如何实现线程安全" class="headerlink" title="如何实现线程安全"></a>如何实现线程安全</h1><p>线程安全在三个方面体现</p>
<p>1.原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</p>
<p>2.可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</p>
<p>3.有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>
<ul>
<li><strong>原子性</strong>：JDK里面提供了很多atomic类，AtomicInteger,AtomicLong,AtomicBoolean等等。</li>
</ul>
<p>它们是通过CAS完成原子性。</p>
<ul>
<li><strong>原子性：</strong>synchronized是一种同步锁，通过锁实现原子操作。</li>
</ul>
<p>JDK提供锁分两种：一种是synchronized，依赖JVM实现锁，因此在这个关键字作用对象的作用范围内是同一时刻只能有一个线程进行操作；另一种是LOCK，是JDK提供的代码层面的锁，依赖CPU指令，代表性的是ReentrantLock。</p>
<p>synchronized修饰的对象有四种：</p>
<p>（1）修饰代码块，作用于调用的对象；</p>
<p>（2）修饰方法，作用于调用的对象；</p>
<p>（3）修饰静态方法，作用于所有对象；</p>
<p>（4）修饰类，作用于所有对象。</p>
<ul>
<li><p>可见性—volatile</p>
<p>对于可见性，JVM提供了synchronized和volatile。这里我们看volatile。</p>
<p>（1）volatile的可见性是通过内存屏障和禁止重排序实现的</p>
<p>volatile会在写操作时，会在写操作后加一条store屏障指令，将本地内存中的共享变量值刷新到主内存：<br>volatile在进行读操作时，会在读操作前加一条load指令，从内存中读取共享变量：</p>
<p>2）但是volatile不是原子性的，进行++操作不是安全的。执行后发现线程不安全，原因是 执行conut++ 时分成了三步，第一步是取出当前内存 count 值，这时 count 值时最新的，接下来执行了两步操作，分别是 +1 和重新写回主存。假设有两个线程同时在执行 count++ ，两个内存都执行了第一步，比如当前 count 值为 5 ，它们都读到了，然后两个线程分别执行了 +1 ，并写回主存，这样就丢掉了一次加一的操作。</p>
<p>（3）volatile适用的场景</p>
<p>既然volatile不适用于计数，那么volatile适用于哪些场景呢：</p>
<p>\1. 对变量的写操作不依赖于当前值</p>
<p>\2. 该变量没有包含在具有其他变量不变的式子中</p>
</li>
<li><p>有序性</p>
</li>
</ul>
<p>有序性是指，在JMM中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>可以通过volatile、synchronized、lock保证有序性。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40459875/article/details/80290875">Java中如何保证线程安全性</a></p>
<h1 id="Java中如何保证线程安全性"><a href="#Java中如何保证线程安全性" class="headerlink" title="Java中如何保证线程安全性"></a>Java中如何保证线程安全性</h1><p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40459875/article/details/80290875">ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</a></p>
<p>ReentrantLock的介绍<br>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。在java关键字synchronized隐式支持重入性（关于synchronized可以看这篇文章），synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：1. 重入性的实现原理；2. 公平锁和非公平锁。<br>具体参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/102469388">ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</a></p>
<h1 id="MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖"><a href="#MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖" class="headerlink" title="MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖"></a>MySQL中的聚簇索引和非聚簇索引、回表和索引覆盖</h1><h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>前面提到mysql中是通过B+树来组织一张表数据的，而B+树每个节点上都有一个关键字，在进行搜索的时候要从根节点开始查找，直到在叶子节点上查询到对应的关键字和这行数据。那么MySQL中是使用什么作为B+树节点上的关键字呢？答案是主键索引，MySQL是通过主键索引作为B+树节点上的关键字来组织数据的。那么MySQL又是怎样确定使用哪个字段作为主键索引呢？规则如下：</p>
<p>如果建表时指定了主键，则使用主键作为B+树节点的关键字。<br>如果表中没有主键，但是有唯一索引，则会选取一个唯一索引作为关键字。<br>如果既没有主键也没有唯一索引，MySQL会自动生成一个6字节的整型唯一标识作为关键字。<br>也就是说，MySQL每张表中都必须有一个主键索引，使用这个主键索引作为关键字将整张表组织成一棵B+树。</p>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>在MySQL中不管是InnoDB还是MyISAM都是使用B+树来组织表中的数据的。但是在具体实现方法上略有不同。InnoDB的主键索引是聚簇索引，在InnoDB的实现中，把主键作为关键字组织到B+树的各个节点上，而叶子节点上存储的是主键列的值和对应的整行数据。注意这里说的是将表中实际的一整行数据直接存到叶子节点上MyISAM是非聚簇索引，在MyISAM的实现中，叶子节点中存储的是一行数据在磁盘上的地址（可以理解为行号）。所以聚簇索引和非聚簇索引本质的区别就是B+树的叶子节点上存储的是行数据还是行数据的地址（行号）。</p>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="索引的类型："><a href="#索引的类型：" class="headerlink" title="索引的类型："></a>索引的类型：</h2><p><strong>普通索引：</strong><br>最基本的索引，没有任何限制，是我们大多数情况下使用到的索引<br>如何创建：<br>1.直接创建：<br>CREATE INDEX index_name ON table(column(length))<br>2.修改原有表结构：<br>ALTER TABLE table_name ADD INDEX index_name ON(column(length))<br>若是char、varchar类型length可不填，默认字段的实际长度，若是blob、text类型则必须指定长度<br><strong>唯一索引：</strong><br>与普通索引类似，不同之处在于索引列的值必须唯一，但允许有空值(和主键不同之处)，若是联合索引，则列值得组合必须唯一<br>如何创建：<br>1.直接创建：<br>CREATE UNIQUE INDEX index_name ON table(column(length))<br>2.修改原有表结构：<br>ALTER TABLE table ADD UNIQUE index_name ON(column(length))<br><strong>主键索引：</strong><br>不允许有空值，主键索引建立的规则是int优于varchar，一般在剪标的时候创建，最好是与表的其他字段不想关的列或者是业务不相关的列，一般为int且是AUTO_INCREMENT自增长类型的<br><strong>联合索引：</strong><br>通俗地讲就是，索引包含多个字段但只有一个名称，这个才是本篇文章要讲的重点<br>如何创建：<br>CREATE INDEX index_name ON table_name(column1(length1),column2(length2……))<br>一个联合索引根据”最左前缀”会包含多个索引：<br>比如：建立了联合索引(A,B,C)，实际上它包含了3个索引，分别是(A)、(A,B)、(A,B,C)，即包含了联合索引的左子集，这也是为什么我们建了联合索引(A,B,C)，就没必要再单独建一个普通索引(A)的原因<br>建立联合索引的时候，通常需要将其他相关的查询都拿来参考，以便做综合评估，进一步提高索引的使用效率与查询效率<br><strong>联合索引的特点：</strong><br>实例的背景——在T_news表中建立以ischecked、channel_id、audit_time3个字段为联合索引<br>a.最左前缀：索引where时的条件要按照建立索引的时候字段的排列顺序<br>实例如下：<br>where条件单独使用ischecked字段，符合最左前缀，联合索引起作用</p>
<h1 id="创建索引的几个原则"><a href="#创建索引的几个原则" class="headerlink" title="创建索引的几个原则"></a>创建索引的几个原则</h1><p><strong>a.最左前缀匹配原则</strong>，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like ‘%…’)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，若建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整<br><strong>b.=和in可以乱序，</strong>比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会优化成索引可识别的形式<br><strong>c.尽量选择区分度高(cardinality越大越好)的列作为索引</strong>,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，一般需要join的字段都要求是0.1以上，当然，使用场景不同，该值也难以确定<br><strong>d.索引列不能是表达式的一部分或mysql函数的参数</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，因为b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，成本太大，故不能走索引，所以语句应写成create_time = unix_timestamp(’2014-05-29’)<br><strong>e.尽量的扩展索引，</strong>不要新建索引，比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/linbiaorui/article/details/72793527">mysql索引优化</a> </p>
<h1 id="Java语言的特点和特性"><a href="#Java语言的特点和特性" class="headerlink" title="Java语言的特点和特性"></a>Java语言的特点和特性</h1><h2 id="1-Java语言的主要特点："><a href="#1-Java语言的主要特点：" class="headerlink" title="1.　　Java语言的主要特点："></a>1.　　<strong>Java</strong>语言的主要特点：</h2><p>　　　1. 跨平台性</p>
<p>　　　所谓的跨平台性，是指软件可以不受计算机硬件和操作系统的约束而在任意计算机环境下正常运行。这是软件发展的趋势和编程人员追求的目标。之所以这样说，是因为计算机硬件的种类繁多，操作系统也各不相同，不同的用户和公司有自己不同的计算机环境偏好，而软件为了能在这些不同的环境里正常运行，就需要独立于这些平台。而在<strong>Java</strong>语言中， <strong>Java</strong>自带的虚拟机很好地实现了跨平台性。 <strong>Java</strong>源程序代码经过编译后生成二进制的字节码是与平台无关的，但是可被<strong>Java</strong>虚拟机识别的一种机器码指令。 <strong>Java</strong>虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得<strong>Java</strong>语言具备跨平台性。</p>
<p>　　　2. 面向对象</p>
<p>　　　面向对象是指以对象为基本粒度，其下包含属性和方法。对象的说明用属性表达，而通过使用方法来操作这个对象。面向对象技术使得应用程序的开发变得简单易用，节省代码。<strong>Java</strong>是一种面向对象<strong>的语言</strong>，也继承了面向对象的诸多好处，如代码扩展、代码复用等。</p>
<p>　　　3. 安全性</p>
<p>　　　安全性可以分为四个层面，即语言级安全性、编译时安全性、运行时安全性、可执行代码安全性。语言级安全性指<strong>Java</strong>的数据结构是完整的对象，这些封装过的数据类型具有安全性。编译时要进行<strong>Java</strong>语言和语义的检查，保证每个变量对应一个相应的值，编译后生成<strong>Java</strong>类。运行时<strong>Java</strong>类需要类加载器载入www jxzxmr net，并经由字节码校验器校验之后才可以运行。 <strong>Java</strong>类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。</p>
<p>　　　4. 多线程</p>
<p>　　　多线程在操作系统中已得到了最成功的应用。多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于支持事务并发和多任务处理。 <strong>Java</strong>除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。</p>
<p>　　　5. 简单易用</p>
<p>　　　<strong>Java</strong>源代码的书写不拘泥于特定的环境，可以用记事本、文本编辑器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。</p>
<h2 id="2-Java语言的几大特性："><a href="#2-Java语言的几大特性：" class="headerlink" title="2.　　Java语言的几大特性："></a>2.　　<strong>Java</strong>语言的几大<strong>特性</strong>：</h2><p>　　　1.封装： </p>
<p>　　　封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在<strong>java</strong>中通过关键字private，protected和public实现封装。什么是封装？封装把对象的所有组成部分组合在一起，封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 适当的封装可以让程式码更容易理解和维护，也加强了程式码的安全性。</p>
<p>　　　2.继承：</p>
<p>　　　继承是面向对象最显著的一个<strong>特性</strong>。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 <strong>Java</strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。这种技术使得复用以前的代码非常容易，能够大大缩短开发周期，降低开发费用</p>
<p>　　　3.多态： </p>
<p>　　　按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的<strong>特性</strong>以不同的方式运作 多态的话，我觉得是更好的利用了继承这一<strong>特性</strong>，然后为什么能实现多态，因为可以重写父类的方法。说重写可能不清楚，具体来说就是子类父类可以存在分别存在名字相同的属性或者方法，然后可视声明的类去调用相应的方法等。</p>
<p>　　　4.抽象：<br>　　　抽象是通过分析与综合的途径，运用概念在人脑中再现对象的质和本质的方法，我觉得理解成一种方法比较好。就是我们通过对事物的认知，将某一或者一类事物的属性变化成<strong>JAVA</strong>语言能识别的类。</p>
<h1 id="static关键字总结"><a href="#static关键字总结" class="headerlink" title="static关键字总结"></a>static关键字总结</h1><h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a><strong>静态变量和静态方法</strong></h2><p>static关键字最基本的用法是：</p>
<p>1、被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来</p>
<p>2、被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来\</p>
<h2 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a><strong>静态块</strong></h2><p>静态块也是static的重要应用之一。也是用于初始化一个类的时候做操作用的，和静态变量、静态方法一样，<strong>静态块里面的代码只执行一次，且只在初始化类的时候执行</strong>。静态块很简单，不过提三个小细节：</p>
<ol>
<li><p><strong>静态资源的加载顺序是严格按照静态资源的定义顺序来加载的</strong>。</p>
</li>
<li><p><strong>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问</strong>。</p>
</li>
<li><p><strong>静态代码块是严格按照父类静态代码块-&gt;子类静态代码块的顺序加载的，且只加载一次</strong>。</p>
<p>最后一个小例子：</p>
</li>
</ol>
<p>具体可参考：</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/swisszhang/p/9892992.html">static关键字作用总结</a></p>
<h1 id="final的用法"><a href="#final的用法" class="headerlink" title="final的用法"></a>final的用法</h1><h3 id="1-修饰数据"><a href="#1-修饰数据" class="headerlink" title="1.修饰数据"></a>1.修饰数据</h3><h3 id="2-修饰方法参数"><a href="#2-修饰方法参数" class="headerlink" title="2.修饰方法参数"></a>2.修饰方法参数</h3><h3 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3.修饰方法"></a>3.修饰方法</h3><h3 id="4-修饰类"><a href="#4-修饰类" class="headerlink" title="4.修饰类"></a>4.修饰类</h3><p>总结<br>final关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：</p>
<ol>
<li><p>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；</p>
</li>
<li><p>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；</p>
</li>
<li><p>修饰方法，表示该方法无法被重写；</p>
</li>
<li><p>修饰类，表示该类无法被继承。</p>
</li>
</ol>
<p>上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="volatile的第一个特性–保证可见性"><a href="#volatile的第一个特性–保证可见性" class="headerlink" title="volatile的第一个特性–保证可见性"></a>volatile的第一个特性–保证可见性</h2><p>解决内存可见性问题方式的一种是加锁，但是使用锁太笨重，因为它会带来线程上下文的切换开销。Java提供了一种弱形式的同步，也就是volatile关键字。该关键字确保对一个变量的更新对其他线程马上可见。</p>
<p><strong>当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。</strong></p>
<p><strong>当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。</strong></p>
<p>理解volatile保证可见性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。</p>
<h2 id="volatile的第二个特性–保证有序性"><a href="#volatile的第二个特性–保证有序性" class="headerlink" title="volatile的第二个特性–保证有序性"></a>volatile的第二个特性–保证有序性</h2><p>Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。</p>
<blockquote>
<p>什么是数据依赖性？<br>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>
</blockquote>
<p>在单线程下重排序可以保证最终执行结果与程序顺序执行的结果一致，但是在多线程下就会出现问题。</p>
<h2 id="volatile保证有序性和可见性的原理–内存屏障"><a href="#volatile保证有序性和可见性的原理–内存屏障" class="headerlink" title="volatile保证有序性和可见性的原理–内存屏障"></a>volatile保证有序性和可见性的原理–内存屏障</h2><p>前面介绍了volatile关键字的两大特性，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序。</p>
<h2 id="什么是内存屏障"><a href="#什么是内存屏障" class="headerlink" title="什么是内存屏障"></a>什么是内存屏障</h2><p>维基百科中对内存屏障的描述如下：</p>
<blockquote>
<p>内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，它使得 CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行, 也就是说在memory barrier 之前的指令和memory barrier之后的指令不会由于系统优化等原因而导致乱序。<br>大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。<br>语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。</p>
</blockquote>
<p>在JVM中提供了四类内存屏障指令：</p>
<p><img src="https://pic3.zhimg.com/80/v2-06ae616adae545c36a01f7eaa192ac52_720w.jpg" alt="img"></p>
<h2 id="内存屏障的插入"><a href="#内存屏障的插入" class="headerlink" title="内存屏障的插入"></a>内存屏障的插入</h2><p>了解什么是内存屏障之后，我们再来看看JMM是如何插入内存屏障的。</p>
<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的前面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>在此策略下，volatile写操作插入内存屏障后生成的指令序列如下图所示。</p>
<p><img src="https://pic1.zhimg.com/80/v2-e6737695804284045f66f0e1163425b0_720w.jpg" alt="img"></p>
<p>由于StoreStore屏障保障上面所有的普通写在volatile写之前刷新到主内存，StoreStore屏障可以保证在volaitle写之前，其前面的所有普通写操作已经对任意处理器可见了。</p>
<p>volatile读操作插入内存屏障后生成的指令序列如下图所示。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c1a18b0fea3fcd2efe52ca35f658d1d1_720w.jpg" alt="img"></p>
<p>需要注意的是，在实际执行时，为了保证效率，编译器可以根据具体的情况省略不必要的屏障。</p>
<p>关于volatile的特性和实现原理就介绍到这里。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/151289085">volatile关键字的作用以及原理</a></p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><strong>存储引擎</strong>说白了就是如何存储数据、如何为存储的数据建立<strong>索引</strong>和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以<strong>存储引擎</strong>也可以称为表类型（即存储和操作此表的类型）。</p>
<p>在Oracle 和SQL Server等数据库中只有一种<strong>存储引擎</strong>，所有数据存储管理机制都是一样的。而MySql数据库提供了多种<strong>存储引擎</strong>。用户可以根据不同的需求为数据表选择不同的<strong>存储引擎</strong>，用户也可以根据自己的需要编写自己的<strong>存储引擎</strong>。</p>
<p>\2.   <strong>存储引擎</strong>的类型及特点</p>
<table>
<thead>
<tr>
<th><strong>引擎名称</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺陷</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>MyISAM</strong></td>
<td>独立于操作系统，这说明可以轻松地将其从Windows服务器移植到Linux服务器</td>
<td>不支持事务/行级锁/外键约束</td>
<td>适合管理邮件或Web服务器日志数据</td>
</tr>
<tr>
<td><strong>InnoDB</strong></td>
<td>健壮的事务型<strong>存储引擎</strong>；支持事务/行级锁/外键约束自动灾难恢复/AUTO_INCREMENT</td>
<td></td>
<td>需要事务支持，并且有较高的并发读取频率</td>
</tr>
<tr>
<td><strong>MEMORY</strong></td>
<td>为得到最快的响应时间，采用的逻辑存储介质是系统内存</td>
<td>当mysqld守护进程崩溃时，所有的Memory数据都会丢失；不能使用BLOB和TEXT这样的长度可变的数据类型</td>
<td>临时表</td>
</tr>
<tr>
<td><strong>MERGE</strong></td>
<td>是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表</td>
<td></td>
<td>常应用于日志和数据仓库</td>
</tr>
<tr>
<td><strong>ARCHIVE</strong></td>
<td>归档的意思，支持<strong>索引</strong>，拥有很好的压缩机制</td>
<td>仅支持插入和查询功能</td>
<td>经常被用来当做仓库使用</td>
</tr>
</tbody></table>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是对<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>表中一个或多个列（例如，employee 表的姓名 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</p>
<p>例如这样一个查询：select * from table1 where id=10000。如果没有索引，必须遍历整个表，直到ID等于10000的这一行被找到为止；有了索引之后(必须是在ID这一列上建立的索引)，即可在索引中查找。由于索引是经过某种算法优化过的，因而查找次数要少的多。可见，索引是用来定位的。</p>
<h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a><strong>分类：</strong></h2><p><strong>唯一索引</strong></p>
<p>唯一索引是不允许其中任何两行具有相同索引值的索引。<br>当现有数据中存在重复的键值时，大多数<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>不允许将新创建的唯一索引与表一起保存。<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p>
<p><strong>主键索引</strong></p>
<p><a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。<br>在<a target="_blank" rel="noopener" href="https://coding.imooc.com/?c=data">数据库</a>关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>
<p><strong>聚集索引</strong></p>
<p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。<br>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/11725"><strong>【程序员必读系列】-数据库索引的原理</strong></a></p>
<h1 id="分布式、微服务和集群的初步了解"><a href="#分布式、微服务和集群的初步了解" class="headerlink" title="分布式、微服务和集群的初步了解"></a>分布式、微服务和集群的初步了解</h1><p><strong>微服务</strong></p>
<p>简单来说微服务就是很小的服务，<strong>小到一个服务只对应一个单一的功能，只做一件事</strong>。这个服务可以单独部署运行，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</p>
<p><strong>微服务架构</strong></p>
<p>在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。</p>
<p><strong>分布式</strong></p>
<p>分布式服务顾名思义服务是<strong>分散部署在不同的机器上</strong>，一个服务可能负责几个功能，是一种面向SOA架构的，服务之间也是通过rpc来交互或者是webservice来交互的。</p>
<p>逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署，生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。<br>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难.</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yaoyao-sun/p/10422019.html">分布式、微服务和集群的初步了解</a></p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<h2 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h2><h3 id="1-1-Object-——-gt-getClass"><a href="#1-1-Object-——-gt-getClass" class="headerlink" title="1.1 Object ——&gt; getClass();"></a>1.1 Object ——&gt; getClass();</h3><h3 id="1-2-任何数据类型（包括基本数据类型）都有一个“静态”的class属性"><a href="#1-2-任何数据类型（包括基本数据类型）都有一个“静态”的class属性" class="headerlink" title="1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性"></a>1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</h3><h3 id="1-3-通过Class类的静态方法：forName（String-className）-常用"><a href="#1-3-通过Class类的静态方法：forName（String-className）-常用" class="headerlink" title="1.3 通过Class类的静态方法：forName（String  className）(常用)"></a>1.3 通过Class类的静态方法：forName（String  className）(常用)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象的三种方式</span></span><br><span class="line"><span class="comment"> * 1 Object ——&gt; getClass();</span></span><br><span class="line"><span class="comment"> * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</span></span><br><span class="line"><span class="comment"> * 3 通过Class类的静态方法：forName（String  className）(常用)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fanshe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式获取Class对象  </span></span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">        Class stuClass = stu1.getClass();<span class="comment">//获取Class对象</span></span><br><span class="line">        System.out.println(stuClass.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种方式获取Class对象</span></span><br><span class="line">        Class stuClass2 = Student.class;</span><br><span class="line">        System.out.println(stuClass == stuClass2);<span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三种方式获取Class对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class stuClass3 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">            System.out.println(stuClass3 == stuClass2);<span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Java类加载器与双亲委派模式的详解"><a href="#Java类加载器与双亲委派模式的详解" class="headerlink" title="Java类加载器与双亲委派模式的详解"></a>Java类加载器与双亲委派模式的详解</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38055381/article/details/81382115">Java类加载器与双亲委派模式的详解</a></p>
<h1 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h1><p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p>
<h1 id="B树，B-树的原理及区别"><a href="#B树，B-树的原理及区别" class="headerlink" title="B树，B+树的原理及区别"></a>B树，B+树的原理及区别</h1><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p><img src="/images/pasted-210408Btree.jpg"></p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><pre><code>  1.其定义基本与B-树同，除了：
</code></pre>
<p>​      2.非叶子结点的子树指针与关键字个数相同；</p>
<p>​      3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</p>
<p>​      4.为所有叶子结点增加一个链指针；</p>
<p>​      5.所有关键字都在叶子结点出现；</p>
<p><img src="/images/pasted-210408B+tree.jpg"></p>
<p> B+的特性：</p>
<p>​      1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>
<p>​      2.不可能在非叶子结点命中；</p>
<p>​      3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>
<p>​      4.更适合文件索引系统；</p>
<h2 id="为什么B-树比B树更适合数据库索引？"><a href="#为什么B-树比B树更适合数据库索引？" class="headerlink" title="为什么B+树比B树更适合数据库索引？"></a>为什么B+树比B树更适合数据库索引？</h2><p>1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<p>4、B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p>
<p>具体参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzzi/article/details/90208999">为什么说B+树比B树更适合数据库索引？</a></p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="红黑树规则"><a href="#红黑树规则" class="headerlink" title="红黑树规则"></a>红黑树规则</h2><p>红黑树有必须要遵守的规则，称为红-黑规则：</p>
<p>每个节点不是红色就是黑色的；<br>根节点总是黑色的；<br>红色节点的子节点必须是黑色的（反之不一定）。也就是从每个叶子到根的路径上不能有两个连续的红色节点；<br>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</p>
<h2 id="红黑树性能分析"><a href="#红黑树性能分析" class="headerlink" title="红黑树性能分析"></a>红黑树性能分析</h2><p>红黑树的查找、插入和删除时间复杂度都为O(logN)，额外的开销是每个节点的存储空间都稍微增加了一点，因为一个存储红黑树节点的颜色变量。插入和删除的时间要增加一个常数因子，因为要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是 O(logN)，(时间复杂度的计算要省略常数)，但实际上红黑树的插入和删除比普通的二叉树是要慢的。</p>
<p>红黑树适用于查找的次数比插入和删除的次数大很多的情况，红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。</p>
<p>具体参考：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_Wanderer/article/details/113872720">https://blog.csdn.net/Mr_Wanderer/article/details/113872720</a></p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉搜索树作为一种数据结构，其查找、插入和删除操作的时间复杂度都为O(logn)，底数为2。</p>
<p>但是我们说这个时间复杂度是在平衡的二叉搜索树上体现的，也就是如果插入的数据是随机的，则效率很高，但是如果插入的数据是有序的，比如从小到大的顺序【10,20,30,40,50】插入到二叉搜索树中：从大到小就是全部在左边，这和链表没有任何区别了，这种情况下查找的时间复杂度为O(N)，而不是O(logN)。当然这是在最不平衡的条件下，实际情况下，<strong>二叉搜索树的效率应该在O(N)和O(logN)之间，这取决于树的不平衡程度</strong>。</p>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>查找、插入和删除在平均和最坏情况下都是O（log n）。</p>
<p> 高度为 h 的 AVL 树，节点数 N 最多2^h − 1；</p>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="浅拷贝（Shallow-Copy）："><a href="#浅拷贝（Shallow-Copy）：" class="headerlink" title="浅拷贝（Shallow Copy）："></a><strong>浅拷贝</strong>（Shallow Copy）：</h2><p>①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</p>
<p><img src="https://images2017.cnblogs.com/blog/1218256/201710/1218256-20171011182513121-1029542999.png" alt="img"></p>
<p>浅拷贝的实现方式主要有三种：</p>
<p>一、通过拷贝构造方法实现浅拷贝：</p>
<p>拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。</p>
<p>二、通过重写clone()方法进行浅拷贝：</p>
<p>Object类是类结构的根类，其中有一个方法为protected Object <strong>clone</strong>() throws <a target="_blank" rel="noopener" href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/CloneNotSupportedException.html">CloneNotSupportedException</a>，这个方法就是进行的浅拷贝。有了这个浅拷贝模板，我们可以通过调用clone()方法来实现对象的浅拷贝。但是需要注意：1、Object类虽然有这个方法，但是这个方法是受保护的（被protected修饰），所以我们无法直接使用。2、使用clone方法的类必须实现Cloneable接口，否则会抛出异常CloneNotSupportedException。对于这两点，我们的解决方法是，在要使用clone方法的类中重写clone()方法，通过super.clone()调用Object类中的原clone方法。</p>
<p>基本数据类型是值传递，所以修改值后不会影响另一个对象的该属性值；</p>
<p>引用数据类型是地址传递（引用传递），所以修改值后另一个对象的该属性值会同步被修改。</p>
<h2 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h2><p>首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象图进行拷贝！</p>
<p>简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。</p>
<p>深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。</p>
<p><img src="https://images2017.cnblogs.com/blog/1218256/201710/1218256-20171011190501371-68869476.png" alt="img"></p>
<p>因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>深拷贝的实现方法主要有两种：</p>
<p>一、通过重写clone方法来实现深拷贝</p>
<p>与通过重写clone方法实现浅拷贝的基本思路一样，只需要为对象图的每一层的每一个对象都实现Cloneable接口并重写clone方法，最后在最顶层的类的重写的clone方法中调用所有的clone方法即可实现深拷贝。简单的说就是：每一层的每个对象都进行浅拷贝=深拷贝。</p>
<p>分析结果可以验证：进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。</p>
<p>二、通过对象序列化实现深拷贝</p>
<p>虽然层次调用clone方法可以实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写clone方法太过繁琐。</p>
<p>将对象序列化为字节序列后，默认会将该对象的整个对象图进行序列化，再通过反序列即可完美地实现深拷贝。</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>JVM在进行GC时，并不是对这三个区域统一回收。 大部分时候，回收都是新生代~<br>●新生代<br><strong>●幸存区(form，to)</strong><br>●老年区<br>GC两种类:轻GC (普通的GC)， 重GC (全局GC)<br>GC常见面试题目:<br>●JVM的内存模型和分区~详细到每个区放什么?<br><img src="https://img-blog.csdnimg.cn/20200715153153103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p> 图 JVM内存模型和分区</p>
<p>●堆里面的分区有哪些?<br>Eden, form, to, 老年区,说说他们的特点!<br>●GC的算法有哪些?<br>标记清除法，标记整理,复制算法，引用计数器<br>●轻GC和重GC分别在什么时候发生?</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42671148/article/details/108274558">JVM-狂神学习笔记</a></p>
<h1 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h1><p>在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程<br>　　<strong>第一</strong>：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>　　<strong>第二</strong>：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>　　<strong>第三</strong>：提高线程的可管理性。<br>常用线程池：ExecutorService 是主要的实现类，其中常用的有 :<br>Executors.newSingleThreadPool()</p>
<p>  　　newFixedThreadPool()</p>
<p>  　　newcachedTheadPool()</p>
<p>  　 newScheduledThreadPool()</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zeze/p/6548649.html">线程池的作用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/superfj/p/7544971.html">由浅入深理解Java线程池及线程池的如何使用</a></p>
<h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>局部性通常分为：<strong>时间局部性</strong>和<strong>空间局部性</strong>。</p>
<p>1）时间局部性<br>时间局部性是指被引用过一次的内存位置很可能在不远的将来再被多次引用。</p>
<p>2）空间局部性<br>空间局部性是指如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用其附近的一个内存位置。</p>
<p>3）局部性原理举例</p>
<ul>
<li>在硬件层，局部性原理允许计算机设计者通过引入小而快的高速缓存存储器来保存最近被引用的指令和数据项，从而提高对主存的访问速度。</li>
<li>在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。</li>
<li>类似的，操作系统用主存来缓存磁盘文件系统中最近被使用的磁盘块。</li>
<li>在应用程序的设计，如Web浏览器将最近被请求的文档放在本地磁盘上，利用的就是时间局部性。大容量的Web服务器将最近被请求的文档放在前端磁盘高速缓存中，不需要服务器的干预就可满足对这些文档的请求。</li>
</ul>
<h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<h1 id="Linux下的编译和执行"><a href="#Linux下的编译和执行" class="headerlink" title="Linux下的编译和执行"></a>Linux下的编译和执行</h1><p>具体参考：</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013793399/article/details/51365311">在Linux系统下编译并执行C++程序</a></p>
<h1 id="Spring相关面试题"><a href="#Spring相关面试题" class="headerlink" title="Spring相关面试题"></a>Spring相关面试题</h1><p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41701956/article/details/81389067">近5年来的 Spring 相关面试题整理</a></p>
<h1 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h1><p>具体参考：</p>
<p><a href="%5Bhttps://jpeony.blog.csdn.net/article/details/80950336?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control%5D(https://jpeony.blog.csdn.net/article/details/80950336?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control)">【JVM】垃圾回收机制(1)–如何判定对象可以回收</a></p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。</p>
<h2 id="SQL注入攻击的总体思路"><a href="#SQL注入攻击的总体思路" class="headerlink" title="SQL注入攻击的总体思路"></a>SQL注入攻击的总体思路</h2><p>　　1：寻找到SQL注入的位置</p>
<p>　　2：判断服务器类型和后台数据库类型</p>
<p>　　3：针对不同的服务器和数据库特点进行SQL注入攻击</p>
<h1 id="各网络层的协议"><a href="#各网络层的协议" class="headerlink" title="各网络层的协议"></a>各网络层的协议</h1><p>TCP/IP体系结构</p>
<p><img src="https://img-blog.csdnimg.cn/20200823014026904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI4MjA2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>TCP/IP协议各层功能</p>
<p>各层所包含的协议</p>
<p><img src="https://img-blog.csdnimg.cn/20200823014123331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI4MjA2Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>协议栈<br>各层的所有协议被称为协 议栈(protocol stack).因特网的协议栈由5个层次组成：物理层，数据链路层，网络层，运输层，应用层。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>(1)应用层(application layer) 应用层是体系结构中的最高层。应用层直接为用户的应用进程提供服务。这里的进程就是指正在运行的程序。在因特网中的应用层协议很多， 如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等等。<br>应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中 的应用程序交换信息分组。我们将这种位于应用层的信息分组称为报文（message）。</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>迈输层提供了在应用程序端点之间传送应用层报文的服务。<br>(2)运输层(transport layer) 运输层的任务就是负责向两个主机中进程之间的通信提 供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多 个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付给上面 应用层中的相应的进程。运输层分组称为报文段。<br>运输层主要使用以下两种协议：<br>① 传输控制协议TCP (Transmission Control Protocol) 面向连接的，数据传输的单位<br>是报文段(segment),能够提供可靠的交付。<br>② 用户数据报协议UDP (User Datagram Protocol) 无连接的，数据传输的单位是用<br>户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付(best-effortdelivery)”<br>TCP与UDP区别<br>协议，即TCP和UDP,利用其中的任何一个都能传输应用层报文。TCP向它的应用程序提供了 面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流童控制(即发送方/接 收方速率匹配)。TCP也将长报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时， 源抑制其传输速率。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务 的服务，不提供可靠性，没有流量控制，也没有拥塞控制。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>(3)因特网的网络层负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主 机。源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址， 就像你向邮政信件提供目的地址一样。在 TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报，或简称为数据报。<br>因特网的网络层包括著名的IP协议，该协议定义了数据报中的各个字段以及端系统和路 由器如何作用于这些字段。仅有一个IP协议，所有具有网络层的因特网组件都必须运行IP协议。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>(4)数据链路层(data link layer) 常简称为链路层。我们知道，两个主机之间的数据 传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间(主机和路由器之 间或两个路由器之间)传送数据是直接传送的(点对点)。这时就需要使用专门的链路层的 协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧 (framing),在两个相邻结点间的链路上“透明”地传送帧(frame)中的数据。每一帧包括数据 和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将 该帧中的一个一个比特从一个节点移动到下一个节点。该层中的协议仍然是链路相关的，并 且进一步与链路（例如，双绞铜线、单模光纤）的实际传输媒体相关。例如，以太网具有许 多物理层协议：关于双绞铜线的，关于同轴电缆的，关于光纤的，等等。在每种情况下，跨 越这些链路移动一个比特的方式不同。</p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>一篇比较好的并查集：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42011541/article/details/83378709">https://blog.csdn.net/qq_42011541/article/details/83378709</a></p>
<p>N个人要坐在桌子上吃饭，但是人们拒绝和陌生人坐在一张桌子上。什么样的不算陌生人呢？主要是朋友的朋友的朋友的…..只要能扯上关系就不算陌生人。能扯上关系就可以坐在一张桌子上。所以至少要准备多少张桌子？</p>
<p>思路：其实就是对并查集进行合并操作，只要俩人认识，就组队。把队组好以后，看最后有多少个组(集合)就行了。最初每个人都自成一组，所以有多少人就有多少组。但是随着他们组队，每两个组合并成一个组，总的组数就会少1。如果组队的时候发现，他俩已经早就‘扯上关系了’，也就表名他俩早就是一组了，那就不用继续合并了，也就不用再 -1 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//代表并查集中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> groups;<span class="comment">//代表并查集中有多少个集合（小组）</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.groups = size;<span class="comment">//因为初始的时候每个人自成一组，所以有多少人就有多少组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>.weight[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (element != parent[element]) &#123;</span><br><span class="line">            parent[element] = parent[parent[element]];</span><br><span class="line">            element = parent[element];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> firstElement, <span class="keyword">int</span> secondElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(firstElement) == find(secondElement);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> firstElement, <span class="keyword">int</span> secondElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstRoot = find(firstElement);</span><br><span class="line">        <span class="keyword">int</span> secondRoot = find(secondElement);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//如果已经属于同一个集合了，就不用再合并了。</span></span><br><span class="line">        <span class="keyword">if</span> (firstRoot == secondRoot) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (weight[firstRoot] &gt; weight[secondRoot]) &#123;</span><br><span class="line">            parent[secondRoot] = firstRoot;</span><br><span class="line">            weight[firstRoot] += weight[secondRoot];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//weight[firstRoot] &lt;= weight[secondRoot]</span></span><br><span class="line">            parent[firstRoot] = secondRoot;</span><br><span class="line">            weight[secondRoot] += weight[firstRoot];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//合并 firstElement 和 secondElement 所在的两个组后，就少了一组。</span></span><br><span class="line">        <span class="keyword">this</span>.groups--;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGroups</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.groups;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.Scanner scanner = <span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> times = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = scanner.nextInt();</span><br><span class="line">            UnionFind union = <span class="keyword">new</span> UnionFind(size);</span><br><span class="line">            <span class="keyword">int</span> input = scanner.nextInt();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input; j++) &#123;</span><br><span class="line">                <span class="comment">//因为测试数据是从1开始，而我们的并查集是从数组的第0位开始</span></span><br><span class="line">                <span class="keyword">int</span> first = scanner.nextInt() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> second = scanner.nextInt() - <span class="number">1</span>;</span><br><span class="line">                union.unionElements(first, second);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(union.getGroups());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure>

<h1 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h1><p>transient关键字的作用是：被transient修饰的变量不参与序列化和反序列化。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>简要解释：<br>　　序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。<br>　　序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，<br>然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangchunze/p/6728086.html">什么是Java序列化，如何实现java序列化</a></p>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>Java线程可以有优先级的设定，高优先级的线程比低优先级的线程有更高的几率得到执行（不完全正确，请参考下面的“线程优先级的问题“）。</p>
<ol>
<li>记住当线程的优先级没有指定时，所有线程都携带普通优先级。</li>
<li>优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。</li>
<li>记住优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态。</li>
<li>与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。</li>
<li>由调度程序决定哪一个线程被执行。</li>
<li>t.setPriority()用来设定线程的优先级。</li>
<li>记住在线程开始方法被调用之前，线程的优先级应该被设定。</li>
<li>你可以使用常量，如MIN_PRIORITY,MAX_PRIORITY，NORM_PRIORITY来设定优先级。</li>
</ol>
<h1 id="Java线程和操作系统线程的关系"><a href="#Java线程和操作系统线程的关系" class="headerlink" title="Java线程和操作系统线程的关系"></a>Java线程和操作系统线程的关系</h1><p>Java中的线程：</p>
<p><strong>特别注意：这些线程的状态时JVM中的线程状态！不是操作系统中的线程状态。</strong></p>
<p><img src="https://img-blog.csdn.net/20180418174102632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ3JpbmdLb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CringKong/article/details/79994511">Java线程和操作系统线程的关系</a></p>
<h1 id="从输入URL到页面展示的详细过程"><a href="#从输入URL到页面展示的详细过程" class="headerlink" title="从输入URL到页面展示的详细过程"></a>从输入URL到页面展示的详细过程</h1><p>大致过程：</p>
<ul>
<li>1、输入网址</li>
<li>2、DNS解析</li>
<li>3、建立tcp连接</li>
<li>4、客户端发送HTPP请求</li>
<li>5、服务器处理请求</li>
<li>6、服务器响应请求</li>
<li>7、浏览器展示HTML</li>
<li>8、浏览器发送请求获取其他在HTML中的资源。</li>
</ul>
<h2 id="1、输入地址"><a href="#1、输入地址" class="headerlink" title="1、输入地址"></a>1、输入地址</h2><p>  当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>
<h2 id="2、浏览器查找域名的-IP-地址"><a href="#2、浏览器查找域名的-IP-地址" class="headerlink" title="2、浏览器查找域名的 IP 地址"></a>2、浏览器查找域名的 IP 地址</h2><p>　　1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>
<p>   2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p>
<p>　  3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</p>
<p>　　4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。</p>
<p>　　5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p>
<p>　　6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<h2 id="3、浏览器向-web-服务器发送一个-HTTP-请求"><a href="#3、浏览器向-web-服务器发送一个-HTTP-请求" class="headerlink" title="3、浏览器向 web 服务器发送一个 HTTP 请求"></a>3、浏览器向 web 服务器发送一个 HTTP 请求</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p>
<p>建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。</p>
<p>　　客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>
<p>　　| 请求方法URI协议/版本</p>
<p>​        | 请求头(Request Header)</p>
<p>　　| 请求正文：</p>
<h2 id="4、服务器的永久重定向响应"><a href="#4、服务器的永久重定向响应" class="headerlink" title="4、服务器的永久重定向响应"></a>4、服务器的永久重定向响应</h2><p>​        服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“<a target="_blank" rel="noopener" href="http://www.google.com/%E2%80%9D">http://www.google.com/”</a> 而非“<a target="_blank" rel="noopener" href="http://google.com/%E2%80%9D%E3%80%82">http://google.com/”。</a></p>
<p>　　为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<a target="_blank" rel="noopener" href="http://www.yy.com/%E5%92%8Chttp://yy.com/%EF%BC%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%9A%E8%AE%A4%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E7%BB%93%E6%9E%9C%E9%80%A0%E6%88%90%E6%AF%8F%E4%B8%AA%E6%90%9C%E7%B4%A2%E9%93%BE%E6%8E%A5%E9%83%BD%E5%87%8F%E5%B0%91%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E6%8E%92%E5%90%8D%E3%80%82%E8%80%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9F%A5%E9%81%93301%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%BC%9A%E6%8A%8A%E8%AE%BF%E9%97%AE%E5%B8%A6www%E7%9A%84%E5%92%8C%E4%B8%8D%E5%B8%A6www%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%92%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E6%8E%92%E5%90%8D%E4%B8%8B%E3%80%82%E8%BF%98%E6%9C%89%E5%B0%B1%E6%98%AF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E9%80%A0%E6%88%90%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E6%80%A7%E5%8F%98%E5%B7%AE%EF%BC%8C%E5%BD%93%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%90%8D%E5%AD%97%E6%97%B6%EF%BC%8C%E5%AE%83%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%9C%A8%E7%BC%93%E5%AD%98%E9%87%8C%E5%87%BA%E7%8E%B0%E5%A5%BD%E5%87%A0%E6%AC%A1%E3%80%82">http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。</a></p>
<h2 id="5、浏览器跟踪重定向地址"><a href="#5、浏览器跟踪重定向地址" class="headerlink" title="5、浏览器跟踪重定向地址"></a>5、浏览器跟踪重定向地址</h2><p>  现在浏览器知道了 “<a target="_blank" rel="noopener" href="http://www.google.com/&quot;%E6%89%8D%E6%98%AF%E8%A6%81%E8%AE%BF%E9%97%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%83%E4%BC%9A%E5%8F%91%E9%80%81%E5%8F%A6%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82%E3%80%82%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89%E5%95%A5%E5%A5%BD%E8%AF%B4%E7%9A%84">http://www.google.com/&quot;才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的</a></p>
<h2 id="6、服务器处理请求"><a href="#6、服务器处理请求" class="headerlink" title="6、服务器处理请求"></a>6、服务器处理请求</h2><p>　　经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？</p>
<p>　　后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p>
<p>　　一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>
<h2 id="7、服务器返回一个-HTTP-响应"><a href="#7、服务器返回一个-HTTP-响应" class="headerlink" title="7、服务器返回一个 HTTP 响应"></a>7、服务器返回一个 HTTP 响应</h2><p>　　经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。</p>
<p>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>
<p>l 状态行</p>
<p>l 响应头(Response Header)</p>
<p>l 响应正文</p>
<h2 id="8、浏览器显示-HTML"><a href="#8、浏览器显示-HTML" class="headerlink" title="8、浏览器显示 HTML"></a>8、浏览器显示 HTML</h2><p>　　在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：(暂略)</p>
<h2 id="9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）"><a href="#9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）" class="headerlink" title="9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）"></a>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</h2><p>​        其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：</p>
<p>图片：<a target="_blank" rel="noopener" href="http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif">http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif</a></p>
<p>CSS式样表：<a target="_blank" rel="noopener" href="http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css">http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css</a></p>
<p>JavaScript 文件：<a target="_blank" rel="noopener" href="http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js">http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js</a></p>
<p>　　这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p>
<p>不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="1-什么是DNS？"><a href="#1-什么是DNS？" class="headerlink" title="1)什么是DNS？"></a>1)什么是DNS？</h2><p>　　DNS（Domain Name System，域名系统），因特网上作为域名和<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>相互映射的一个<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93">分布式数据库</a>，能够使用户更方便的访问<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91">互联网</a>，而不用去记住能够被机器直接读取的IP数串。通过<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<p>　　通俗的讲，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</a></p>
<h2 id="2-DNS查询的两种方式：递归查询和迭代查询"><a href="#2-DNS查询的两种方式：递归查询和迭代查询" class="headerlink" title="2)DNS查询的两种方式：递归查询和迭代查询"></a>2)DNS查询的两种方式：递归查询和迭代查询</h2><p>1、递归解析</p>
<p>  当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图\所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p>
<p>2、迭代解析</p>
<p>　　当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p>
<h2 id="4-DNS负载均衡"><a href="#4-DNS负载均衡" class="headerlink" title="4)DNS负载均衡"></a>4)DNS负载均衡</h2><p>　　当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
<h1 id="重定向原因"><a href="#重定向原因" class="headerlink" title="重定向原因"></a>重定向原因</h1><p>（1）网站调整（如改变网页目录结构）；</p>
<p>（2）网页被移到一个新地址；</p>
<p>（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</p>
<p>​    这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>
<h1 id="状态码301和302"><a href="#状态码301和302" class="headerlink" title="状态码301和302"></a>状态码301和302</h1><h2 id="1）301和302的区别。"><a href="#1）301和302的区别。" class="headerlink" title="1）301和302的区别。"></a>1）301和302的区别。</h2><p>　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。</p>
<p>　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</p>
<p>　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 所以302好于301。</p>
<h2 id="2）什么时候进行301或者302跳转呢？"><a href="#2）什么时候进行301或者302跳转呢？" class="headerlink" title="2）什么时候进行301或者302跳转呢？"></a>2）什么时候进行301或者302跳转呢？</h2><p>​    当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。</p>
<p>清晰明确而言：使用301跳转的大概场景如下：</p>
<p>1、域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</p>
<p>2、在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</p>
<p>3、空间服务器不稳定，换空间的时候。</p>
<h1 id="如何判断一个对象是否应该被回收"><a href="#如何判断一个对象是否应该被回收" class="headerlink" title="如何判断一个对象是否应该被回收"></a>如何判断一个对象是否应该被回收</h1><p>这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析。由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法。</p>
<h3 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h3><p>引用计数法的逻辑非常简单，但是存在问题，java并不采用这种方式进行对象存活判断。</p>
<p>引用计数法的逻辑是：在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。</p>
<p>这种方法来标记对象的状态会存在很多问题：</p>
<p>jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。 </p>
<h3 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h3><p>在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。<br><img src="https://img-blog.csdnimg.cn/20190529111953162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTk2NzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42996761/article/details/90667725">如何判断一个对象是否应该被回收</a></p>
<h1 id="Java内存泄露和内存溢出的区别和联系"><a href="#Java内存泄露和内存溢出的区别和联系" class="headerlink" title="Java内存泄露和内存溢出的区别和联系"></a>Java内存泄露和内存溢出的区别和联系</h1><h2 id="1、内存泄漏memory-leak"><a href="#1、内存泄漏memory-leak" class="headerlink" title="1、内存泄漏memory leak :"></a>1、内存泄漏memory leak :</h2><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>
<h2 id="2、内存溢出-out-of-memory"><a href="#2、内存溢出-out-of-memory" class="headerlink" title="2、内存溢出 out of memory :"></a>2、内存溢出 out of memory :</h2><p>指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p>
<h2 id="3、二者的关系："><a href="#3、二者的关系：" class="headerlink" title="3、二者的关系："></a>3、二者的关系：</h2><ol>
<li>内存泄漏的堆积最终会导致内存溢出</li>
<li>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</li>
<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</li>
<li>内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。</li>
</ol>
<h2 id="内存泄露的场景"><a href="#内存泄露的场景" class="headerlink" title="内存泄露的场景"></a>内存泄露的场景</h2><ol>
<li>静态集合类引起内存泄漏：静态成员的生命周期是整个程序运行期间。</li>
<li>调用 remove()方法时不起作用</li>
<li>各种连接对象( IO 流对象、数据库连接对象、网络连接对象)使用后未关闭：因为每个流 在操作系统层面都对应了打开的文件句柄，流没有关闭，会导致操作系统的文件句柄一 直处于打开状态，而jvm会消耗内存来跟踪操作系统打开的文件句柄。</li>
<li>监听器的使用：在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li>
<li>不正确使用单例模式是引起内存泄漏：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</li>
</ol>
<h2 id="内存泄漏解决措施"><a href="#内存泄漏解决措施" class="headerlink" title="内存泄漏解决措施"></a>内存泄漏解决措施</h2><ol>
<li><p>尽量减少使用静态变量，类的静态变量的生命周期和类同步的。</p>
</li>
<li><p>声明对象引用之前，明确内存对象的有效作用域，尽量减小对象的作用域，将类的成员 变量改写为方法内的局部变量；</p>
</li>
<li><p>减少长生命周期的对象持有短生命周期的引用；</p>
</li>
<li><p>使用 StringBuilder 和 StringBuffer 进行字符串连接，Sting 和 StringBuilder 以及 StringBuffer 等都可以代表字符串，其中 String 字符串代表的是不可变的字符串，后两者表示 可变的字符串。如果使用多个 String 对象进行字符串连接运算，在运行时可能产生大量临时字符串，这些字符串会保存在内存中从而导致程序性能下降。</p>
</li>
<li><p>对于不需要使用的对象手动设置 null 值，不管 GC 何时会开始清理，我们都应及时的将无用的对象标记为可被清理的对象；</p>
</li>
<li><p>各种连接（数据库连接，网络连接，IO 连接）操作，务必显示调用 close 关闭。</p>
</li>
</ol>
<h2 id="内存溢出的场景"><a href="#内存溢出的场景" class="headerlink" title="内存溢出的场景"></a>内存溢出的场景</h2><h3 id="JVM-Heap（堆）溢出："><a href="#JVM-Heap（堆）溢出：" class="headerlink" title="JVM Heap（堆）溢出："></a><strong>JVM Heap（堆）溢出</strong>：</h3><p> 发生这种问题的原因是 java 虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已 经用满了。</p>
<p>解决方法：</p>
<ol>
<li>手动设置 JVM Heap（堆）的大小。</li>
<li>检查程序，看是否有死循环或不必要地重复创建大量对象。</li>
</ol>
<h2 id="Metaspace溢出"><a href="#Metaspace溢出" class="headerlink" title="Metaspace溢出"></a><strong>Metaspace溢出</strong></h2><p>Metaspace 程序中使用了大量的 jar 或 class，使 java 虚拟机装载类的空间不够，与 metaspace 大小有关。方法区用于存放 Java 类型的相关信息。在类装载器加载 class 文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的 内存占用又已经达到 -XX:MaxMetaspaceSize 设置的最大值，将会抛出 OutOfMemoryError 异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</p>
<p>解决方法:</p>
<ol>
<li>通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置永久代大小即可。</li>
</ol>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a><strong>栈溢出</strong></h2><p>java.lang.StackOverflowError : Thread Stack space：线程的方法嵌套调用层次太多(如递归调用)，以致于把栈区溢出了。</p>
<p>解决方法：</p>
<ol>
<li>修改程序。</li>
<li>通过 -Xss: 来设置每个线程的 Stack 大小即可。</li>
</ol>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/sunmin/blog/3034336">JAVA内存泄漏和内存溢出的区别和联系</a></p>
<h1 id="散列函数和Hash冲突"><a href="#散列函数和Hash冲突" class="headerlink" title="散列函数和Hash冲突"></a>散列函数和Hash冲突</h1><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><ol>
<li>直接定值法：例如线性函数</li>
<li>数字分析法：根据数字特性来决定</li>
<li>除留余数法：例如除以某个质数</li>
<li>平方取中法</li>
<li>基数转换法</li>
<li>折叠法</li>
</ol>
<h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><ol>
<li><p>开放定址法：</p>
<ul>
<li><p>线性探测再散列 di = 1 , 2 , 3 , … , m-1</p>
</li>
<li><p>平方探测再散列 di = 1 , -1 , 2, -2 , 3 , -3 , … , k , -k(取相应数的平方)</p>
</li>
<li><p>随机探测再散列 di 是一组伪随机数列</p>
</li>
</ul>
</li>
<li><p>链接法：</p>
<p>将所有哈希地址相同的记录都链接在同一链表中。</p>
</li>
<li><p>再哈希法：</p>
<p>再次进行另一个哈希函数计算，直到冲突不发生。</p>
</li>
<li><p>建立公共溢出区</p>
<p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>
</li>
</ol>
<h1 id="Integer比较大小要注意的地方"><a href="#Integer比较大小要注意的地方" class="headerlink" title="Integer比较大小要注意的地方"></a>Integer比较大小要注意的地方</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b);     <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">Integer c = <span class="number">128</span>;</span><br><span class="line">Integer d = <span class="number">128</span>;</span><br><span class="line">System.out.println(c == d);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p>这是因为 Integer 类在内存中有一个值的范围为[-128, 127]的对象池。只要 Integer 对象的值在[-128, 127]范围内，都是从这个对象池中取。所以只要是这个范围的 Integer 对象，只要值相同，就是同一个对象。那么 == 的结果，就是 true。超过了这个范围，则会 new 新的 Integer 对象，尽管值相同，但是已经是不同的对象了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(a == b);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>那么结果就是 false 了，因为他重新生成对象了；</p>
<p>如果超过了 [-128, 127] 之间的值，被装箱后的 Integer 对象并不会被重用，即相当于每次装箱时都新建一个 Integer 对象，所以 Integer c = 128，Integer d = 128 参考的不同的对象。内存地址不同，结果是 false，对象如果要比较值，应该用 .equals()方法。<br><em>注意</em>：只有 Integer 类有对象池，其他的 Short…Double 都没有对象池</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fly_sky23/article/details/85162859">Java中两个Integer比较大小需要注意的误区</a></p>
<h1 id="Mysql实现乐观锁"><a href="#Mysql实现乐观锁" class="headerlink" title="Mysql实现乐观锁"></a>Mysql实现乐观锁</h1><p>具体参考：</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/gaopeijiayou/article/details/100152780">mysql实现乐观锁</a></p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><ol>
<li>线程池的概念：</li>
</ol>
<p>​     线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>
<ol start="2">
<li>线程池的工作机制</li>
</ol>
<p>​     2.1 在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</p>
<p>​     2.1 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>
<ol start="3">
<li>使用线程池的原因：</li>
</ol>
<p>​    多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。</p>
<h2 id="四种常见线程池"><a href="#四种常见线程池" class="headerlink" title="四种常见线程池"></a>四种常见线程池</h2><ol>
<li>线程池的返回值ExecutorService简介：</li>
</ol>
<p>​     ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程</p>
<ol start="2">
<li><p>具体的4种常用的线程池实现如下：（返回值都是ExecutorService）</p>
<p>2.1  Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务</p>
<p>2.2 Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。</p>
<p>2.3 Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行</p>
<p>2.4 Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
</li>
</ol>
<h2 id="缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor"><a href="#缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor" class="headerlink" title="缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor"></a>缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor</h2><p>\1. 缓冲队列BlockingQueue简介：</p>
<p>​     BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。</p>
<p>\2. 常用的几种BlockingQueue：</p>
<ul>
<li>ArrayBlockingQueue（int i）:规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。</li>
<li>LinkedBlockingQueue（）或者（int i）:大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。</li>
<li>PriorityBlockingQueue（）或者（int i）:类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。</li>
<li>SynchronizedQueue（）:特殊的BlockingQueue，对其的操作必须是放和取交替完成。</li>
</ul>
<p>\3. 自定义线程池（ThreadPoolExecutor和BlockingQueue连用）：</p>
<p>   <em>自定义线程池，可以用ThreadPoolExecutor类创建，它有多个构造方法来创建线程池。</em></p>
<p>  <em>常见的构造函数：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)</em></p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiawen010/p/11855768.html">4种常用线程池介绍</a></p>
<h1 id="访问量大为什么服务会崩溃，崩溃的本质是什么？"><a href="#访问量大为什么服务会崩溃，崩溃的本质是什么？" class="headerlink" title="访问量大为什么服务会崩溃，崩溃的本质是什么？"></a>访问量大为什么服务会崩溃，崩溃的本质是什么？</h1><p>崩溃是通俗的说法，意思是对外服务不正常了。。但是这个不正常是有语境的，比如我们淘宝买东西，应该几秒钟就提示购买成功，但是如果10秒后才出来，这个就叫负载大，卡了。如果这个时间继续增大到30秒或者1分钟，浏览器就认为超时了，直接显示打不开，那么对外就是宣称服务崩溃了。比如淘宝双11的时候很多页面打不开。但是实际上服务器上程序并没有退出，只是处理不过来了。</p>
<p>崩溃的原因是：服务器对于请求都是排队的，负载不大的时候感觉不到，因为都是1秒内处理了。。当请求数量上去后，就开始有感觉了。但是继续增大的话，队列也满了，服务器开始丢弃部分请求<br>继续增大网络请求，操作系统的TCP协议栈也开始丢弃请求，对外表现为服务器网络也连不上了。<br>继续增大的话，网卡硬件部分开始满速运行，然后就看操作系统驱动和硬件质量了。</p>
<h1 id="交替打印1-100"><a href="#交替打印1-100" class="headerlink" title="交替打印1-100"></a>交替打印1-100</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printonetohundredtwo210505</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turning</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread even = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数: &quot;</span> + count++);</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果还没有结束，则让出当前的锁并休眠</span></span><br><span class="line">                        <span class="keyword">if</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread odd = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数: &quot;</span> + count++);</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果还没有结束，则让出当前的锁并休眠</span></span><br><span class="line">                        <span class="keyword">if</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        even.start();</span><br><span class="line">        <span class="comment">// 确保偶数线程线先获取到锁</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        odd.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拓展：如果<strong>有三个线程，要求让它们交替输出 1、2、3</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread thread1,thread2,thread3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        thread1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1());</span><br><span class="line">        thread2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2());</span><br><span class="line">        thread3=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread3());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1=&quot;</span>+i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2=&quot;</span>+i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">2</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t3=&quot;</span>+i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h1><p>1）四种整数类型(byte、short、int、long)：   byte：8 位，用于表示最小数据单位，如文件中数据，-128<del>127   short：16 位，很少用，-32768 ~ 32767   int：32 位、最常用，-2^31-1</del>2^31 （21 亿）   long：64 位、次常用   注意事项：   int i=5; // 5 叫直接量（或字面量），即 直接写出的常数。   整数字面量默认都为 int 类型，所以在定义的 long 型数据后面加 L或 l。   小于 32 位数的变量，都按 int 结果计算。   强转符比数学运算符优先级高。见常量与变量中的例子。</p>
<p>2）两种浮点数类型(float、double)：   float：32 位，后缀 F 或 f，1 位符号位，8 位指数，23 位有效尾数。   double：64 位，最常用，后缀 D 或 d，1 位符号位，11 位指数，52 位有效尾   注意事项：   二 进 制 浮 点 数 ： 1010100010=101010001.0<em>2=10101000.10</em>2^10（2次方)=1010100.010<em>2^11(3次方)= . 1010100010</em>2^1010(10次方)   尾数： . 1010100010  指数：1010  基数：2   浮点数字面量默认都为 double 类型，所以在定义的 float 型数据后面加F 或 f；double 类型可不写后缀，但在小数计算中一定要写 D 或 X.X   float 的精度没有 long 高，有效位数（尾数）短。   float 的范围大于 long 指数可以很大。   浮点数是不精确的，不能对浮点数进行精确比较。</p>
<p>3）一种字符类型(char)：   char：16 位，是整数类型，用单引号括起来的 1 个字符（可以是一个中文字符），使用 Unicode 码代表字符，0~2^16-1（65535） 。   注意事项：   不能为 0个字符。   转义字符：\n 换行 \r 回车 \t Tab 字符 &quot; 双引号 \ 表示一个\   两字符 char 中间用“+”连接，内部先把字符转成 int 类型，再进行加法运算，char 本质就是个数！二进制的，显示的时候，经过“处理”显示为字符。</p>
<p>4）一种布尔类型(boolean)：true 真 和 false 假。</p>
<h1 id="Java中有了基本类型为什么还要有包装类型"><a href="#Java中有了基本类型为什么还要有包装类型" class="headerlink" title="Java中有了基本类型为什么还要有包装类型?"></a>Java中有了基本类型为什么还要有包装类型?</h1><p>Java中基本数据类型与包装类型有：</p>
<table>
<thead>
<tr>
<th><strong>基本类型</strong></th>
<th><strong>包装器类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>为什么存在这两种类型呢？</p>
<p>我们都知道在Java语言中，new一个对象存储在堆里，我们通过栈中的引用来使用这些对象；但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在栈中，因此更加高效。</p>
<p>有了基本类型为什么还要有包装类型呢？</p>
<p>我们知道Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<p>另外，当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装器类了。</p>
<p>二者相互转换：</p>
<p>1、int转Integer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">Integer ii = <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure>

<p>2、Integer转int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer ii = <span class="keyword">new</span> Integer(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">int</span> i = ii.intValue();  </span><br></pre></td></tr></table></figure>




<p>二者的区别：</p>
<ol>
<li>声明方式不同：</li>
</ol>
<p>基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；</p>
<ol start="2">
<li>存储方式及位置不同：</li>
</ol>
<p>基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；</p>
<ol start="3">
<li>初始值不同：</li>
</ol>
<p>基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</p>
<ol start="4">
<li>使用方式不同：</li>
</ol>
<p>基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</p>
<p>具体参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/min996358312/article/details/62894674">java中有了基本类型为什么还要有包装类型?</a></p>
<h1 id="为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K？"></a><strong>为什么HashMap中String、Integer这样的包装类适合作为K？</strong></h1><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<p>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况<br>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况<br>如果Object作为键，那么需要重写hashCode()和equals()方法</p>
<p>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞<br>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性</p>
<h1 id="HashMap和Hashtable实现类的区别"><a href="#HashMap和Hashtable实现类的区别" class="headerlink" title="HashMap和Hashtable实现类的区别"></a>HashMap和Hashtable实现类的区别</h1><p><strong>区别</strong></p>
<ul>
<li>Hashtable是线性安全的，HashMap是线性不安全的，所以后者效率更高。</li>
<li>Hashtable不允许使用null作为key和value，否则会引发异常，而HashMap可以；</li>
</ul>
<h1 id="HashMap和HashSet实现类的区别"><a href="#HashMap和HashSet实现类的区别" class="headerlink" title="HashMap和HashSet实现类的区别"></a>HashMap和<strong>HashSet</strong>实现类的区别</h1><ul>
<li>与HashSet集合不能保证元素顺序一样，HashMap和Hashtable也不能保证键值对的顺序。他们判断两个key相等的标准也是：两个key通过equals方法比较返回true，两个key的hashCode值也相等。而判断value值相等的标准：只要两个对象通过equals方法比较返回true即可。</li>
<li>不能修改集合中的key，否则程序再也无法准确访问到Map中被修改过的key。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/04/210404Java-jihelei/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/04/210404Java-jihelei/" class="post-title-link" itemprop="url">Java常用集合类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-04 18:56:00 / 修改时间：19:24:21" itemprop="dateCreated datePublished" datetime="2021-04-04T18:56:00+08:00">2021-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>inkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p>
<h2 id="新建队列"><a href="#新建队列" class="headerlink" title="新建队列"></a><strong>新建队列</strong></h2><p>Queue<String> queue=new LinkedList<Steing>;</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h2><p>queue.offer(“a”);</p>
<h2 id="返回第一个元素，并在队列中删除"><a href="#返回第一个元素，并在队列中删除" class="headerlink" title="返回第一个元素，并在队列中删除"></a><strong>返回第一个元素，并在队列中删除</strong></h2><p>queue.poll();</p>
<h2 id="返回第一个元素"><a href="#返回第一个元素" class="headerlink" title="返回第一个元素"></a><strong>返回第一个元素</strong></h2><p>queue.element();</p>
<p>或者</p>
<p>queue.peek();</p>
<h1 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a><strong>Deque</strong></h1><p>双端队列（两端都可进出）</p>
<h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a><strong>新建</strong></h2><p>Deque<String>  deque= new LinkList&lt;&gt;();</p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a><strong>相关函数</strong></h2><p><img src="/images/pasted-210404.jpg"></p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="新建-1"><a href="#新建-1" class="headerlink" title="新建"></a><strong>新建</strong></h2><p>ArrayList<String> arraylist=new ArrayList<String>();</p>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h2><p>arraylist.get(0);//访问第1个元素</p>
<h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a><strong>修改元素</strong></h2><p>arraylist.set(2,”wiki”);</p>
<h2 id="计算大小"><a href="#计算大小" class="headerlink" title="计算大小"></a><strong>计算大小</strong></h2><p>arraylist.size();</p>
<h2 id="ArrayList排序"><a href="#ArrayList排序" class="headerlink" title="ArrayList排序"></a><strong>ArrayList排序</strong></h2><p>Collections.sort(arraylist);</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><strong>LinkedList</strong></h1><h2 id="与ArrayList的使用对比"><a href="#与ArrayList的使用对比" class="headerlink" title="与ArrayList的使用对比"></a><strong>与ArrayList的使用对比</strong></h2><p>以下情况使用 ArrayList :</p>
<p>频繁访问列表中的某一个元素。</p>
<p>只需要在列表末尾进行添加和删除元素操作。</p>
<p>以下情况使用 LinkedList :</p>
<p>你需要通过循环迭代来访问列表中的某些元素。</p>
<p>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a><strong>创建</strong></h2><p>LinkList<E> list=new LinkList<E>();</p>
<h2 id="开头添加-移除-获取元素"><a href="#开头添加-移除-获取元素" class="headerlink" title="开头添加/移除/获取元素"></a><strong>开头添加/移除/获取元素</strong></h2><p>list.addFirst(“Wiki”);</p>
<p>list.removeFirst();</p>
<p>list.getFirst();</p>
<h2 id="结尾添加元素"><a href="#结尾添加元素" class="headerlink" title="结尾添加元素"></a><strong>结尾添加元素</strong></h2><p>list.addLast(“hello”);</p>
<p>list.removeLast();</p>
<p>list.getLast();</p>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>
<p>HashSet 允许有 null 值。</p>
<p>HashSet 是无序的，即不会记录插入的顺序。</p>
<p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p>
<p>HashSet 实现了 Set 接口。</p>
<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a><strong>创建</strong></h2><p>HashSet<String> hashset=new HashSet<String>();</p>
<h2 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h2><p>hashset.add(“Google”);</p>
<p>注意，重复的元素不会被添加。</p>
<h2 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a><strong>判断元素是否存在</strong></h2><p>hashset.contains(“TaoBao”);</p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h2><p>hashset.remove(“TaoBao”);</p>
<h2 id="计算大小-1"><a href="#计算大小-1" class="headerlink" title="计算大小"></a><strong>计算大小</strong></h2><p>hashset.size();</p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><strong>HashMap</strong></h1><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>
<p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p>
<p>HashMap 是无序的，即不会记录插入的顺序。</p>
<p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p>
<h2 id="新建-2"><a href="#新建-2" class="headerlink" title="新建"></a><strong>新建</strong></h2><p>HashMap&lt;Integer,String&gt; Sites=new HashMap&lt;Integer,String&gt;();</p>
<h2 id="添加元素-2"><a href="#添加元素-2" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h2><p>Sites.put(1,”Google”);</p>
<h2 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h2><p>Sites.get(1);</p>
<p>使用get方法来获取key对应的value</p>
<h2 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h2><p>Sites.remove(1);</p>
<p>使用 remove(key) 方法来删除 key 对应的键值对(key-value)</p>
<p>删除所有键值对可以使用clear方法</p>
<p>Sites.clear();</p>
<h2 id="计算大小-2"><a href="#计算大小-2" class="headerlink" title="计算大小"></a><strong>计算大小</strong></h2><p>Sites.size();</p>
<h2 id="存在key-value"><a href="#存在key-value" class="headerlink" title="存在key/value"></a><strong>存在key/value</strong></h2><p>Sites.containsKey(1);</p>
<p>Sites.containsValue(“Google”);</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代HashMap:如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。</p>
<h2 id="返回或者默认值"><a href="#返回或者默认值" class="headerlink" title="返回或者默认值"></a>返回或者默认值</h2><p>获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值：getOrDefault()</p>
<h1 id="Java-Stack"><a href="#Java-Stack" class="headerlink" title="Java Stack"></a><strong>Java Stack</strong></h1><h2 id="新建-3"><a href="#新建-3" class="headerlink" title="新建"></a><strong>新建</strong></h2><p>Stack<Integer> st=new Stack<Integer>();</p>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p><img src="/images/pasted-210404stack.jpg"></p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>length()</p>
<h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><p>concat()</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>charAt(int index) ：返回指定索引处的 char 值。</p>
<p>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html"> int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p>
<h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">public delete(int start, int end) 移除此序列的子字符串中的字符。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/29/210329jjworldfupan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/210329jjworldfupan/" class="post-title-link" itemprop="url">竞技世界面试复盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 19:27:00" itemprop="dateCreated datePublished" datetime="2021-03-29T19:27:00+08:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-01 14:31:51" itemprop="dateModified" datetime="2021-04-01T14:31:51+08:00">2021-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RAM和ROM"><a href="#RAM和ROM" class="headerlink" title="RAM和ROM"></a>RAM和ROM</h1><p>RAM（random access memory）即随机存储内存，这种存储器在断电时将丢失其存储内容，故主要用于存储短时间使用的程序。ROM（Read-Only Memory）即只读内存，是一种只能读出事先所存数据的固态半导体存储器。</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存是操作系统内核为了对进程地址空间进行管理（process address space management）而精心设计的一个逻辑意义上的内存空间概念。</p>
<p>用户编制程序时使用的地址称为<strong>虚地址或逻辑地址</strong>，其对应的存储空间称为虚存空间或逻辑地址空间；而计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。</p>
<p><strong>引入虚拟存储技术的好处</strong>：<br>可在较小的可用内存中执行较大的用户程序；<br>可在内存中容纳更多程序并发执行；<br>不必影响编程时的程序结构（与覆盖技术比较）；</p>
<p>提供给用户可用的虚拟内存空间通常大于物理内存。</p>
<h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><p>理论上<em>SMTP</em>可以通过TCP,UDP或某些第三方协议来处理</p>
<p>DHCP 用的是UDP</p>
<h1 id="数据库主键"><a href="#数据库主键" class="headerlink" title="数据库主键"></a>数据库主键</h1><p><em>主键</em>只有一个,但是可以设置为多个字段为<em>主键</em>,也即联合<em>主键</em>。</p>
<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quicksort(<span class="keyword">int</span> []arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">int</span> start = low;</span><br><span class="line">    <span class="keyword">int</span> end = high;</span><br><span class="line">    <span class="keyword">int</span> key = arr[start];</span><br><span class="line">    <span class="keyword">while</span>(end &gt; start)&#123;</span><br><span class="line">        <span class="keyword">while</span>(end &gt; start&amp;&amp;arr[end]&gt;=key)&#123;</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[end]&lt;=key)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=arr[end];</span><br><span class="line">            arr[end]=arr[start];</span><br><span class="line">            arr[start]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end&gt;start&amp;&amp;arr[start]&lt;=key)&#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[start]&gt;=key)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=arr[start];</span><br><span class="line">            arr[start]=arr[end];</span><br><span class="line">            arr[end]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>使用哈夫曼编码来编码字符串”aaaabbcd”时，得到的编码长度为多少?</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43247186/article/details/87855415">https://blog.csdn.net/weixin_43247186/article/details/87855415</a></p>
<h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><p><em>字节是</em>一个存储单位 1个二进制位等于1Bit 8个Bit等于<em>1Byte</em>(字节)</p>
<p>C语言会自动在在双引号””括起来的内容的末尾补上”\0”代表结束，ASCII中的0号位也占用一个字符。</p>
<p>注意，了解了sizeof的真正含义后。类似如下的代码就很low了。</p>
<h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><p><strong>（数据看成字符串）</strong>大端——高尾端，小端——低尾端</p>
<p>我们的电脑通常是小端存储</p>
<h2 id="大小端各自的优点"><a href="#大小端各自的优点" class="headerlink" title="大小端各自的优点"></a>大小端各自的优点</h2><p>大端：符号位在所表示的内存的低地址，用于快速判断数据的正负和大小<br>小端：CPU做数值运算的时候是从内存中依次从低位到高位取数据进行运算，这样运算效率更高。</p>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>并发是指一个处理器同时处理多个任务。<br>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。<br>并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。<br>来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。</p>
<p>当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发(Concurrent)。</p>
<p>当系统有一个以上CPU时,则线程的操作有可能非并发.当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,这种方式我们称之为并行(Parallel)。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]并发并行的区别<a target="_blank" rel="noopener" href="https://blog.csdn.net/java_zero2one/article/details/51477791">https://blog.csdn.net/java_zero2one/article/details/51477791</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/28/Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/28/Git/" class="post-title-link" itemprop="url">Git</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-28 14:11:00" itemprop="dateCreated datePublished" datetime="2021-03-28T14:11:00+08:00">2021-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 21:09:02" itemprop="dateModified" datetime="2021-03-29T21:09:02+08:00">2021-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>学习git之前，我们需要先明白一个概念</p>
<p><strong>版本控制！</strong></p>
<h2 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
<ul>
<li>实现跨区域多人协同开发</li>
<li>追踪和记载一个或者多个文件的历史记录</li>
<li>组织和保护你的源代码和文档</li>
<li>统计工作量</li>
<li>并行开发、提高开发效率</li>
<li>跟踪记录整个软件的开发过程</li>
<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>
</ul>
<p>简单说就是用于管理多人协同开发项目的技术。</p>
<p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p>
<p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0C4qeLxMgoTg9B154ibahsUaibiaV7DgH9GTFQZj3Kyhf5fxrj6G2U5HFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>多人开发就必须要使用版本控制！</p>
<h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><p>我们学习的东西，一定是当下最流行的！</p>
<p>主流的版本控制器有如下这些：</p>
<ul>
<li><strong>Git</strong></li>
<li><strong>SVN</strong>（Subversion）</li>
<li><strong>CVS</strong>（Concurrent Versions System）</li>
<li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li>
<li><strong>TFS</strong>（Team Foundation Server）</li>
<li>Visual Studio Online</li>
</ul>
<p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p>
<h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><h3 id="1、本地版本控制"><a href="#1、本地版本控制" class="headerlink" title="1、本地版本控制"></a><strong>1、本地版本控制</strong></h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Dg3fHrbPqbNEOMO9GTjFhVaukMZWx54icS7eS2x8A7BEu0VB9ibwEhzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="2、集中版本控制-SVN"><a href="#2、集中版本控制-SVN" class="headerlink" title="2、集中版本控制  SVN"></a><strong>2、集中版本控制  SVN</strong></h3><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p>
<h3 id="3、分布式版本控制-Git"><a href="#3、分布式版本控制-Git" class="headerlink" title="3、分布式版本控制     Git"></a><strong>3、分布式版本控制     Git</strong></h3><p>每个人都拥有全部的代码！安全隐患！</p>
<p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>
<p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="Git与SVN的主要区别"><a href="#Git与SVN的主要区别" class="headerlink" title="Git与SVN的主要区别"></a>Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<h1 id="聊一聊Git的历史"><a href="#聊一聊Git的历史" class="headerlink" title="聊一聊Git的历史"></a>聊一聊Git的历史</h1><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p>
<h1 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h1><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p>打开 [git官网] <a target="_blank" rel="noopener" href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p>
<p>所有东西下载慢的话就可以去找镜像！</p>
<p>官网下载太慢，我们可以使用淘宝镜像下载：<a target="_blank" rel="noopener" href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210328143055320.png" alt="image-20210328143055320"></p>
<p>下载对应的版本即可安装！</p>
<p>安装：无脑下一步即可！安装完毕就可以使用了！</p>
<h2 id="启动Git"><a href="#启动Git" class="headerlink" title="启动Git"></a>启动Git</h2><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p>
<p><strong>Git CMD：</strong>Windows风格的命令行</p>
<p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p>
<h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p>
<p>1）、cd : (Change Directory)改变目录。</p>
<p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p>
<p>3）、pwd : (print work directory)显示当前所在的目录路径。</p>
<p>4）、ls(ll):  (list)都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p>
<p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p>
<p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p>
<p>7）、mkdir: (Make Directory) 新建一个目录,就是新建一个文件夹。</p>
<p>8）、rm -r : (Remove Directory) 删除一个文件夹, rm -r src 删除src目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！</span><br></pre></td></tr></table></figure>

<p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p>
<p>10）、reset 重新初始化终端/清屏。</p>
<p>11）、clear 清屏。</p>
<p>12）、history 查看命令历史。</p>
<p>13）、help 帮助。</p>
<p>14）、exit 退出。</p>
<p>15）、#表示注释</p>
<h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>所有的配置文件，其实都保存在本地！</p>
<p>查看配置 git config -l</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>查看不同级别的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看系统config</span><br><span class="line">git config --system --list　　</span><br><span class="line">#查看当前用户（global）配置</span><br><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure>

<p><strong>Git相关的配置文件：</strong></p>
<p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p>
<p>2）、C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p>
<h2 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;名称&quot;  #名称</span><br><span class="line">git config --global user.email 邮箱   #邮箱</span><br></pre></td></tr></table></figure>

<p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p>
<p>可以查看当前用户（global）配置<br>git config –global  –list</p>
<h1 id="Git基本原理"><a href="#Git基本原理" class="headerlink" title="Git基本原理"></a>Git基本原理</h1><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li>Workspace：工作区，就是你平时存放项目代码的地方</li>
<li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>git的工作流程一般是这样的：</p>
<p>１、在工作目录中添加、修改文件；</p>
<p>２、将需要进行版本管理的文件放入暂存区域；</p>
<p>３、将暂存区域的文件提交到git仓库。</p>
<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>
<p>日常使用只要记住下图6个命令：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>
<p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p>
<h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]  </span><br></pre></td></tr></table></figure>

<p>2、去 gitee 或者 github 上克隆一个测试！</p>
<h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li>
<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li>
<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li>
<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>
</ul>
<h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line">#查看所有文件状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"># git add .                  添加所有文件到暂存区# git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>



<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>
<p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p>
<ol>
<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">&#x2F;temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build&#x2F;       #忽略build&#x2F;目录下的所有文件</span><br><span class="line">doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure>

<h2 id="码云的使用"><a href="#码云的使用" class="headerlink" title="码云的使用"></a>码云的使用</h2><p>这个其实可以作为大家未来找工作的一个重要信息！</p>
<p>1、注册登录码云，完善个人信息</p>
<p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入 C:\Users\Administrator\.ssh 目录</span><br><span class="line"># 生成公钥</span><br><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>3、将公钥信息public key 添加到码云账户中即可！</p>
<p>4、使用码云创建一个自己的仓库！</p>
<h1 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h1><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p>
<p>git分支中常用指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line">#远程提交</span><br><span class="line">git push -u origin &lt;你要推送的分支名&gt;</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure>

<p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p>
<p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/26/210326datastructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clx.jpg">
      <meta itemprop="name" content="porridgechou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mynote">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/210326datastructure/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 19:21:00" itemprop="dateCreated datePublished" datetime="2021-03-26T19:21:00+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 21:08:17" itemprop="dateModified" datetime="2021-03-29T21:08:17+08:00">2021-03-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树查找的时间复杂度"><a href="#二叉树查找的时间复杂度" class="headerlink" title="二叉树查找的时间复杂度"></a>二叉树查找的时间复杂度</h2><p>如果<strong>二叉排序树是平衡</strong>的，则n个节点的二叉排序树的高度为Log2(n+1),其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。</p>
<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printIn(root);</span><br><span class="line">    PreOrder(root.left);</span><br><span class="line">    PreOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Stack&lt;TreeNode&gt; stack =<span class="keyword">new</span> Stack &lt;&gt;();</span><br><span class="line">	stack.push(root);</span><br><span class="line">	<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">		TreeNode node =stack.pop();</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ret.add(node.val);</span><br><span class="line">		stack.push(node.right);<span class="comment">//先右后左，保证左子树先出来</span></span><br><span class="line">		stack.push(node.left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">    visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret.add(node.val);</span><br><span class="line">        stack.push(node.left);</span><br><span class="line">        stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    visit(root);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        ret.add(node.val);</span><br><span class="line">        cur = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="porridgechou"
      src="/images/clx.jpg">
  <p class="site-author-name" itemprop="name">porridgechou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">porridgechou</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
